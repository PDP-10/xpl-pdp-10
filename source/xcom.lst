 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by version 4.0                               page 1
 line    source statement                                                               procedure and compiler information
 
    1   /*                                                                              *
    2                                p d p - 1 0   x p l                                *
    3                                v e r s i o n   1                                  *
    4        a compiler-compiler for programming language 1.                            *
    5                                                 richard l. bisbey ii              *
    6                                                 july 1971                         *
    7                                                                                   *
    8  version 4.0        november 1975.                                                *
    9                                                                                   *
   10        verion 4 of the compiler processes the entire xpl grammar.                 *
   11                                                                                   *
   12  version 3.0        november, 1975.                                               *
   13                                                                                   *
   14        version 3.0 contains the following differences from version 2.0:           *
   15        relocatable binary code output,                                            *
   16        call inline facility implemented,                                          *
   17        uuos used to call the run-time routines,                                   *
   18        some switches can be specified from the terminal,                          *
   19        "compactify" is compiled from a source library,                            *
   20        redundant saves of procedure results in other registers is                 *
   21           avoided in most instances.                                              *
   22                                                                                   *
   23        version 2.0                                                                *
   24        hash-coded symbol table,                                                   *
   25        left-to-right generation of strings from numbers,                          *
   26        special case checks in string catenation routine,                          *
   27        faster, more efficient procedure calls,                                    *
   28        general input/output, file, filename procedures,                           *
   29        better listing, symbol dump format, etc.                                   *
   30                                                                                   *
   31               r. w. hay,                                                          *
   32               computer group,                                                     *
   33               dept. of electrical eng.,                                           *
   34               university of toronto,                                              *
   35               toronto, ontario, canada.                                           *
   36                                                                                   *
   37                                                                                   *
   38        the main structure of the program is as follows:                           *
   39              contents.                                                            *
   40              recognition tables for the syntax analyzer.                          *
   41              declaration of scanner/compiler variables.                           *
   42              storage compactification procedure.                                  *
   43              scanner procedures.                                                  *
   44              parser procedures.                                                   *
   45              code/data emitter procedures.                                        *
   46              symbol table procedures.                                             *
   47              code generation procedures.                                          *
   48              initialization procedure.                                            *
   49              analysis algorithm.                                                  *
   50              production rules.                                                    *
   51     */                                                                            *
   52                                                                                   *
   53     declare VERSION literally '''4.0''';                                          *
   54                                                                                   *
   55           /*   these are lalr parsing tables   */                                 *
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 2
 line    source statement                                                               procedure and compiler information
 
   56                                                                                   *
   57           declare MAXR# literally '99'; /* max read # */                          *
   58                                                                                   *
   59           declare MAXL# literally '125'; /* max look # */                         *
   60                                                                                   *
   61           declare MAXP# literally '125'; /* max push # */                         *
   62                                                                                   *
   63           declare MAXS# literally '234'; /* max state # */                        *
   64                                                                                   *
   65           declare START_STATE literally '1';                                      *
   66                                                                                   *
   67           declare TERMINAL# literally '42'; /* # of terminals */                  *
   68                                                                                   *
   69           declare VOCAB# literally '91';                                          *
   70                                                                                   *
   71           declare vocab(VOCAB#) character initial ('','<','(','+','|','&','*',')' *
   72           ,';','~','-','/',',','>',':','=','||','by','do','go','if','to','bit'    *
   73           ,'end','eof','mod','call','case','else','goto','then','fixed','label'   *
   74           ,'while','return','declare','initial','<number>','<string>','character' *
   75           ,'literally','procedure','<identifier>','<term>','<type>','<go to>'     *
   76           ,'<group>','<ending>','<primary>','<program>','<replace>','<bit head>'  *
   77           ,'<constant>','<relation>','<variable>','<if clause>','<left part>'     *
   78           ,'<statement>','<true part>','<assignment>','<bound head>'              *
   79           ,'<expression>','<group head>','<if statement>','<initial head>'        *
   80           ,'<initial list>','<while clause>','<case selector>','<call statement>' *
   81           ,'<logical factor>','<parameter head>','<parameter list>'               *
   82           ,'<procedure head>','<procedure name>','<statement list>'               *
   83           ,'<subscript head>','<basic statement>','<go to statement>'             *
   84           ,'<identifier list>','<logical primary>','<step definition>'            *
   85           ,'<label definition>','<return statement>','<type declaration>'         *
   86           ,'<iteration control>','<logical secondary>','<string expression>'      *
   87           ,'<declaration element>','<procedure definition>'                       *
   88           ,'<arithmetic expression>','<declaration statement>'                    *
   89           ,'<identifier specification>');                                         *
   90                                                                                   *
   91           declare P# literally '109'; /* # of productions */                      *
   92                                                                                   *
   93           declare state_name(MAXR#) bit(8) initial (0,0,1,2,3,3,4,5,6,7,9,9,10,10 *
   94           ,11,12,13,16,17,18,19,20,21,22,23,25,26,27,33,34,35,36,37,37,40,42,42   *
   95           ,42,42,42,43,43,43,43,43,44,44,45,46,50,50,51,52,53,54,54,55,56,58,59   *
   96           ,60,61,61,61,61,61,61,61,61,61,61,62,64,66,67,68,69,69,70,71,72,73,74   *
   97           ,74,75,76,77,78,80,81,81,82,83,86,86,88,89,89,90,91);                   *
   98                                                                                   *
   99           declare RSIZE literally '337'; /*  read states info  */                 *
  100                                                                                   *
  101           declare LSIZE literally '69'; /* look ahead states info */              *
  102                                                                                   *
  103           declare ASIZE literally '105'; /* apply production states info */       *
  104                                                                                   *
  105           declare read1(RSIZE) bit(8) initial (0,8,18,19,20,26,29,34,35,42,15,2,3 *
  106           ,9,10,37,38,42,2,37,38,42,2,37,38,42,2,3,9,10,37,38,42,2,3,9,10,37,38   *
  107           ,42,2,37,38,42,22,31,32,39,2,3,10,37,38,42,1,13,15,2,37,38,42,2,37,38   *
  108           ,42,2,37,38,42,2,42,15,2,3,10,37,38,42,2,3,9,10,37,38,42,8,27,33,42,21  *
  109           ,2,3,9,10,37,38,42,2,3,9,10,37,38,42,2,42,2,37,38,42,42,2,3,9,10,37,38  *
  110           ,42,2,3,9,10,37,38,42,2,3,9,10,37,38,42,2,42,2,7,7,38,2,14,2,40,7,12,7  *
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 3
 line    source statement                                                               procedure and compiler information
 
  111           ,12,6,11,25,6,11,25,6,11,25,6,11,25,6,11,25,8,8,42,8,2,3,9,10,37,38,42  *
  112           ,2,3,9,10,37,38,42,37,7,12,2,3,10,37,38,42,12,15,15,8,18,19,20,26,29,34 *
  113           ,35,42,42,8,18,19,20,26,29,34,35,42,8,37,4,30,4,4,7,12,4,4,4,7,4,4,21,4 *
  114           ,17,4,8,18,19,20,23,26,29,34,35,42,37,38,8,8,8,5,5,42,8,22,31,32,39,8   *
  115           ,18,19,20,26,29,34,35,42,2,8,22,31,32,39,8,18,19,20,24,26,29,34,35,42,8 *
  116           ,18,19,20,23,26,29,34,35,42,2,3,9,10,37,38,42,28,8,42,8,8,18,19,20,26   *
  117           ,29,34,35,41,42,8,18,19,20,23,26,29,34,35,41,42,8,36,1,9,13,15,16,16,8  *
  118           ,3,10,3,10,8,12,2,22,31,32,39);                                         *
  119                                                                                   *
  120           declare look1(LSIZE) bit(8) initial (0,15,0,15,0,42,0,8,0,2,14,0,2,0,40 *
  121           ,0,6,11,25,0,6,11,25,0,6,11,25,0,6,11,25,0,6,11,25,0,4,0,4,0,4,0,4,0,8  *
  122           ,0,4,0,5,0,5,0,28,0,36,0,1,9,13,15,16,0,16,0,3,10,0,3,10,0);            *
  123                                                                                   *
  124           /*  push states are built-in to the index tables  */                    *
  125                                                                                   *
  126           declare apply1(ASIZE) bit(8) initial (0,0,80,0,56,58,71,82,83,0,56,89   *
  127           ,90,0,89,90,0,0,0,0,0,0,0,0,0,0,0,0,0,0,83,90,0,71,83,90,0,0,0,0,0,0,15 *
  128           ,0,0,9,79,99,0,0,0,0,0,0,0,57,0,55,0,0,3,18,22,27,28,29,49,50,84,0,6,0  *
  129           ,7,0,10,0,0,53,0,17,0,4,5,12,13,0,8,14,25,0,1,19,26,56,57,58,71,80,82   *
  130           ,83,89,90,0,0,72,0);                                                    *
  131                                                                                   *
  132           declare read2(RSIZE) bit(8) initial (0,138,19,20,21,26,174,103,30,104   *
  133           ,213,3,4,10,12,234,233,105,3,234,233,105,3,234,233,105,3,4,10,12,234    *
  134           ,233,105,3,4,10,12,234,233,105,3,234,233,105,23,182,184,183,3,4,12,234  *
  135           ,233,105,211,212,210,3,234,233,105,3,234,233,105,3,234,233,105,190,106  *
  136           ,214,3,4,12,234,233,105,3,4,10,12,234,233,105,146,27,28,105,173,3,4,10  *
  137           ,12,234,233,105,3,4,10,12,234,233,105,186,166,3,234,233,105,105,3,4,10  *
  138           ,12,234,233,105,3,4,10,12,234,233,105,3,4,10,12,234,233,105,190,106,193 *
  139           ,9,185,178,231,168,231,34,189,191,162,164,8,14,25,8,14,25,8,14,25,8,14  *
  140           ,25,8,14,25,158,160,172,132,3,4,10,12,234,233,105,3,4,10,12,234,233,105 *
  141           ,33,192,194,3,4,12,234,233,105,198,197,197,138,19,20,21,26,174,103,30   *
  142           ,104,105,138,19,20,21,26,174,103,30,104,131,32,6,143,6,6,230,232,6,6,6  *
  143           ,228,6,6,22,6,18,6,138,19,20,21,102,26,174,103,30,104,234,233,148,149   *
  144           ,135,7,7,39,159,23,182,184,183,138,19,20,21,26,174,103,30,104,163,157   *
  145           ,23,182,184,183,138,19,20,21,126,26,174,103,30,104,138,19,20,21,102,26  *
  146           ,174,103,30,104,3,4,10,12,234,233,105,144,136,38,147,138,19,20,21,26    *
  147           ,174,103,30,161,104,138,19,20,21,102,26,174,103,30,161,104,134,31,100   *
  148           ,11,101,207,17,17,133,5,13,5,13,137,15,187,23,182,184,183);             *
  149                                                                                   *
  150           declare look2(LSIZE) bit(8) initial (0,2,208,16,209,24,165,169,29,35,35 *
  151           ,229,36,229,37,188,40,40,40,217,41,41,41,220,42,42,42,221,43,43,43,218  *
  152           ,44,44,44,219,62,170,64,155,65,154,67,195,152,69,70,153,76,199,77,200   *
  153           ,85,129,92,177,93,93,93,93,93,205,94,206,96,96,215,97,97,216);          *
  154                                                                                   *
  155           declare apply2(ASIZE) bit(8) initial (0,0,83,82,140,141,150,128,128,127 *
  156           ,120,139,139,129,142,142,130,56,58,48,71,88,151,73,74,95,80,81,79,78    *
  157           ,156,167,145,90,90,90,89,91,75,86,47,98,176,175,121,180,46,179,45,51,60 *
  158           ,99,87,181,72,196,59,50,49,57,66,117,116,113,114,112,115,68,63,61,119   *
  159           ,118,202,201,204,203,53,123,122,125,124,108,110,109,111,107,223,224,225 *
  160           ,222,54,55,171,54,54,54,54,54,54,54,54,54,227,84,52,226);               *
  161                                                                                   *
  162           declare index1(MAXS#) bit(16) initial (0,1,10,11,18,22,26,33,40,44,48   *
  163           ,54,57,61,65,69,71,72,78,85,89,90,97,104,105,106,110,111,118,125,132    *
  164           ,134,135,136,137,138,140,141,142,144,146,149,152,155,158,161,162,163    *
  165           ,164,165,172,179,180,182,188,190,191,200,201,210,211,212,214,215,218    *
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 4
 line    source statement                                                               procedure and compiler information
 
  166           ,219,220,222,223,225,227,228,238,240,241,242,243,244,245,246,251,260    *
  167           ,266,276,286,293,294,295,296,297,307,318,319,320,325,326,327,329,331    *
  168           ,333,1,3,5,7,9,12,14,16,20,24,28,32,36,38,40,42,44,46,48,50,52,54,56,62 *
  169           ,64,67,1,2,2,4,4,10,10,10,10,10,10,10,10,10,14,14,14,17,18,19,20,20,20  *
  170           ,20,20,21,22,22,23,24,25,26,26,26,26,27,28,29,29,30,30,30,33,37,37,38   *
  171           ,39,40,40,41,41,42,42,44,44,44,45,45,45,45,49,50,51,51,52,52,53,54,54   *
  172           ,55,55,57,59,60,60,70,70,72,72,74,74,76,76,76,76,76,76,76,76,77,77,79   *
  173           ,79,79,79,79,81,81,81,81,86,86,86,90,90,103,103,104,104);               *
  174                                                                                   *
  175           declare index2(MAXS#) bit(8) initial (0,9,1,7,4,4,7,7,4,4,6,3,4,4,4,2,1 *
  176           ,6,7,4,1,7,7,1,1,4,1,7,7,7,2,1,1,1,1,2,1,1,2,2,3,3,3,3,3,1,1,1,1,7,7,1  *
  177           ,2,6,2,1,9,1,9,1,1,2,1,3,1,1,2,1,2,2,1,10,2,1,1,1,1,1,1,5,9,6,10,10,7,1 *
  178           ,1,1,1,10,11,1,1,5,1,1,2,2,2,5,2,2,2,2,3,2,2,4,4,4,4,4,2,2,2,2,2,2,2,2  *
  179           ,2,2,6,2,3,3,1,0,1,0,0,1,1,1,1,1,1,1,0,1,1,2,1,2,1,1,1,2,2,2,1,3,1,3,1  *
  180           ,1,2,1,2,2,3,1,2,0,2,0,1,1,1,0,1,1,1,1,0,1,2,0,2,1,3,1,0,0,0,2,1,1,0,2  *
  181           ,0,2,2,1,2,2,1,0,1,0,2,0,2,0,1,0,2,0,0,0,1,1,1,1,1,0,2,0,2,2,1,1,0,2,2  *
  182           ,2,0,0,2,0,2,1,2,0,0);                                                  *
  183                                                                                   *
  184                                                                                   *
  185     /*  declarations for the scanner                                        */    *
  186     /* token is the index into the vocabulary v() of the last symbol scanned,     *
  187        cp is the pointer to the last character scanned in the cardimage,          *
  188        bcd is the last symbol scanned (literal character string). */              *
  189                                                                                   *
  190     declare token fixed, bcd character, ch fixed, cp fixed;                       *
  191                                                                                   *
  192     /* set up some convenient abbreviations for printer control */                *
  193                                                                                   *
  194     declare TRUE literally '"1"', FALSE literally '"0"',                          *
  195        FOREVER literally 'while TRUE',                                            *
  196        x70 character initial ('                                                   *
  197                                ');                                                *
  198     declare pointer character initial    ('                                       *
  199                                                             |');                  *
  200     /* length of longest symbol in v */                                           *
  201     declare reserved_limit fixed;                                                 *
  202                                                                                   *
  203     /* chartype() is used to distinguish classes of symbols in the scanner.       *
  204        tx() is a table used for translating from one character set to another.    *
  205        control() holds the value of the compiler control toggles set in $ cards.  *
  206        not_letter_or_digit() is similiar to chartype() but used in scanning       *
  207        identifiers only.                                                          *
  208                                                                                   *
  209        all are used by the scanner and control() is set there.                    *
  210     */                                                                            *
  211     declare chartype(255) bit(8), tx(255) bit(8), control(255) bit(1),            *
  212        not_letter_or_digit(255) bit(1);                                           *
  213     /* buffer holds the latest cardimage,                                         *
  214        text holds the present state of the input text                             *
  215        (not including the portions deleted by the scanner),                       *
  216        text_limit is a convenient place to store the pointer to the end of text,  *
  217        card_count is incremented by one for every source card read,               *
  218        error_count tabulates the errors as they are detected,                     *
  219        severe_errors tabulates those errors of fatal significance.                *
  220        current_procedure contains the name of the procedure being processed.      *
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 5
 line    source statement                                                               procedure and compiler information
 
  221     */                                                                            *
  222     declare buffer character, text character, text_limit fixed,                   *
  223         card_count fixed, error_count fixed,                                      *
  224         severe_errors fixed, previous_error fixed,                                *
  225         line_length  fixed,         /* length of source statement */              *
  226         current_procedure character;                                              *
  227                                                                                   *
  228     /* number_value contains the numeric value of the last constant scanned,      *
  229     */                                                                            *
  230     declare number_value fixed, jbase fixed, base fixed;                          *
  231     /* each of the following contains the index into v() of the corresponding     *
  232        symbol.   we ask:    if token = ident    etc.    */                        *
  233     declare ident fixed, string fixed, number fixed, divide fixed, eofile fixed,  *
  234        labelset fixed;                                                            *
  235     declare orsymbol fixed, concatenate fixed;                                    *
  236     declare balance character, lb fixed ;                                         *
  237     declare MACRO_LIMIT literally '60', macro_name (MACRO_LIMIT) character,       *
  238        macro_text(MACRO_LIMIT) character, macro_index (255) bit (8),              *
  239        macro_count (MACRO_LIMIT) fixed, macro_declare (MACRO_LIMIT) fixed,        *
  240        top_macro fixed;                                                           *
  241     declare expansion_count fixed, EXPANSION_LIMIT literally '300';               *
  242     /* stopit() is a table of symbols which are allowed to terminate the error    *
  243        flush process.  in general they are symbols of sufficient syntactic        *
  244        hierarchy that we expect to avoid attempting to start checking again       *
  245        right into another error producing situation.  the token stack is also     *
  246        flushed down to something acceptable to a stopit() symbol.                 *
  247        failsoft is a bit which allows the compiler one attempt at a gentle        *
  248        recovery.   then it takes a strong hand.   when there is real trouble      *
  249        compiling is set to FALSE, thereby terminating the compilation.            *
  250     */                                                                            *
  251     declare stopit(TERMINAL#) bit(1), failsoft fixed, compiling fixed;            *
  252     /*   the following switch is used by the lalr parser   */                     *
  253                                                                                   *
  254     declare no_look_ahead_done bit(1);                                            *
  255     declare target_register fixed;       /* for findar */                         *
  256     declare trueloc fixed;               /* location of constant 1 */             *
  257     declare falseloc fixed;              /* location of constant 0 */             *
  258     declare byteptrs fixed,              /* location of 4 ptrs for ldb & dpb */   *
  259             psbits fixed;                /* byte ptrs fore move */                *
  260     declare string_check fixed,          /* compactify caller */                  *
  261             catentry fixed,              /* catenation subroutine */              *
  262             nmbrentry fixed,             /* number to string subroutine */        *
  263             strcomp fixed,               /* string compare subroutine */          *
  264             calltype fixed initial (1),  /* dist between sub & function */        *
  265             mover fixed,                 /* string move subroutine */             *
  266             string_recover fixed,        /* syt location of compactify */         *
  267             corebyteloc fixed,           /* syt location of corebyte */           *
  268             limitword fixed,             /* address of freelimit */               *
  269             tsa fixed;                   /* address of freepoint */               *
  270     declare ndesc fixed;                 /* address of ndescript               */ *
  271     declare library fixed,               /* address of runtime library */         *
  272             library_save fixed,          /* place to store r11 on lib calls */    *
  273             str  fixed;                  /* descriptor of last string */          *
  274     declare stepk fixed;                 /* used for do loops */                  *
  275     declare a fixed, b fixed, c fixed;   /* for catenation & conversion */        *
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 6
 line    source statement                                                               procedure and compiler information
 
  276     declare lengthmask fixed;            /* addr of dv length mask */             *
  277     declare addrmask fixed;              /* address of "fffff" */                 *
  278     declare label_sink fixed initial(0); /* for label generator */                *
  279     declare label_gen character;         /* contains label for next inst*/        *
  280     declare acc(15) fixed;               /* keeps track of accumulators */        *
  281     declare AVAIL literally '0', BUSY literally '1';                              *
  282      /* call counts of important procedures */                                    *
  283     declare count_scan fixed, /* scan               */                            *
  284              count_inst fixed,  /* emitinst           */                          *
  285              count_force fixed, /* forceaccumulator   */                          *
  286              count_arith fixed, /* arithemit          */                          *
  287              count_store fixed; /* genstore           */                          *
  288                                                                                   *
  289     declare title        character,     /*title line for listing */               *
  290             subtitle     character,     /*subtitle for listing */                 *
  291             page_count   fixed,         /*current page number for listing*/       *
  292             line_count   fixed,         /*number of lines printed */              *
  293             PAGE_MAX literally '54',    /*max no of lines on page*/               *
  294             EJECT_PAGE literally 'line_count = PAGE_MAX+1';                       *
  295     declare source character;           /*file name being compiled*/              *
  296     declare DATAFILE literally '2';     /* scratch file for data */               *
  297     declare CODEFILE literally '3';     /* scratch file for code */               *
  298     declare RELFILE  literally '4';     /* binary output file */                  *
  299     declare LIBFILE  literally '5';     /* source library file */                 *
  300     declare reading  bit(1);            /* 0 iff reading LIBFILE */               *
  301     declare datacard character;         /* data buffer */                         *
  302     declare pp      fixed,              /* current program pointer */             *
  303             code(3) character,           /* the code buffer */                    *
  304             code_full(3) bit(1),         /* fullness flag */                      *
  305             code_head fixed,             /* front of buffer */                    *
  306             code_tail fixed,             /* end of buffer */                      *
  307             dp      fixed,              /* current data pointer */                *
  308             dpoffset fixed;             /* current dp byte offset */              *
  309     declare codestring character;     /*for copying code into data file*/         *
  310                                                                                   *
  311     /*   the following are for relocatable binary code emission */                *
  312                                                                                   *
  313     declare BUFFERSIZE literally '18';   /* size of binary buffers */             *
  314     declare code_buffer (BUFFERSIZE) fixed;   /*code (high) buffer */             *
  315     declare data_buffer (BUFFERSIZE) fixed;   /* data (low) buffer */             *
  316     declare label_buffer (BUFFERSIZE) fixed;  /* labels defined buffer */         *
  317     declare code_rel(3) fixed,         /* binary code buffer (see code) */        *
  318             code_pp(3) fixed,                                                     *
  319             code_rbits(3) fixed;                                                  *
  320                                                                                   *
  321     declare rptr fixed,                  /* pointer to code_buffer */             *
  322             rctr fixed,                  /* counter for code_buffer */            *
  323             dptr fixed,                   /* pointer to data_buffer */            *
  324             dctr fixed,                  /* counter for data_buffer */            *
  325             dloc fixed;                   /* location of next word in data buffer */*
  326     declare label_count fixed;            /*no of labels in label_buffer */       *
  327                                                                                   *
  328     declare FOR_MAX  literally '50';      /* maximum forward references */        *
  329     declare for_ref   (FOR_MAX) fixed,    /* forward referenced labels */         *
  330             for_label (FOR_MAX) fixed,    /* label referenced */                  *
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 7
 line    source statement                                                               procedure and compiler information
 
  331             for_count fixed;              /* count of current forward refs */     *
  332     declare pword fixed;                  /* part-word acc. for bytes*/           *
  333     declare startloc fixed;               /* first instruction to be executed */  *
  334                                                                                   *
  335                                                                                   *
  336     declare CODE_TYPE literally '"(3)1000000"';   /* code & data type block */    *
  337     declare SYMB_TYPE literally '"(3)2000000"';   /* symbol defn type block */    *
  338     declare HISEG_TYPE literally '"(3)3000000"';  /* high segment type block */   *
  339     declare END_TYPE literally '"(3)5000000"';    /* end type block */            *
  340     declare NAME_TYPE literally '"(3)6000000"';   /* name type block */           *
  341     declare START_TYPE literally '"(3)7000000"';  /* start address type block */  *
  342     declare INTREQ_TYPE literally '"(3)10000000"'; /* internal request type block */*
  343                                                                                   *
  344                                                                                   *
  345     /* end of definitions for relocatable binary files */                         *
  346                                                                                   *
  347     declare adr     fixed;                                                        *
  348     declare itype fixed;                                                          *
  349     declare newdp fixed, newdsp fixed, newdpoffset fixed; /* for allocation */    *
  350     declare olddp fixed, olddsp fixed, olddpoffset fixed; /* for allocation */    *
  351     declare DESCLIMIT literally '1000', /* number of string descriptors */        *
  352             desca (DESCLIMIT) fixed,     /* string descriptor address */          *
  353             descl (DESCLIMIT) fixed,     /* string descriptor length */           *
  354             descref (DESCLIMIT) fixed,    /* last reference to string */          *
  355             dsp     fixed;              /* descriptor pointer */                  *
  356     declare s character;                                                          *
  357     declare opname (15) character initial (                                       *
  358  '      .init..inpt..outp..exit.      .fili..filo..name.',                        *
  359  'call  init  uuo042uuo043uuo044uuo045uuo046calli open  ttcalluuo052uuo053uuo054  *
  360  renamein    out   setstsstato getstsstatz inbuf outbufinput outputclose          *
  361  releasmtape ugetf useti useto lookupenter ',                                     *
  362  'uuo100uuo101uuo102uuo103uuo104uuo105uuo106uuo107uuo110uuo111uuo112uuo113uuo114u *
  363  uo115uuo116uuo117uuo120uuo121uuo122uuo123uuo124uuo125uuo126uuo127ufa   dfn   fsc *
  364     ibp   ildb  ldb   idpb  dpb   ',                                              *
  365  '',                                                                              *
  366  'move  movei movem moves movs  movsi movsm movss movn  movni movnm movns movm  m *
  367  ovmi movmm movms imul  imuli imulm imulb mul   muli  mulm  mulb  idiv  idivi idi *
  368  vm idivb div   divi  divm  divb  ',                                              *
  369  'ash   rot   lsh   jffo  ashc  rotc  lshc  ......exch  blt   aobjp aobjn jrst  j *
  370  fcl  xct   ......pushj push  pop   popj  jsr   jsp   jsa   jra   add   addi  add *
  371  m  addb  sub   subi  subm  subb  ',                                              *
  372  'cai   cail  caie  caile caia  caige cain  caig  cam   caml  came  camle cama  c *
  373  amge camn  camg  jump  jumpl jumpe jumplejumpa jumpgejumpn jumpg skip  skipl ski *
  374  pe skipleskipa skipgeskipn skipg ',                                              *
  375   'aoj   aojl  aoje  aojle aoja  aojge aojn  aojg  aos   aosl  aose  aosle aosa  a*
  376  osge aosn  aosg  soj   sojl  soje  sojle soja  sojge sojn  sojg  sos   sosl  sos *
  377  e  sosle sosa  sosge sosn  sosg  ',                                              *
  378  'setz  setzi setzm setzb and   andi  anmd  andb  andca andcaiandcamandcabsetm  s *
  379  etmi setmm setmb andcm andcmiandcmmandcmbseta  setai setam setab xor   xori  xor *
  380  m  xorb  ior   iori  iorm  iorb  ',                                              *
  381  'andcb andcbiandcbmandcbbeqv   eqvi  eqvm  eqvb  setca setcaisetcamsetcaborca  o *
  382  rcai orcam orcab setcm setcmisetcmmsetcmborcm  orcmi orcmm orcmb orcb  orcbi orc *
  383  bm orcbb seto  setoi setom setob ',                                              *
  384  'hll   hlli  hllm  hlls  hrl   hrli  hrlm  hrls  hllz  hllzi hllzm hllzs hrlz  h *
  385  rlzi hrlzm hrlzs hllo  hlloi hllom hllos hrlo  hrloi hrlom hrlos hlle  hllei hll *
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 8
 line    source statement                                                               procedure and compiler information
 
  386  em hlles hrle  hrlei hrlem hrles ',                                              *
  387  'hrr   hrri  hrrm  hrrs  hlr   hlri  hlrm  hlrs  hrrz  hrrzi hrrzm hrrzs hlrz  h *
  388  lrzi hlrzm hlrzs hrro  hrroi hrrom hrros hlro  hlroi hlrom hlros hrre  hrrei hrr *
  389  em hrres hlre  hlrei hlrem hlres ',                                              *
  390  'trn   tln   trne  tlne  trna  tlna  trnn  tlnn  tdn   tsn   tdne  tsne  tdna  t *
  391  sna  tdnn  tsnn  trz   tlz   trze  tlze  trza  tlza  trzn  tlzn  tdz   tsz   tdz *
  392  e  tsze  tdza  tsza  tdzn  tszn  ',                                              *
  393  'trc   tlc   trce  tlce  trca  tlca  trcn  tlcn  tdc   tsc   tdce  tsce  tdca  t *
  394  sca  tdcn  tscn  tro   tlo   troe  tloe  troa  tloa  tron  tlon  tdo   tso   tdo *
  395  e  tsoe  tdoa  tsoa  tdon  tson  ',                                              *
  396  '',                                                                              *
  397  '');                                                                             *
  398     declare instruct(511) fixed;         /* count of the instructions issued */   *
  399           /* commonly used opcodes */                                             *
  400     declare add    fixed initial ("(3)270"),                                      *
  401             addi   fixed initial ("(3)271"),                                      *
  402             addm   fixed initial ("(3)272"),                                      *
  403             and    fixed initial ("(3)404"),                                      *
  404             andi   fixed initial ("(3)405"),                                      *
  405             aosa   fixed initial ("(3)354"),                                      *
  406             blt    fixed initial ("(3)251"),                                      *
  407             calli  fixed initial ("(3)047"),                                      *
  408             cam    fixed initial ("(3)310"),                                      *
  409             camge  fixed initial ("(3)315"),                                      *
  410             caml   fixed initial ("(3)311"),                                      *
  411             camle  fixed initial ("(3)313"),                                      *
  412             camn   fixed initial ("(3)316"),                                      *
  413             cmprhi fixed initial ("(3)317"),                                      *
  414             dpb    fixed initial ("(3)137"),                                      *
  415             hll    fixed initial ("(3)500"),                                      *
  416             hlrz   fixed initial ("(3)554"),                                      *
  417             hrli   fixed initial ("(3)505"),                                      *
  418             hrlm   fixed initial ("(3)506"),                                      *
  419             hrrei  fixed initial ("(3)571"),                                      *
  420             idiv   fixed initial ("(3)230"),                                      *
  421             idivi  fixed initial ("(3)231"),                                      *
  422             idpb   fixed initial ("(3)136"),                                      *
  423             ildb   fixed initial ("(3)134"),                                      *
  424             imul   fixed initial ("(3)220"),                                      *
  425             ior    fixed initial ("(3)434"),                                      *
  426             jrst   fixed initial ("(3)254"),                                      *
  427             jump   fixed initial ("(3)320"),                                      *
  428             jumpe  fixed initial ("(3)322"),                                      *
  429             jumpge fixed initial ("(3)325"),                                      *
  430             jumpn  fixed initial ("(3)326"),                                      *
  431             ldb    fixed initial ("(3)135"),                                      *
  432             lsh    fixed initial ("(3)242"),                                      *
  433             lshc   fixed initial ("(3)246"),                                      *
  434             move   fixed initial ("(3)200"),                                      *
  435             movei  fixed initial ("(3)201"),                                      *
  436             movem  fixed initial ("(3)202"),                                      *
  437             movm   fixed initial ("(3)214"),                                      *
  438             movn   fixed initial ("(3)210"),                                      *
  439             pop    fixed initial ("(3)262"),                                      *
  440             popj   fixed initial ("(3)263"),                                      *
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 9
 line    source statement                                                               procedure and compiler information
 
  441             push   fixed initial ("(3)261"),                                      *
  442             pushj  fixed initial ("(3)260"),                                      *
  443             rot    fixed initial ("(3)241"),                                      *
  444             setca  fixed initial ("(3)450"),                                      *
  445             setzm  fixed initial ("(3)402"),                                      *
  446             skip   fixed initial ("(3)330"),                                      *
  447             skipe  fixed initial ("(3)332"),                                      *
  448             sojg   fixed initial ("(3)367"),                                      *
  449             sub    fixed initial ("(3)274"),                                      *
  450             subi   fixed initial ("(3)275");                                      *
  451     declare compareswap (7) fixed initial (0,7,2,5,0,3,6,1);                      *
  452     declare stillcond fixed,            /* peep hole for bool branching */        *
  453             stillinzero fixed;          /* peephole for redundant moves */        *
  454     declare statement_count fixed;      /* a count of the xpl statements */       *
  455     declare idcompares fixed;                                                     *
  456     declare x1 character initial (' ');                                           *
  457     declare x2 character initial ('  ');                                          *
  458     declare x3 character initial ('   ');                                         *
  459     declare x4 character initial ('    ');                                        *
  460     declare x7 character initial ('       ');                                     *
  461     declare info character;         /* for listing information*/                  *
  462     declare char_temp character;                                                  *
  463     declare i_string character;      /* for i_format */                           *
  464     declare i fixed, j fixed, k fixed, l fixed;                                   *
  465     declare procmark fixed, ndecsy fixed, maxndecsy fixed, parct fixed;           *
  466     declare returned_type fixed;                                                  *
  467     declare LABELTYPE     literally  '1',                                         *
  468             ACCUMULATOR   literally  '2',                                         *
  469             VARIABLE      literally  '3',                                         *
  470             CONSTANT      literally  '4',                                         *
  471             CHRTYPE       literally  '6',                                         *
  472             FIXEDTYPE     literally  '7',                                         *
  473             BYTETYPE      literally  '8',                                         *
  474             FORWARDTYPE   literally  '9',                                         *
  475             DESCRIPT      literally '10',                                         *
  476             SPECIAL       literally '11',                                         *
  477             FORWARDCALL   literally '12',                                         *
  478             PROCTYPE      literally '13',                                         *
  479             CHARPROCTYPE  literally '14';                                         *
  480     declare typename (14) character initial ('', 'label    ', '', '', '', '',     *
  481             'character', 'fixed    ', 'bit (9)  ' , '', '', '', '',               *
  482             'procedure','character procedure');                                   *
  483     /*  the symbol table is initialized with the names of all                     *
  484         builtin functions and pseudo variables.  the procedure                    *
  485         initialize depends on the order and placement of these                    *
  486         names.  changes should be made observing due caution to                   *
  487         avoid messing things up.                                                  *
  488     */                                                                            *
  489     declare SYTSIZE literally '420';     /* the symbol table size */              *
  490     declare syt (SYTSIZE) character      /* the VARIABLE name */                  *
  491        initial ('coreword', 'corebyte', 'freepoint', 'descriptor',                *
  492           'ndescript',   'length', 'substr', 'byte', 'shl', 'shr',                *
  493           'input', 'output', 'file', 'inline', 'trace', 'untrace',                *
  494           'exit', 'time', 'date', 'clock_trap', 'interrupt_trap',                 *
  495           'monitor', 'addr', 'runtime', 'filename',                               *
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 10
 line    source statement                                                               procedure and compiler information
 
  496           'compactify', 'freelimit', 'freebase');                                 *
  497     declare sytype (SYTSIZE) bit (8)     /* type of VARIABLE */                   *
  498        initial (FIXEDTYPE, BYTETYPE, FIXEDTYPE, FIXEDTYPE,                        *
  499           FIXEDTYPE, SPECIAL, SPECIAL, SPECIAL, SPECIAL, SPECIAL,                 *
  500           SPECIAL, SPECIAL, SPECIAL, SPECIAL, SPECIAL, SPECIAL,                   *
  501            SPECIAL, SPECIAL, SPECIAL, SPECIAL, SPECIAL,                           *
  502           SPECIAL, SPECIAL, SPECIAL, SPECIAL,                                     *
  503           FORWARDCALL, FIXEDTYPE, FIXEDTYPE);                                     *
  504     declare sytloc (SYTSIZE) fixed       /* location of VARIABLE */               *
  505        initial (0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,     *
  506            0,0,0);                                                                *
  507     declare sytseg (SYTSIZE) bit(8)      /* segment of VARIABLE */                *
  508        initial (0,0,1,3,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,1,1);         *
  509     declare sytco (SYTSIZE) fixed;       /* a count of references */              *
  510     declare sytcard (SYTSIZE) fixed;     /* where symbol is defined */            *
  511                                                                                   *
  512     declare hash (255)      fixed,       /* hash table into symbol table*/        *
  513             ptr  (SYTSIZE)  fixed,       /* points to next symbol in hash*/       *
  514             idx             fixed;       /* index while using hash*/              *
  515                                                                                   *
  516     /*  the compiler stacks declared below are used to drive the syntactic        *
  517        analysis algorithm and store information relevant to the interpretation    *
  518        of the text.  the stacks are all pointed to by the stack pointer sp.  */   *
  519     declare STACKSIZE literally '50';  /* size of stack  */                       *
  520     declare state_stack (STACKSIZE)  bit (8);                                     *
  521     declare type        (STACKSIZE)  fixed;                                       *
  522     declare reg         (STACKSIZE)  fixed;                                       *
  523     declare inx         (STACKSIZE)  fixed;                                       *
  524     declare cnt         (STACKSIZE)  fixed;                                       *
  525     declare var         (STACKSIZE)  character;                                   *
  526     declare fixv        (STACKSIZE)  fixed;                                       *
  527     declare ppsave      (STACKSIZE)  fixed;                                       *
  528     declare fixl        (STACKSIZE)  fixed;                                       *
  529     declare sp fixed, mp fixed, mpp1 fixed;                                       *
  530                                                                                   *
  531     declare CASELIMIT literally '175',                                            *
  532             casestack (CASELIMIT) fixed, /* contains addr of stmts of case */     *
  533             casep  fixed;                /* points to current casestack entry */  *
  534                                                                                   *
  535     declare codemsg  character initial ('code = '),                               *
  536             datamsg  character initial ('data = '),                               *
  537             backmsg  character initial ('back up code emitter'),                  *
  538             filemsg  character initial ('missing number for file');               *
  539                                                                                   *
  540                                                                                   *
  541  /*                                                                               *
  542            g l o b a l   p r o c e d u r e s                                      *
  543  */                                                                               *
  544                                                                                   *
  545  i_format:                                                                        *
  546     procedure (number, width);                                                    *
  547     declare number  fixed,                                                         i_format
  548             width   fixed;                                                         i_format
  549     declare l       fixed;                                                         i_format
  550     i_string = number;                                                             i_format
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 11
 line    source statement                                                               procedure and compiler information
 
  551     l = length (i_string);                                                         i_format
  552     if l < width then                                                              i_format
  553           i_string = substr(x70,0,width-l) || i_string;                            i_format
  554     end  i_format;                                                                 i_format
 
symbol table dump
 
symbol          type       loc   segment defined ref count
l               fixed      9113     data    549       3
number          fixed      9111     data    546       1
width           fixed      9112     data    546       2
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 12
 line    source statement                                                               procedure and compiler information
 
  555                                                                                   *
  556  printline:                                                                       *
  557     procedure (line, ind);                                                        *
  558     declare line character,             /*line to be printed */                    printline
  559             ind fixed;                  /*format indicator*/                       printline
  560     declare ctl(5) character initial ('0','1','','','','');                        printline
  561     declare skips (5) fixed initial (2,99,0,0,0,0);                                printline
  562     if line_count > PAGE_MAX then                                                  printline
  563        do;                                                                         printline
  564           page_count = page_count + 1;                                             printline
  565           output(1) = title || page_count;                                         printline
  566           output = subtitle;                                                       printline
  567           output = ' ';                                                            printline
  568           line_count = 0;                                                          printline
  569        end;                                                                        printline
  570     if ind < 0 | ind > 5 then                                                      printline
  571        do;                                                                         printline
  572           output = line;                                                           printline
  573           line_count = line_count + 1;                                             printline
  574        end;                                                                        printline
  575     else                                                                           printline
  576        do;                                                                         printline
  577           output(1) = ctl(ind) || line;                                            printline
  578           line_count = line_count + skips(ind);                                    printline
  579        end;                                                                        printline
  580  end printline;                                                                    printline
 
symbol table dump
 
symbol          type       loc   segment defined ref count
ctl             character   753   string    560       1
ind             fixed      9114     data    557       4
line            character   752   string    557       2
skips           fixed      9116     data    561       1
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 13
 line    source statement                                                               procedure and compiler information
 
  581     error:                                                                        *
  582        procedure (msg, severity);                                                 *
  583     /* print the error message with a pointer pointing to the current token        error
  584        being scanned.  if source listing is disabled, also print the current       error
  585        source image.                                                               error
  586     */                                                                             error
  587        declare msg character, severity fixed;                                      error
  588        declare i fixed;                                                            error
  589        error_count = error_count + 1;                                              error
  590        if control(byte('L')) = 0 then                                              error
  591           do;                                                                      error
  592              i = 5 - length(card_count);                                           error
  593              call printline (substr (x70, 0, i) || card_count || x4 || buffer,-1); error
  594           end;                                                                     error
  595        call printline (substr(pointer,length(pointer)-7-                           error
  596              (line_length+cp-text_limit-lb-1)),-1);                                error
  597                                                                                    error
  598        output(-1) = card_count || x4 || buffer;                                    error
  599        output(-1) = x7 || msg;                                                     error
  600                                                                                    error
  601        if previous_error > 0 then                                                  error
  602           msg = msg || '. last previous error was on line ' || previous_error;     error
  603        call printline ('*** error. ' || msg,-1);                                   error
  604        previous_error = card_count;                                                error
  605        if severity > 0 then                                                        error
  606           if severe_errors > 25 then                                               error
  607              do;                                                                   error
  608                  call printline ('*** too many severe errors, compilation aborted ***',0); error
  609                  compiling = FALSE;                                                error
  610               end;                                                                 error
  611             else severe_errors = severe_errors + 1;                                error
  612     end error;                                                                     error
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9124     data    588       2
msg             character   760   string    582       4
severity        fixed      9123     data    582       1
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 14
 line    source statement                                                               procedure and compiler information
 
  613     /*                the scanner procedures              */                      *
  614     build_bcd:                                                                    *
  615        procedure (c);                                                             *
  616        declare c bit(9);                                                           build_bcd
  617        if length(bcd) > 0 then bcd = bcd || x1;                                    build_bcd
  618        else bcd = substr(x1 || x1, 1);                                             build_bcd
  619        corebyte(freepoint-1) = c;                                                  build_bcd c5 = 134217727
  620     end build_bcd;                                                                 build_bcd
 
symbol table dump
 
symbol          type       loc   segment defined ref count
c               bit (9)    9149     data    615       1
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 15
 line    source statement                                                               procedure and compiler information
 
  621     get_card:                                                                     *
  622        procedure;                                                                 *
  623        /* does all card reading and listing                                 */     get_card
  624        declare i fixed, tempo character, temp2 character;                          get_card
  625        if lb ~= 0 then                                                             get_card
  626           do;                                                                      get_card
  627              if cp >= 255 then                                                     get_card
  628                 do;                                                                get_card
  629                    text = substr(text, lb);                                        get_card
  630                    cp = cp - lb;                                                   get_card
  631                    call error ('identifier too long', 0);                          get_card
  632                 end;                                                               get_card
  633                 if lb > 255 - cp then i = 255 - cp;                                get_card
  634                 else i = lb;                                                       get_card
  635                 lb = lb - i;                                                       get_card
  636                 text = text || substr(balance, 0, i);                              get_card
  637                 balance = substr(balance, i);                                      get_card
  638                 text_limit = length(text) - 1;                                     get_card
  639                 return;                                                            get_card
  640           end;                                                                     get_card
  641        expansion_count = 0;    /* checked in scanner  */                           get_card
  642        if reading then   /* reading is FALSE initially, to read library */         get_card
  643           do;                                                                      get_card
  644              buffer = input;                                                       get_card
  645              if length(buffer) = 0 then                                            get_card
  646                 do;                                                                get_card
  647                    call error ('eof missing', 0);                                  get_card
  648                    buffer = ' /* '' /* */ eof; end; eof; end; eof';                get_card
  649                 end;                                                               get_card
  650              else card_count = card_count + 1;                                     get_card
  651           end;                                                                     get_card
  652        else                                                                        get_card
  653           do;                                                                      get_card
  654              buffer = input(LIBFILE);                                              get_card
  655              if length(buffer) = 0 then                                            get_card
  656                 do;                                                                get_card
  657                    reading = TRUE;                                                 get_card
  658                    buffer = input;                                                 get_card
  659                    card_count = card_count + 1;                                    get_card
  660                    statement_count = 0;                                            get_card
  661                    control(byte('L')) = TRUE & ~ control(byte('K'));               get_card
  662                 end;                                                               get_card
  663           end;                                                                     get_card
  664        line_length = length (buffer);                                              get_card
  665        if cp + length(buffer) > 255 then                                           get_card
  666           do;                                                                      get_card
  667              i = 255 - cp;                                                         get_card
  668              text = text || substr(buffer, 0, i);                                  get_card
  669              balance = substr(buffer, i);                                          get_card
  670              lb = length(balance);                                                 get_card
  671           end;                                                                     get_card
  672        else text = text || buffer;                                                 get_card
  673        text_limit = length(text) - 1;                                              get_card
  674        if control(byte('M')) then call printline(buffer,-1);                       get_card
  675        else if control(byte('L')) then                                             get_card
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 16
 line    source statement                                                               procedure and compiler information
 
  676           do;                                                                      get_card
  677              tempo = card_count;                                                   get_card
  678              i = 5 - length (tempo);                                               get_card
  679              tempo = substr(x70, 0, i) || tempo || x2 || buffer;                   get_card
  680              i = 88 - length(tempo);                                               get_card
  681              if i >= 70 then                                                       get_card
  682                 do;                                                                get_card
  683                    i = i - 70;                                                     get_card
  684                    tempo = tempo || x70;                                           get_card
  685                 end;                                                               get_card
  686              if i > 0 then tempo = tempo || substr(x70, 0, i);                     get_card
  687              temp2 = current_procedure || info;                                    get_card
  688              if control(byte('F')) then                                            get_card
  689                     temp2 = x2 || pp || x1 || dp || x1 || dsp || temp2;            get_card
  690              if length (temp2) > 44 then temp2 = substr (temp2,0,44);              get_card
  691              call printline (tempo || temp2,-1);                                   get_card c6 = 5905580032
  692           end;                                                                     get_card
  693        info = '';           /* clear information buffer */                         get_card
  694     end get_card;                                                                  get_card
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9151     data    624      16
temp2           character   765   string    624       7
tempo           character   764   string    624      10
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 17
 line    source statement                                                               procedure and compiler information
 
  695     char:                                                                         *
  696        procedure;                                                                 *
  697        cp = cp + 1;                                                                char
  698        if cp <= text_limit then return;                                            char
  699        cp = 0;                                                                     char
  700        text = '';                                                                  char
  701        call get_card;                                                              char
  702     end char;                                                                      char
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 18
 line    source statement                                                               procedure and compiler information
 
  703     deblank:                                                                      *
  704        procedure;                                                                 *
  705        call char;                                                                  deblank
  706        do while byte (text, cp) = byte (' ');                                      deblank
  707           call char;                                                               deblank
  708        end;                                                                        deblank
  709     end deblank;                                                                   deblank
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 19
 line    source statement                                                               procedure and compiler information
 
  710     bchar:                                                                        *
  711        procedure;                                                                 *
  712        do FOREVER;                                                                 bchar
  713           call deblank;                                                            bchar
  714           ch = byte(text, cp);                                                     bchar
  715           if ch ~= byte ('(') then return;                                         bchar
  716           /*  (base width)  */                                                     bchar
  717            call deblank;                                                           bchar
  718           jbase = byte (text, cp) - byte ('0');  /* width */                       bchar
  719           if jbase < 1 | jbase > 4 then                                            bchar
  720              do;                                                                   bchar
  721                 call error ('illegal bit string width: ' || substr(text,cp,1),0);  bchar
  722                 jbase = 4;  /* default width for error */                          bchar c7 = 134217728
  723              end;                                                                  bchar
  724           base = shl(1, jbase);                                                    bchar
  725           call deblank;                                                            bchar
  726          if byte(text,cp)~=byte(')')then call error('missing ) in bit string',0);  bchar
  727        end;                                                                        bchar
  728     end bchar;                                                                     bchar
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 20
 line    source statement                                                               procedure and compiler information
 
  729     scan:                                                                         *
  730        procedure;     /* get the next token from the text  */                     *
  731        declare s1 fixed, s2 fixed;                                                 scan
  732     declare lstrngm character initial ('string too long');                         scan
  733     declare lbitm character initial ('bit string too long');                       scan
  734      count_scan = count_scan + 1;                                                  scan
  735        failsoft = TRUE;                                                            scan
  736        bcd = '';  number_value = 0;                                                scan
  737     rescan:                                                                        scan
  738        if cp > text_limit then                                                     scan
  739           do;                                                                      scan
  740              text = '';                                                            scan
  741              call get_card;                                                        scan
  742           end;                                                                     scan
  743        else                                                                        scan
  744           do;                                                                      scan
  745              text_limit = text_limit - cp;                                         scan
  746              text = substr(text, cp);                                              scan
  747           end;                                                                     scan
  748        cp = 0;                                                                     scan
  749     /*  branch on next character in text                  */                       scan
  750        do case chartype(byte(text));                                               scan
  751           /*  case 0  */                                                           scan case 0.
  752           /* illegal characters fall here  */                                      scan
  753           call error ('illegal character: ' || substr (text, 0, 1), 0);            scan
  754           /*  case 1  */                                                           scan case 1.
  755           /*  blank  */                                                            scan
  756           do cp = 1 to text_limit;                                                 scan
  757              if byte (text, cp) ~= byte (' ') then goto rescan;                    scan
  758           end;                                                                     scan
  759           /*  case 2  */                                                           scan case 2.
  760           do FOREVER;   /* string quote ('):  character string       */            scan
  761              token = string;                                                       scan
  762              do cp = cp + 1 to text_limit;                                         scan
  763                 if byte (text, cp) = byte ('''') then                              scan
  764                    do;                                                             scan
  765                       if length(bcd) + cp > 257 then                               scan
  766                          do;                                                       scan
  767                             call error (lstrngm, 0);                               scan
  768                             return;                                                scan
  769                          end;                                                      scan
  770                       if cp > 1 then                                               scan
  771                       bcd = bcd || substr(text, 1, cp-1);                          scan
  772                       call char;                                                   scan
  773                        if byte (text, cp) = byte ('''') then                       scan
  774                           if length(bcd) = 255 then                                scan
  775                             do;                                                    scan
  776                               call error (lstrngm, 0);                             scan
  777                               return;                                              scan
  778                             end;                                                   scan
  779                          else                                                      scan
  780                             do;                                                    scan
  781                                bcd = bcd || substr(text, cp, 1);                   scan
  782                                go to rescan;                                       scan
  783                             end;                                                   scan
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 21
 line    source statement                                                               procedure and compiler information
 
  784                       return;                                                      scan
  785                    end;                                                            scan
  786              end;                                                                  scan
  787              /*  we have run off a card  */                                        scan
  788              if length(bcd) + cp > 257 then                                        scan
  789                 do;                                                                scan
  790                   call error (lstrngm, 0);                                         scan
  791                   return;                                                          scan
  792                 end;                                                               scan
  793              if cp > 1 then bcd = bcd || substr(text, 1, cp-1);                    scan
  794              text = x1;                                                            scan
  795              cp = 0;                                                               scan
  796              call get_card;                                                        scan
  797           end;                                                                     scan
  798           /*  case 3  */                                                           scan case 3.
  799           do;      /*  bit quote("):  bit string  */                               scan
  800              jbase = 4;  base = 16;  /* default width */                           scan
  801              token = number;                                                       scan
  802              s1 = 0;                                                               scan
  803              call bchar;                                                           scan
  804              do while ch ~= byte ('"');                                            scan
  805                 s1 = s1 + jbase;                                                   scan
  806                 if ch >= byte ('0') & ch <= byte ('9') then s2 = ch - byte ('0');  scan
  807                 else s2 = ch + 10 - byte ('a');                                    scan
  808                 if s2 >= base | s2 < 0 then                                        scan
  809                    call error ('illegal character in bit string: '                 scan
  810                    || substr(text, cp, 1), 0);                                     scan
  811                 if s1 > 36 then token = string;                                    scan
  812                 if token = string then                                             scan
  813                    do while s1 - jbase >= 9;                                       scan
  814                       if length(bcd) >= 255 then                                   scan
  815                          do;                                                       scan
  816                             call error ( lbitm, 0);                                scan
  817                             return;                                                scan
  818                          end;                                                      scan
  819                       s1 = s1 - 9;                                                 scan
  820                       call build_bcd (shr(number_value, s1-jbase));                scan
  821                    end;                                                            scan
  822                 number_value = shl(number_value, jbase) + s2;                      scan
  823                 call bchar;                                                        scan
  824              end;     /* of do while ch...  */                                     scan
  825              cp = cp + 1;                                                          scan
  826              if token = string then                                                scan
  827                 if length(bcd) >= 255 then call error (lbitm,0);                   scan
  828                 else call build_bcd (shl(number_value, 9 - s1));                   scan
  829               return;                                                              scan
  830           end;                                                                     scan
  831           /*  case 4  */                                                           scan case 4.
  832           do FOREVER;   /*  a letter:  identifiers and reserved words  */          scan
  833              do cp = cp + 1 to text_limit;                                         scan
  834                 if not_letter_or_digit(byte(text, cp)) then                        scan
  835                    do;  /* end of identifier  */                                   scan
  836                       bcd = substr(text, 0, cp);                                   scan
  837                       if cp > 1 then if cp <= reserved_limit then                  scan
  838                          /* check for reserved words */                            scan
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 22
 line    source statement                                                               procedure and compiler information
 
  839                          do i = 1 to TERMINAL#;                                    scan
  840                             if bcd = vocab(i) then                                 scan c8 = 42
  841                                do;                                                 scan
  842                                   token = i;                                       scan
  843                                   return;                                          scan
  844                                end;                                                scan
  845                          end;                                                      scan
  846                       do i = macro_index(cp-1) to macro_index(cp) - 1;             scan
  847                          if bcd = macro_name(i) then                               scan
  848                             do;                                                    scan
  849                              macro_count(i) = macro_count(i) + 1;                  scan
  850                                bcd = macro_text(i);                                scan
  851                                if expansion_count < EXPANSION_LIMIT then           scan
  852                                   expansion_count = expansion_count + 1;           scan
  853                                else call printline ('** warning, too many expansions for scan
  854   the macro: ' || bcd,-1);                                                         scan
  855                                text = substr(text, cp);                            scan
  856                                text_limit = text_limit - cp;                       scan
  857                                if length(bcd) + text_limit > 255 then              scan
  858                                   do;                                              scan
  859                                      if lb + text_limit > 255 then                 scan
  860                                         call error('macro expansion too long',0);  scan
  861                                      else                                          scan
  862                                         do;                                        scan
  863                                            balance = text || balance;              scan
  864                                            lb = length(balance);                   scan
  865                                            text = bcd;                             scan
  866                                         end;                                       scan
  867                                   end;                                             scan
  868                                else text = bcd || text;                            scan
  869                                bcd = '';                                           scan
  870                                text_limit = length(text) - 1;                      scan
  871                                cp = 0;                                             scan
  872                                go to rescan;                                       scan
  873                             end;                                                   scan
  874                       end;                                                         scan
  875                       /*  reserved words exit higher:  therefore <identifier> */   scan
  876                       token = ident;                                               scan
  877                       return;                                                      scan
  878                    end;                                                            scan
  879              end;                                                                  scan
  880              /*  end of card  */                                                   scan
  881              call get_card;                                                        scan
  882              cp = cp - 1;                                                          scan
  883           end;                                                                     scan
  884           /*  case 5  */                                                           scan case 5.
  885            do FOREVER;   /*  digit:  a number  */                                  scan
  886              token = number;                                                       scan
  887              do cp = cp to text_limit;                                             scan
  888                 s1 = byte(text, cp);                                               scan
  889                 if s1 < byte ('0') | s1 > byte ('9') then return;                  scan
  890                 number_value = 10 * number_value + s1 - byte ('0');                scan
  891              end;                                                                  scan
  892              call get_card;                                                        scan
  893           end;                                                                     scan
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 23
 line    source statement                                                               procedure and compiler information
 
  894           /*  case 6  */                                                           scan case 6.
  895           do;      /*  a /:  may be divide or start of comment  */                 scan
  896              call char;                                                            scan
  897              if byte (text, cp) ~= byte ('*') then                                 scan
  898                 do;                                                                scan
  899                    token = divide;                                                 scan
  900                    return;                                                         scan
  901                 end;                                                               scan
  902              /* we have a comment  */                                              scan
  903              s1, s2 = byte (' ');                                                  scan
  904              do while s1 ~= byte ('*') | s2 ~= byte ('/');                         scan
  905                 if s1 = byte ('$') then /* a control char */                       scan
  906                      control(s2) = ~control(s2) & 1;                               scan
  907                 s1 = s2;                                                           scan
  908                 call char;                                                         scan
  909                 s2 = byte(text, cp);                                               scan
  910              end;                                                                  scan
  911           end;                                                                     scan
  912           /*  case 7  */                                                           scan case 7.
  913           do;      /*  SPECIAL characters  */                                      scan
  914              token = tx(byte(text));                                               scan
  915              cp = 1;                                                               scan
  916              return;                                                               scan
  917           end;                                                                     scan
  918           /*  case 8  */                                                           scan case 8.
  919           do;   /* a |:  may be  |  or  ||  */                                     scan
  920              call char;                                                            scan
  921              if byte(text, cp) = byte('|') then                                    scan
  922                 do;                                                                scan
  923                    call char;                                                      scan
  924                    token = concatenate;                                            scan
  925                 end;                                                               scan
  926              else token = orsymbol;                                                scan
  927              return;                                                               scan
  928           end;                                                                     scan
  929        end;     /* of case on chartype  */                                         scan case 9.
  930        cp = cp + 1;  /* advance scanner and resume search for token  */            scan
  931        go to rescan;                                                               scan
  932     end scan;                                                                      scan
 
symbol table dump
 
symbol          type       loc   segment defined ref count
lbitm           character   772   string    733       2
lstrngm         character   771   string    732       3
rescan          label       996  program    737       4
s1              fixed      9184     data    731      17
s2              fixed      9185     data    731      11
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 24
 line    source statement                                                               procedure and compiler information
 
  933     /*                                                                            *
  934              c o d e   e m i s s i o n   p r o c e d u r e s                      *
  935   */                                                                              *
  936  flush_data_buffer:                                                               *
  937     procedure;                                                                    *
  938        /* clean out the data buffer and stick all current contents                 flush_data_buffer
  939           into the rel file */                                                     flush_data_buffer
  940        declare i fixed, j fixed;                                                   flush_data_buffer
  941        if (dptr+dctr) > 1 then                                                     flush_data_buffer
  942           do;                                                                      flush_data_buffer
  943              j = (dptr/19)*18 + dctr -1;                                           flush_data_buffer
  944              file(RELFILE) = CODE_TYPE + j;                                        flush_data_buffer
  945              i = dptr+dctr-1;                                                      flush_data_buffer c9 = 262144
  946              do j = 0 to i;                                                        flush_data_buffer
  947                 file(RELFILE) = data_buffer(j);                                    flush_data_buffer
  948                 end;                                                               flush_data_buffer
  949           end;                                                                     flush_data_buffer
  950        dptr = 0;                                                                   flush_data_buffer
  951        dctr = 1;                                                                   flush_data_buffer
  952     end flush_data_buffer;                                                         flush_data_buffer
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9233     data    940       2
j               fixed      9234     data    940       4
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 25
 line    source statement                                                               procedure and compiler information
 
  953  flush_code_buffer:                                                               *
  954     procedure;                                                                    *
  955        /* clean out the code buffer and stick all current contents                 flush_code_buffer
  956           into the rel file */                                                     flush_code_buffer
  957        declare i fixed, j fixed;                                                   flush_code_buffer
  958        if (rptr+rctr) > 1 then                                                     flush_code_buffer
  959           do;                                                                      flush_code_buffer
  960              i = (rptr/19)*18 + rctr -1;                                           flush_code_buffer
  961              j = rptr+rctr-1;                                                      flush_code_buffer
  962              file (RELFILE) = CODE_TYPE+i;                                         flush_code_buffer
  963              do i = 0 to j;                                                        flush_code_buffer
  964                 file(RELFILE) = code_buffer(i);                                    flush_code_buffer
  965                 end;                                                               flush_code_buffer
  966           end;                                                                     flush_code_buffer
  967        rptr = 0;                                                                   flush_code_buffer
  968        rctr = 1;                                                                   flush_code_buffer
  969     end flush_code_buffer;                                                         flush_code_buffer
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9237     data    957       4
j               fixed      9238     data    957       2
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 26
 line    source statement                                                               procedure and compiler information
 
  970  radix50:                                                                         *
  971     procedure (symbol);                                                           *
  972     /* procedure to return the radix-50 representation of a symbol.                radix50
  973        only the first 6 characters are used. */                                    radix50
  974     declare symbol character;                                                      radix50
  975     declare (i,j,k,l) fixed;                                                       radix50
  976                                                                                    radix50
  977     j = 0;                                                                         radix50
  978     if length(symbol) < 6 then symbol = symbol || x7;                              radix50
  979     do l = 0 to 5;                                                                 radix50
  980        i = byte(symbol,l);                                                         radix50 c10 = 5
  981        if i = byte(' ') then k = 0;                                                radix50
  982           else if i = byte ('.') then k = "(3)45";                                 radix50
  983           else if i = byte ('$') then k = "(3)46";                                 radix50
  984           else if i = byte ('%') then k = "(3)47";                                 radix50
  985           else if i >= byte ('0') & i <= byte ('9') then                           radix50
  986                      k = i-byte('0') + "(3)1";                                     radix50
  987           else if i >= byte ('a') & i <= byte ('z') then                           radix50
  988                      k = i - byte ('a') + "(3)13";                                 radix50
  989           else return j;                                                           radix50
  990        j = j * "(3)50" + k;                                                        radix50
  991        end;                                                                        radix50
  992     return j;                                                                      radix50
  993     end radix50;                                                                   radix50
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9240     data    975      11
j               fixed      9241     data    975       5
k               fixed      9242     data    975       7
l               fixed      9243     data    975       2
symbol          character   777   string    971       4
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 27
 line    source statement                                                               procedure and compiler information
 
  994  output_codeword:                                                                 *
  995     procedure;                                                                    *
  996     /* spit out the instruction at codexxx(code_tail) */                           output_codeword
  997     if code_full(code_tail) then                                                   output_codeword
  998        do;                                                                         output_codeword
  999           if control(byte('A')) then output (CODEFILE) = code (code_tail);         output_codeword
 1000           if rctr+rptr = 1 then                                                    output_codeword
 1001              do;                                                                   output_codeword
 1002                 code_buffer(0) =shl(1,34);                                         output_codeword
 1003                 code_buffer(1) = code_pp(code_tail) + "(3)400000";                 output_codeword
 1004                 rctr = rctr +1;                                                    output_codeword
 1005              end;                                                                  output_codeword
 1006           code_buffer(rptr) = shl(code_rbits(code_tail),36-rctr*2)|code_buffer(rptr); output_codeword
 1007           code_buffer(rptr+rctr) = code_rel(code_tail);                            output_codeword
 1008           rctr = rctr +1;                                                          output_codeword
 1009           if rptr+rctr > BUFFERSIZE then call flush_code_buffer;                   output_codeword
 1010           if rctr > 18 then                                                        output_codeword
 1011              do;                                                                   output_codeword
 1012                 rptr = rptr +19;                                                   output_codeword
 1013                 rctr = 1;                                                          output_codeword
 1014                 code_buffer(rptr) = 0;                                             output_codeword
 1015              end;                                                                  output_codeword
 1016        end;                                                                        output_codeword
 1017     code_full(code_tail) = FALSE;                                                  output_codeword
 1018     code_tail = (code_tail+1) & 3;                                                 output_codeword
 1019     end output_codeword;                                                           output_codeword
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 28
 line    source statement                                                               procedure and compiler information
 
 1020  flush_labels:                                                                    *
 1021     procedure;                                                                    *
 1022        /* clean out label buffer by generating internal request                    flush_labels
 1023           type block and defining all labels now known */                          flush_labels
 1024        declare i fixed;                                                            flush_labels
 1025        if label_count = 0 then return;                                             flush_labels
 1026        do while code_tail ~= code_head;                                            flush_labels
 1027           call output_codeword;                                                    flush_labels
 1028           end;                                                                     flush_labels
 1029        call output_codeword;                                                       flush_labels
 1030        code_tail = code_head;      /* reset pointers, since buffers now empty */   flush_labels
 1031        stillcond, stillinzero = 0; /* make sure peephole works */                  flush_labels
 1032        call flush_code_buffer;                                                     flush_labels
 1033        file (RELFILE) = INTREQ_TYPE+label_count;                                   flush_labels
 1034        do i = 0 to label_count;                                                    flush_labels c11 = 2097152
 1035           file (RELFILE) = label_buffer(i);                                        flush_labels
 1036           end;                                                                     flush_labels
 1037        label_count = 0;                                                            flush_labels
 1038        label_buffer(0) = 0;                                                        flush_labels
 1039     end flush_labels;                                                              flush_labels
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9245     data   1024       2
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 29
 line    source statement                                                               procedure and compiler information
 
 1040  output_dataword:                                                                 *
 1041     procedure (w,loc);                                                            *
 1042        /* output a word to the low segment */                                      output_dataword
 1043        declare w  fixed, loc fixed;                                                output_dataword
 1044        if (dptr+dctr)>BUFFERSIZE | dloc ~= loc then call flush_data_buffer;        output_dataword
 1045        if dptr+dctr = 1 then                                                       output_dataword
 1046           do;                                                                      output_dataword
 1047              data_buffer(0) = "(3)200000000000";                                   output_dataword
 1048              data_buffer(1) = loc;                                                 output_dataword c12 = 17179869184
 1049              data_buffer(2) = w;                                                   output_dataword
 1050              dloc = loc + 1;                                                       output_dataword
 1051              dctr = dctr + 2;                                                      output_dataword
 1052              return;                                                               output_dataword
 1053           end;                                                                     output_dataword
 1054        data_buffer (dptr+dctr) = w;                                                output_dataword
 1055        dctr = dctr +1;                                                             output_dataword
 1056        dloc = dloc + 1;                                                            output_dataword
 1057        if dptr+dctr > BUFFERSIZE then call flush_data_buffer;                      output_dataword
 1058        if dctr > 18 then                                                           output_dataword
 1059          do;                                                                       output_dataword
 1060              dctr = 1;                                                             output_dataword
 1061              dptr = dptr + 19;                                                     output_dataword
 1062              data_buffer(dptr) = 0;                                                output_dataword
 1063           end;                                                                     output_dataword
 1064     end output_dataword;                                                           output_dataword
 
symbol table dump
 
symbol          type       loc   segment defined ref count
loc             fixed      9249     data   1041       3
w               fixed      9248     data   1041       2
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 30
 line    source statement                                                               procedure and compiler information
 
 1065  flush_datacard:procedure;                                                        *
 1066        if control(byte('A')) | control(byte('B')) then                             flush_datacard
 1067           do;                                                                      flush_datacard
 1068              datacard = datacard || '; d' || dp;                                   flush_datacard
 1069              if control(byte('A')) then output (DATAFILE) = datacard;              flush_datacard
 1070              if control(byte('B')) then call printline (datamsg || datacard,-1);   flush_datacard
 1071           end;                                                                     flush_datacard
 1072        call output_dataword (pword,dp);                                            flush_datacard
 1073        pword = 0;                                                                  flush_datacard
 1074        dpoffset = 0;                                                               flush_datacard
 1075        dp = dp + 1;                                                                flush_datacard
 1076  end flush_datacard;                                                               flush_datacard
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 31
 line    source statement                                                               procedure and compiler information
 
 1077  emitblock:                                                                       *
 1078     procedure (i);                                                                *
 1079        /* reserve a block of i words */                                            emitblock
 1080        declare i fixed;                                                            emitblock
 1081        if control(byte('A')) | control(byte('B')) then                             emitblock
 1082           do;                                                                      emitblock
 1083              datacard = '       repeat ' || i || ',<0>; d' || dp;                  emitblock
 1084              if control(byte('A')) then output (DATAFILE) = datacard;              emitblock
 1085              if control(byte('B')) then call printline (datamsg || datacard,-1);   emitblock
 1086           end;                                                                     emitblock
 1087        dp = dp + i;                                                                emitblock
 1088  end emitblock;                                                                    emitblock
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9252     data   1078       2
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 32
 line    source statement                                                               procedure and compiler information
 
 1089  emitdataword:                                                                    *
 1090     procedure (w);                                                                *
 1091        declare w fixed;                                                            emitdataword
 1092        /* send an 80 character card to the data file */                            emitdataword
 1093        if dpoffset > 0 then call flush_datacard;                                   emitdataword
 1094        if control(byte('A')) | control(byte('B')) then                             emitdataword
 1095           do;                                                                      emitdataword
 1096              datacard = x7 || w || '; d' || dp;                                    emitdataword
 1097              if control(byte('A')) then output (DATAFILE) = datacard;              emitdataword
 1098              if control(byte('B')) then call printline (datamsg || datacard,-1);   emitdataword
 1099           end;                                                                     emitdataword
 1100        call output_dataword(w,dp);                                                 emitdataword
 1101        dp = dp + 1;                                                                emitdataword
 1102  end emitdataword;                                                                 emitdataword
 
symbol table dump
 
symbol          type       loc   segment defined ref count
w               fixed      9259     data   1090       2
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 33
 line    source statement                                                               procedure and compiler information
 
 1103  emitbyte:                                                                        *
 1104     procedure (c);                                                                *
 1105        declare c fixed;                                                            emitbyte
 1106        /* send one 9-bit byte to the data area */                                  emitbyte
 1107        if control(byte('A')) | control(byte('B')) then                             emitbyte
 1108           if dpoffset = 0 then datacard = '       byte (9)'|| c;                   emitbyte
 1109           else datacard = datacard || ',' || c;                                    emitbyte
 1110        pword = pword + shl(c&"(3)777",9*(3-dpoffset));                             emitbyte
 1111        dpoffset = dpoffset + 1;                                                    emitbyte
 1112        if dpoffset = 4 then call flush_datacard;                                   emitbyte
 1113  end emitbyte;                                                                     emitbyte
 
symbol table dump
 
symbol          type       loc   segment defined ref count
c               fixed      9261     data   1104       3
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 34
 line    source statement                                                               procedure and compiler information
 
 1114  emitconstant:                                                                    *
 1115     procedure (c);                                                                *
 1116        declare c fixed;                                                            emitconstant
 1117        declare ctab (100) fixed, cadd (100) fixed, nc fixed, i fixed;              emitconstant
 1118        /* see if c has already been emited, and if not, emit it.  set up adr.  */  emitconstant
 1119        do i = 1 to nc;                  /* step thru the constants */              emitconstant
 1120           if ctab (i) = c then                                                     emitconstant
 1121              do;                                                                   emitconstant
 1122                 adr = cadd (i);                                                    emitconstant
 1123                 return;                                                            emitconstant
 1124              end;                                                                  emitconstant
 1125        end;                                                                        emitconstant
 1126        ctab (i) = c;                                                               emitconstant
 1127        call emitdataword (c);                                                      emitconstant
 1128        adr, cadd (i) = dp - 1;                                                     emitconstant
 1129        if i < 100 then nc = i;                                                     emitconstant
 1130        if control(byte('C')) then call printline ('* CONSTANT ' || nc || ' = ' || c,-1); emitconstant
 1131           else if control(byte('L')) then info=info|| ' c'|| nc ||' = ' || c;      emitconstant
 1132  end emitconstant;                                                                 emitconstant
 
symbol table dump
 
symbol          type       loc   segment defined ref count
c               fixed      9266     data   1115       5
cadd            fixed      9368     data   1117       2
ctab            fixed      9267     data   1117       2
i               fixed      9470     data   1117       7
nc              fixed      9469     data   1117       4
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 35
 line    source statement                                                               procedure and compiler information
 
 1133  emitcodeword:procedure (w,word,rbits);                                           *
 1134         declare w character;                                                       emitcodeword
 1135        declare word fixed;                                                         emitcodeword
 1136        declare rbits fixed;                                                        emitcodeword
 1137        /* send an 80 character code card to the buffer area */                     emitcodeword
 1138        code_head = (code_head+1) & 3;                                              emitcodeword
 1139        if code_head = code_tail then call output_codeword;                         emitcodeword
 1140        if control(byte('A')) | control(byte('E')) then                             emitcodeword
 1141              code(code_head) = label_gen || w;                                     emitcodeword
 1142        if control(byte('E')) then                                                  emitcodeword
 1143              call printline (codemsg || code(code_head),-1);                       emitcodeword
 1144        code_rel(code_head) = word;                                                 emitcodeword
 1145        code_pp(code_head) = pp;                                                    emitcodeword
 1146        code_rbits(code_head) = rbits;                                              emitcodeword
 1147        code_full(code_head) = TRUE;                                                emitcodeword
 1148        label_gen = '';                                                             emitcodeword
 1149        stillcond, stillinzero = 0;                                                 emitcodeword
 1150        pp = pp + 1;                                                                emitcodeword
 1151  end emitcodeword;                                                                 emitcodeword
 
symbol table dump
 
symbol          type       loc   segment defined ref count
rbits           fixed      9478     data   1133       1
w               character   788   string   1133       1
word            fixed      9477     data   1133       1
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 36
 line    source statement                                                               procedure and compiler information
 
 1152  outputlabel:                                                                     *
 1153     procedure (j);                                                                *
 1154     declare j fixed;                                                               outputlabel
 1155     label_count = label_count+1;                                                   outputlabel
 1156     label_buffer(0) = shl(3,36-label_count*2)|label_buffer(0);                     outputlabel
 1157     label_buffer(label_count) = j;                                                 outputlabel
 1158     if(label_count >= BUFFERSIZE) then call flush_labels;                          outputlabel
 1159     end outputlabel;                                                               outputlabel
 
symbol table dump
 
symbol          type       loc   segment defined ref count
j               fixed      9479     data   1153       1
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 37
 line    source statement                                                               procedure and compiler information
 
 1160  emitlabel:procedure(l,r);                                                        *
 1161        declare l fixed;                                                            emitlabel
 1162        declare r fixed;                                                            emitlabel
 1163        declare i fixed;                                                            emitlabel
 1164        declare j fixed;                                                            emitlabel
 1165        if r = 3 then                                                               emitlabel
 1166           do;                                                                      emitlabel
 1167              if descref(l) = 0 then return;                                        emitlabel
 1168              j = shl(descref(l),18) + dp;                                          emitlabel
 1169              call outputlabel(j);                                                  emitlabel
 1170              descref(l) = 0;                                                       emitlabel
 1171              return;                                                               emitlabel
 1172           end;                                                                     emitlabel
 1173        stillinzero = 0;    /* don't try optimizing over label */                   emitlabel
 1174        j = shl(r,18) + l;                                                          emitlabel
 1175        do i = 1 to for_count;                                                      emitlabel
 1176           if j = for_label(i) then                                                 emitlabel
 1177              do;                                                                   emitlabel
 1178                 j = shl(for_ref(i)+"(3)400000",18);                                emitlabel
 1179                 if r = 4 then j = j + pp + "(3)400000";                            emitlabel
 1180                          else j = j + dp;                                          emitlabel
 1181                 call outputlabel(j);                                               emitlabel
 1182                 j = i;                                                             emitlabel
 1183                 do while j < for_count;                                            emitlabel
 1184                    for_label(j) = for_label(j+1);                                  emitlabel
 1185                    for_ref(j) = for_ref(j+1);                                      emitlabel
 1186                    j = j + 1;                                                      emitlabel
 1187                 end;                                                               emitlabel
 1188                 for_label(for_count) = 0;                                          emitlabel
 1189                 for_ref(for_count) = 0;                                            emitlabel
 1190                 for_count = for_count -1;                                          emitlabel
 1191                 /* put a label on the next instruction generated */                emitlabel
 1192                 if r = 4 & (control(byte('A')) | control(byte('E'))) then          emitlabel
 1193                              label_gen = label_gen || '$' || l || ':';             emitlabel
 1194                 return;                                                            emitlabel
 1195              end;                                                                  emitlabel
 1196        end;                                                                        emitlabel
 1197        if r = 4 & (control(byte('A')) | control(byte('E'))) then                   emitlabel
 1198            label_gen = label_gen || '$' || l || ':';                               emitlabel
 1199        return;                                                                     emitlabel
 1200  end emitlabel;                                                                    emitlabel
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9482     data   1163       4
j               fixed      9483     data   1164      18
l               fixed      9480     data   1160       6
r               fixed      9481     data   1160       5
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 38
 line    source statement                                                               procedure and compiler information
 
 1201  refcheck:                                                                        *
 1202     procedure (i);                                                                *
 1203        /* check to see if this satisfies any forward references.                   refcheck
 1204           if so, set up label buffer.  if not, check if this                       refcheck
 1205           should be chained. */                                                    refcheck
 1206        declare i fixed;                                                            refcheck
 1207        declare j fixed;                                                            refcheck
 1208        if shr(i,18) = 3 then                                                       refcheck
 1209           do;                                                                      refcheck
 1210              i = i & "(3)777777";                                                  refcheck
 1211              j = descref(i);                                                       refcheck
 1212              descref(i) = pp + "(3)400000";                                        refcheck
 1213              return j;                                                             refcheck
 1214           end;                                                                     refcheck
 1215        j = 1;                                                                      refcheck
 1216        do while j <= for_count;                                                    refcheck
 1217           if for_label(j) = i then                                                 refcheck
 1218              do;                                                                   refcheck
 1219                 i = for_ref(j) + "(3)400000";                                      refcheck
 1220                 for_ref(j) = pp;                                                   refcheck
 1221                 return i;                                                          refcheck
 1222              end;                                                                  refcheck
 1223           j=j+1;                                                                   refcheck
 1224        end;                                                                        refcheck
 1225        for_count = for_count +1;                                                   refcheck
 1226        if for_count > FOR_MAX then call error ('too many forward references',3);   refcheck
 1227        for_ref(for_count) = pp;                                                    refcheck
 1228        for_label(for_count) = i;                                                   refcheck
 1229        return 0;                                                                   refcheck
 1230     end refcheck;                                                                  refcheck
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9486     data   1202       9
j               fixed      9487     data   1207       9
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 39
 line    source statement                                                               procedure and compiler information
 
 1231  emitinst:procedure (opcode,treg,indirect,operand,ireg,relocation);               *
 1232        declare opcode fixed,                                                       emitinst
 1233                treg fixed,                                                         emitinst
 1234                indirect fixed,                                                     emitinst
 1235                operand fixed,                                                      emitinst
 1236                ireg fixed,                                                         emitinst
 1237                relocation fixed;                                                   emitinst
 1238        declare rbits fixed,                                                        emitinst
 1239                word fixed;                                                         emitinst
 1240        /* emit a 80 character instruction image */                                 emitinst
 1241        declare reloc (5) character                                                 emitinst
 1242                initial ('', 'd+', 'p+', 's+', '$', '$');                           emitinst
 1243        declare i fixed,                                                            emitinst
 1244                j fixed,                                                            emitinst
 1245                card character,                                                     emitinst
 1246                indir (1) character initial ('', '@');                              emitinst
 1247        count_inst = count_inst + 1;                                                emitinst
 1248                                                                                    emitinst
 1249        word = shl(opcode,27) + shl(treg&"f",23) + shl(indirect&1,22)               emitinst
 1250               + shl(ireg&"f",18);                                                  emitinst
 1251        do case relocation;                                                         emitinst
 1252           /* case 0 : absolute address - no relocation */                          emitinst case 0.
 1253           do;                                                                      emitinst
 1254              word = word + (operand&"(3)777777");                                  emitinst
 1255              rbits = 0;                                                            emitinst
 1256           end;                                                                     emitinst
 1257                                                                                    emitinst case 1.
 1258           /* case 1 : relative to the beginning of data segment */                 emitinst
 1259           do;                                                                      emitinst
 1260              word = word + (operand&"(3)777777");                                  emitinst
 1261              rbits = 1;                                                            emitinst
 1262           end;                                                                     emitinst
 1263                                                                                    emitinst case 2.
 1264           /* case 2 : relative to beginning of code segment */                     emitinst
 1265           do;                                                                      emitinst
 1266              word = word + (operand&"(3)777777") + "(3)400000";                    emitinst
 1267              rbits = 1;                                                            emitinst
 1268           end;                                                                     emitinst
 1269                                                                                    emitinst case 3.
 1270           /* case 3 : relative to beginning of strings */                          emitinst
 1271           do;                                                                      emitinst
 1272              i = shl(relocation,18) + (operand&"(3)777777");                       emitinst
 1273              j = refcheck(i);                                                      emitinst
 1274              word = word + j;                                                      emitinst
 1275              if j = 0 then rbits = 0;                                              emitinst
 1276                       else rbits = 1;                                              emitinst
 1277           end;                                                                     emitinst
 1278                                                                                    emitinst case 4.
 1279           /* case 4 : forward label reference in code area */                      emitinst
 1280           do;                                                                      emitinst
 1281              j = refcheck("(3)4000000" + (operand&"(3)777777"));                   emitinst
 1282              word = word + j;                                                      emitinst c13 = 1048576
 1283              if j = 0 then rbits = 0;                                              emitinst
 1284                       else rbits = 1;                                              emitinst
 1285           end;                                                                     emitinst
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 40
 line    source statement                                                               procedure and compiler information
 
 1286                                                                                    emitinst case 5.
 1287           /* case 5 : forward label reference in data area */                      emitinst
 1288           do;                                                                      emitinst
 1289              j = refcheck("(3)5000000" + (operand&"(3)777777"));                   emitinst
 1290              word = word + j;                                                      emitinst c14 = 1310720
 1291              if j = 0 then rbits = 0;                                              emitinst
 1292                       else rbits = 1;                                              emitinst
 1293           end;                                                                     emitinst
 1294        end;  /* end of do case relocation */                                       emitinst case 6.
 1295                                                                                    emitinst
 1296        if control(byte('A')) | control(byte('E')) then                             emitinst
 1297           do;                                                                      emitinst
 1298              i = shr(opcode,5);                                                    emitinst
 1299              card = x7 || substr(opname(i),(opcode-i*32)*6,6) || x1 ||treg || ','  emitinst
 1300                     || indir(indirect) || reloc(relocation) || operand;            emitinst c15 = 805306368
 1301              if ireg > 0 then card = card || '(' || ireg || ')';                   emitinst
 1302              card = card || '; p' || pp;                                           emitinst
 1303           end;                                                                     emitinst
 1304        instruct(opcode) = instruct(opcode) + 1;                                    emitinst
 1305        call emitcodeword (card,word,rbits);                                        emitinst
 1306  end emitinst;                                                                     emitinst
 
symbol table dump
 
symbol          type       loc   segment defined ref count
card            character   800   string   1245       6
i               fixed      9505     data   1243       5
indir           character   801   string   1246       1
indirect        fixed      9497     data   1231       2
ireg            fixed      9499     data   1231       3
j               fixed      9506     data   1244       9
opcode          fixed      9495     data   1231       5
operand         fixed      9498     data   1231       7
rbits           fixed      9501     data   1238      10
reloc           character   794   string   1241       1
relocation      fixed      9500     data   1231       3
treg            fixed      9496     data   1231       2
word            fixed      9502     data   1239      14
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 41
 line    source statement                                                               procedure and compiler information
 
 1307  emitdesc:procedure (l,a);                                                        *
 1308        declare l fixed,                                                            emitdesc
 1309                a fixed;                                                            emitdesc
 1310        /* send a length and string address to the descriptor area */               emitdesc
 1311        if dsp > DESCLIMIT then                                                     emitdesc
 1312           do;                                                                      emitdesc
 1313              call error ('too many strings',1);                                    emitdesc
 1314              dsp = 0;                                                              emitdesc
 1315           end;                                                                     emitdesc
 1316         if control(byte('B')) then                                                 emitdesc
 1317           call printline (x70 || 'desc =        ' || l || ',' || a || '; s' || dsp,-1); emitdesc
 1318        descl(dsp) = l;                                                             emitdesc
 1319        desca(dsp) = a;                                                             emitdesc
 1320        dsp = dsp + 1;                                                              emitdesc
 1321  end emitdesc;                                                                     emitdesc
 
symbol table dump
 
symbol          type       loc   segment defined ref count
a               fixed      9514     data   1307       2
l               fixed      9513     data   1307       2
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 42
 line    source statement                                                               procedure and compiler information
 
 1322  findlabel:procedure;                                                             *
 1323        label_sink = label_sink + 1;                                                findlabel
 1324        return (label_sink);                                                        findlabel
 1325  end findlabel;                                                                    findlabel
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 43
 line    source statement                                                               procedure and compiler information
 
 1326   /*                                                                              *
 1327             s y m b o l   t a b l e   p r o c e d u r e s                         *
 1328   */                                                                              *
 1329                                                                                   *
 1330  hasher:                                                                          *
 1331     procedure (id);          /* calculate hash index into hash table*/            *
 1332     declare id   character;                                                        hasher
 1333     declare l    fixed;                                                            hasher
 1334     l = length (id);                                                               hasher
 1335     return (byte (id) + byte (id, l-1) + shl (l,4)) & "ff";                        hasher
 1336     end hasher;                                                                    hasher
 
symbol table dump
 
symbol          type       loc   segment defined ref count
id              character   811   string   1331       3
l               fixed      9524     data   1333       3
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 44
 line    source statement                                                               procedure and compiler information
 
 1337                                                                                   *
 1338  enter:procedure (n, t, l, s);                                                    *
 1339        declare t fixed, l fixed, s fixed;                                          enter
 1340        declare n character;                                                        enter
 1341   /* enter the name n in the symbol table with type t at location l segment s */   enter
 1342        declare i fixed, k fixed;                                                   enter
 1343        idx = hasher (n);                                                           enter
 1344        i = hash (idx);                                                             enter
 1345        do while i >= procmark;                                                     enter
 1346           idcompares = idcompares + 1;                                             enter
 1347           if n = syt (i) then                                                      enter
 1348              do;                                                                   enter
 1349                 k = sytype (i);                                                    enter
 1350                 if t = LABELTYPE & (k = FORWARDTYPE | k = FORWARDCALL) then        enter
 1351                    do;                                                             enter
 1352                       if control (byte ('E')) then                                 enter
 1353                          call printline (x70 || 'fixed references to: ' || n,-1);  enter
 1354                       if k = FORWARDTYPE then                                      enter
 1355                          do;                                                       enter
 1356                             call emitlabel(sytloc(i),4);                           enter
 1357                             sytloc(i) = l;                                         enter
 1358                             sytseg(i) = s;                                         enter
 1359                          end;                                                      enter
 1360                       sytype (i) = t;                                              enter
 1361                    end;                                                            enter
 1362                 else if procmark + parct < i then                                  enter
 1363                    call error ('duplicate declaration for: ' || n, 0);             enter
 1364                 return i;                                                          enter
 1365              end;                                                                  enter
 1366           i = ptr (i);                                                             enter
 1367        end;                                                                        enter
 1368        ndecsy = ndecsy + 1;                                                        enter
 1369        if ndecsy > maxndecsy then                                                  enter
 1370           if ndecsy > SYTSIZE then                                                 enter
 1371              do;                                                                   enter
 1372                 call error ('symbol table overflow', 1);                           enter
 1373                 ndecsy = ndecsy - 1;                                               enter
 1374              end;                                                                  enter
 1375           else maxndecsy = ndecsy;                                                 enter
 1376        syt (ndecsy) = n;                                                           enter
 1377        sytype (ndecsy) = t;                                                        enter
 1378        sytloc (ndecsy) = l;                                                        enter
 1379        sytseg (ndecsy) = s;                                                        enter
 1380        sytco (ndecsy) = 0;                                                         enter
 1381        sytcard (ndecsy) = card_count;                                              enter
 1382        ptr (ndecsy) = hash (idx);                                                  enter
 1383        hash (idx) = ndecsy;                                                        enter
 1384        return (ndecsy);                                                            enter
 1385  end enter;                                                                        enter
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9528     data   1342      12
k               fixed      9529     data   1342       4
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 45
symbol          type       loc   segment defined ref count
 
l               fixed      9526     data   1338       2
n               character   812   string   1338       5
s               fixed      9527     data   1338       2
t               fixed      9525     data   1338       3
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 46
 line    source statement                                                               procedure and compiler information
 
 1386   id_lookup:                                                                      *
 1387     procedure (p);                                                                *
 1388        /* looks up the identifier at p in the analysis stack in the                id_lookup
 1389           symbol table and initializes fixl, cnt, type, and inx                    id_lookup
 1390           appropriately.  if the identifier is not found, fixl is                  id_lookup
 1391           set to -1                                                                id_lookup
 1392        */                                                                          id_lookup
 1393        declare p fixed, i fixed;                                                   id_lookup
 1394        char_temp = var (p);                                                        id_lookup
 1395        i = hash (hasher (char_temp));                                              id_lookup
 1396        do while i ~= -1;                                                           id_lookup
 1397           idcompares = idcompares + 1;                                             id_lookup c16 = -1
 1398           if syt(i) = char_temp then                                               id_lookup
 1399              do;                                                                   id_lookup
 1400                 fixl (p) = i;                                                      id_lookup
 1401                 cnt (p) = 0;        /* initialize subscript count */               id_lookup
 1402                 type (p) = VARIABLE;                                               id_lookup
 1403                 if sytype (i) = SPECIAL then                                       id_lookup
 1404                    fixv (p) = sytloc (i);    /* builtin function */                id_lookup
 1405                 else                                                               id_lookup
 1406                    fixv (p) = 0;                                                   id_lookup
 1407                 inx (p) = 0;       /* location of index */                         id_lookup
 1408                 reg(p) = 0;                                                        id_lookup
 1409                 sytco (i) = sytco (i) + 1;                                         id_lookup
 1410                 return;                                                            id_lookup
 1411              end;                                                                  id_lookup
 1412           i = ptr (i);                                                             id_lookup
 1413        end;                                                                        id_lookup
 1414        fixl (p) = -1;              /* identifier not found */                      id_lookup
 1415  end id_lookup;                                                                    id_lookup
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9549     data   1393      10
p               fixed      9548     data   1387       9
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 47
 line    source statement                                                               procedure and compiler information
 
 1416  undeclared_id:                                                                   *
 1417     procedure (p);                                                                *
 1418        /* issues an error message for undeclared identifiers and                   undeclared_id
 1419           enters them with default type in the symbol table                        undeclared_id
 1420       */                                                                           undeclared_id
 1421        declare p fixed;                                                            undeclared_id
 1422        call error ('undeclared identifier: ' || var (p), 0);                       undeclared_id
 1423        call emitdataword (0);                                                      undeclared_id
 1424        fixl (p) = enter (var (p), FIXEDTYPE, dp-1, 1);                             undeclared_id
 1425        cnt (p) = 0;                                                                undeclared_id
 1426        fixv (p) = 0;                                                               undeclared_id
 1427        inx (p) = 0;                                                                undeclared_id
 1428        sytco (ndecsy) = 1;            /* count first reference */                  undeclared_id
 1429        sytcard (ndecsy) = -1;         /* flag undeclared identifier */             undeclared_id
 1430        type (p) = VARIABLE;                                                        undeclared_id
 1431  end undeclared_id;                                                                undeclared_id
 
symbol table dump
 
symbol          type       loc   segment defined ref count
p               fixed      9551     data   1417       7
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 48
 line    source statement                                                               procedure and compiler information
 
 1432   /*                                                                              *
 1433          a r i t h e m e t i c   p r o c e d u r e s                              *
 1434   */                                                                              *
 1435  clearars:                                                                        *
 1436     procedure;                                                                    *
 1437        /* free all the temproary arithemetic registers */                          clearars
 1438        do i = 0 to 11;                                                             clearars
 1439           acc(i) = AVAIL;                                                          clearars c17 = 11
 1440        end;                                                                        clearars
 1441  end clearars;                                                                     clearars
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 49
 line    source statement                                                               procedure and compiler information
 
 1442  findar:                                                                          *
 1443     procedure;                                                                    *
 1444         declare i fixed;                                                           findar
 1445        /* get a temporary arithemetic register */                                  findar
 1446        if target_register > -1 then                                                findar
 1447           if acc (target_register) = AVAIL then                                    findar
 1448              do;                                                                   findar
 1449                 acc (target_register) = BUSY;                                      findar
 1450                 return target_register;                                            findar
 1451              end;                                                                  findar
 1452        do i = 1 to 11;                                                             findar
 1453           if acc(i) = AVAIL then                                                   findar
 1454              do;                                                                   findar
 1455                 acc(i) = BUSY;                                                     findar
 1456                 return (i);                                                        findar
 1457              end;                                                                  findar
 1458        end;                                                                        findar
 1459        call error ('used all accumulators', 0);                                    findar
 1460        return (0);                                                                 findar
 1461  end findar;                                                                       findar
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9559     data   1444       4
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 50
 line    source statement                                                               procedure and compiler information
 
 1462  movestacks:                                                                      *
 1463     procedure (f, t);                                                             *
 1464        declare f fixed, t fixed;                                                   movestacks
 1465        /* move all compiler stacks down from f to t */                             movestacks
 1466        type (t) = type (f);                                                        movestacks
 1467        reg (t) = reg (f);                                                          movestacks
 1468        cnt (t) = cnt (f);                                                          movestacks
 1469        var (t) = var (f);                                                          movestacks
 1470        fixl (t) = fixl (f);                                                        movestacks
 1471        fixv (t) = fixv (f);                                                        movestacks
 1472        inx (t) = inx (f);                                                          movestacks
 1473        ppsave (t) = ppsave (f);                                                    movestacks
 1474  end movestacks;                                                                   movestacks
 
symbol table dump
 
symbol          type       loc   segment defined ref count
f               fixed      9566     data   1463       8
t               fixed      9567     data   1463       8
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 51
 line    source statement                                                               procedure and compiler information
 
 1475  forceaddress:                                                                    *
 1476     procedure(sp);                                                                *
 1477        /* generates the address of <VARIABLE> in the analysis stack                forceaddress
 1478           at sp.                                                                   forceaddress
 1479        */                                                                          forceaddress
 1480        declare sp fixed, j fixed, r fixed;                                         forceaddress
 1481        r = findar;                                                                 forceaddress
 1482        j = fixl(sp);                                                               forceaddress
 1483        call emitinst (movei,r,0,sytloc(j),0,sytseg(j));                            forceaddress
 1484        reg(j) = r;                                                                 forceaddress
 1485  end forceaddress;                                                                 forceaddress
 
symbol table dump
 
symbol          type       loc   segment defined ref count
j               fixed      9569     data   1480       4
r               fixed      9570     data   1480       3
sp              fixed      9568     data   1476       1
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 52
 line    source statement                                                               procedure and compiler information
 
 1486  setinit:                                                                         *
 1487     procedure;                                                                    *
 1488        /* places initial values into data area */                                  setinit
 1489        declare tmiiil character initial ('too many items in initial list');        setinit
 1490        if itype = CHRTYPE then                                                     setinit
 1491           do;                                                                      setinit
 1492              if dsp < newdsp then                                                  setinit
 1493                 do;                                                                setinit
 1494                    if type (mpp1) ~= CHRTYPE then s = fixv (mpp1);                 setinit
 1495                    else s = var (mpp1);     /* the string */                       setinit
 1496                    i = length (s);                                                 setinit
 1497                    if i = 0 then                                                   setinit
 1498                       call emitdesc (0,0);                                         setinit
 1499                    else                                                            setinit
 1500                       do;                                                          setinit
 1501                          call emitdesc (i, dpoffset+shl(dp,2));                    setinit
 1502                          do j = 0 to i - 1;                                        setinit
 1503                             call emitbyte (byte (s, j));                           setinit
 1504                          end;                                                      setinit
 1505                        end;                                                        setinit
 1506                 end;                                                               setinit
 1507              else call error (tmiiil,0);                                           setinit
 1508           end;                                                                     setinit
 1509        else                                                                        setinit
 1510           if type (mpp1) ~= CONSTANT then                                          setinit
 1511              call error ('illegal CONSTANT in initial list',0);                    setinit
 1512           else                                                                     setinit
 1513              if itype = FIXEDTYPE then                                             setinit
 1514                 do;                                                                setinit
 1515                 if dp < newdp then call emitdataword (fixv(mpp1));                 setinit
 1516                 else call error (tmiiil,0);                                        setinit
 1517                 end;                                                               setinit
 1518              else   /* must be BYTETYPE */                                         setinit
 1519                 if dp < newdp | (dp = newdp & dpoffset < newdpoffset) then         setinit
 1520                    call emitbyte(fixv(mpp1));                                      setinit
 1521                 else call error (tmiiil,0);                                        setinit
 1522  end setinit;                                                                      setinit
 
symbol table dump
 
symbol          type       loc   segment defined ref count
tmiiil          character   818   string   1489       3
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 53
 line    source statement                                                               procedure and compiler information
 
 1523  save_acs:                                                                        *
 1524     procedure (n);                                                                *
 1525        /* generate code to save BUSY acs, up to ac-n */                            save_acs
 1526        declare n fixed;                                                            save_acs
 1527        declare i fixed;                                                            save_acs
 1528        do i = 1 to n;                                                              save_acs
 1529           if (acc(i) = BUSY) then call emitinst (push,15,0,i,0,0);                 save_acs
 1530        end;                                                                        save_acs
 1531  end save_acs;                                                                     save_acs
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9589     data   1527       3
n               fixed      9588     data   1524       1
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 54
 line    source statement                                                               procedure and compiler information
 
 1532  restore_acs:                                                                     *
 1533     procedure (n);                                                                *
 1534        /* generate code to restore BUSY acs, up to ac-n  */                        restore_acs
 1535        declare n fixed;                                                            restore_acs
 1536        declare i fixed, j fixed;                                                   restore_acs
 1537        do i = 1 to n;                                                              restore_acs
 1538           j = n - i + 1;                                                           restore_acs
 1539           if (acc(j) = BUSY) then call emitinst (pop,15,0,j,0,0);                  restore_acs
 1540        end;                                                                        restore_acs
 1541  end restore_acs;                                                                  restore_acs
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9592     data   1536       2
j               fixed      9593     data   1536       3
n               fixed      9591     data   1533       2
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 55
 line    source statement                                                               procedure and compiler information
 
 1542  proc_start:                                                                      *
 1543     procedure;                                                                    *
 1544        /* generates code for the head of a procedure */                            proc_start
 1545        ppsave(mp) = findlabel;           /* something to goto */                   proc_start
 1546        call emitinst (jrst,0,0,ppsave(mp),0,4); /* go around proc */               proc_start
 1547        if sytseg(fixl(mp)) = 4 then call emitlabel(sytloc(fixl(mp)),4);            proc_start
 1548        sytseg(fixl(mp)) = 2;                                                       proc_start
 1549        sytloc(fixl(mp)) = pp;            /* addr of proc */                        proc_start
 1550  end proc_start;                                                                   proc_start
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 56
 line    source statement                                                               procedure and compiler information
 
 1551  tdeclare:                                                                        *
 1552     procedure (dim);                                                              *
 1553     /* allocates storage for identifiers in declaration */                         tdeclare
 1554        declare dim fixed;                                                          tdeclare
 1555        declare i   fixed;                                                          tdeclare
 1556     allocate:                                                                      tdeclare
 1557        procedure (p, dim);                                                         tdeclare
 1558           /* allocates storage for the identifier at p in the analysis             allocate
 1559              stack with dimension dim                                              allocate
 1560           */                                                                       allocate
 1561           declare p fixed, dim fixed, j fixed, k fixed;                            allocate
 1562           dim = dim + 1;                    /* actual number of items */           allocate
 1563           do case type (p);                                                        allocate
 1564              ;    /*  case 0 -- dummy */                                           allocate case 0.
 1565              ;    /*  case 1 -- label type */                                      allocate case 1.
 1566              ;    /*  case 2 -- ACCUMULATOR */                                     allocate case 2.
 1567              ;    /*  case 3 -- VARIABLE */                                        allocate case 3.
 1568              ;    /*  case 4 -- CONSTANT */                                        allocate case 4.
 1569              ;    /*  case 5 -- condition */                                       allocate case 5.
 1570              do;   /* case 6 -- CHRTYPE */                                         allocate case 6.
 1571                 j = dsp; k = 3;                                                    allocate
 1572                 newdsp = dsp + dim;                                                allocate
 1573              end;                                                                  allocate
 1574              do;  /*  case 7 -- FIXEDTYPE */                                       allocate case 7.
 1575                 if dpoffset > 0 then                                               allocate
 1576                    do;                                                             allocate
 1577                       call flush_datacard;                                         allocate
 1578                       olddp = dp;                                                  allocate
 1579                       olddpoffset = 0;                                             allocate
 1580                    end;                                                            allocate
 1581                 j = dp; k = 1;                                                     allocate
 1582                 newdp = dp + dim; newdpoffset = 0;                                 allocate
 1583              end;                                                                  allocate
 1584              do;  /*  case 8 -- BYTETYPE */                                        allocate case 8.
 1585                 if dpoffset > 0 then                                               allocate
 1586                    if i = 1 then                                                   allocate
 1587                       do;                                                          allocate
 1588                          call flush_datacard;                                      allocate
 1589                          olddp = dp; olddpoffset = 0;                              allocate
 1590                       end;                                                         allocate
 1591                    else                                                            allocate
 1592                       do;                                                          allocate
 1593                          dp = dp + 1; dpoffset = 0;                                allocate
 1594                       end;                                                         allocate
 1595                 newdpoffset = dim mod 4;                                           allocate
 1596                 newdp = dp + dim/4;                                                allocate
 1597                 j = dp; k = 1;                                                     allocate
 1598              end;                                                                  allocate
 1599              do;  /*  case 9 -- FORWARDTYPE */                                     allocate case 9.
 1600                 j = findlabel; k = 4;                                              allocate
 1601                 newdp = dp; newdpoffset = dpoffset; /* copy old pointers  */       allocate
 1602              end;                                                                  allocate
 1603              ;    /*  case 10 -- DESCRIPT */                                       allocate case 10.
 1604              ;    /*  case 11 -- SPECIAL */                                        allocate case 11.
 1605              ;    /*  case 12 -- FORWARDCALL */                                    allocate case 12.
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 57
 line    source statement                                                               procedure and compiler information
 
 1606              ;    /*  case 13 -- PROCTYPE */                                       allocate case 13.
 1607              ;    /*  case 14 -- CHARPROCTYPE */                                   allocate case 14.
 1608           end; /* case on type (p) */                                              allocate case 15.
 1609           sytype (fixl(p)) = type (p);                                             allocate
 1610           sytloc (fixl (p)) = j;                                                   allocate
 1611           sytseg (fixl (p)) = k;                                                   allocate
 1612     end allocate;                                                                  allocate
 
symbol table dump
 
symbol          type       loc   segment defined ref count
dim             fixed      9598     data   1557       6
j               fixed      9599     data   1561       5
k               fixed      9600     data   1561       5
p               fixed      9597     data   1557       5
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 58
 line    source statement                                                               procedure and compiler information
 
 1613                                                                                    tdeclare
 1614        olddp = dp;                                                                 tdeclare
 1615        olddsp = dsp;                                                               tdeclare
 1616        olddpoffset = dpoffset;                                                     tdeclare
 1617        type(mp) = type(sp);                                                        tdeclare
 1618        casep = fixl(mp);                                                           tdeclare
 1619        do i = 1 to inx(mp);                                                        tdeclare
 1620           fixl(mp) = casestack(casep+i); /* symbol table pointer */                tdeclare
 1621           call allocate (mp,dim);                                                  tdeclare
 1622           dp = newdp;                                                              tdeclare
 1623           dsp = newdsp;                                                            tdeclare
 1624           dpoffset = newdpoffset;                                                  tdeclare
 1625           end;                                                                     tdeclare
 1626        dp = olddp;                                                                 tdeclare
 1627        dsp = olddsp;                                                               tdeclare
 1628        dpoffset = olddpoffset;                                                     tdeclare
 1629  end tdeclare;                                                                     tdeclare
 
symbol table dump
 
symbol          type       loc   segment defined ref count
allocate        procedure  3520  program   1556       1
  parameter  1  fixed      9597     data   1557       6
  parameter  2  fixed      9598     data   1557       7
dim             fixed      9595     data   1552       1
i               fixed      9596     data   1555       3
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 59
 line    source statement                                                               procedure and compiler information
 
 1630  check_string_overflow:                                                           *
 1631     procedure;                                                                    *
 1632        /* generate a check to see if compactify needs to be called */              check_string_overflow
 1633        call emitinst (pushj,15,0,string_check,0,2);                                check_string_overflow
 1634  end check_string_overflow;                                                        check_string_overflow
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 60
 line    source statement                                                               procedure and compiler information
 
 1635  callsub:procedure (sl,f,p);                                                      *
 1636        /* generates code to call a function or procedure at sl                     callsub
 1637           also does housekeeping for return values                                 callsub
 1638        */                                                                          callsub
 1639        declare sl fixed, f fixed, p fixed;                                         callsub
 1640        call save_acs (11);                                                         callsub
 1641        call emitinst (pushj,15,0,sl,0,sytseg(fixl(p)));                            callsub
 1642        call restore_acs (11);                                                      callsub
 1643        if f = 1 then                                                               callsub
 1644           do;  /* move returned value from register zero */                        callsub
 1645              i = findar;                                                           callsub
 1646              if i ~= 0 then call emitinst (move,i,0,0,0,0);                        callsub
 1647              type(p) = ACCUMULATOR;                                                callsub
 1648              reg(p) = i;                                                           callsub
 1649              acc(i) = BUSY;                                                        callsub
 1650              stillinzero = i;                                                      callsub
 1651           end;                                                                     callsub
 1652  end callsub;                                                                      callsub
 
symbol table dump
 
symbol          type       loc   segment defined ref count
f               fixed      9603     data   1635       1
p               fixed      9604     data   1635       3
sl              fixed      9602     data   1635       1
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 61
 line    source statement                                                               procedure and compiler information
 
 1653  backup:                                                                          *
 1654     procedure;                                                                    *
 1655           code_full(code_head) = FALSE;                                            backup
 1656           code_head = (code_head-1) & 3;                                           backup
 1657           instruct(move) = instruct(move) -1;                                      backup
 1658           pp = pp - 1;                                                             backup
 1659           stillinzero = 0;                                                         backup
 1660           if control(byte('E')) then                                               backup
 1661              call printline (backmsg,-1);                                          backup
 1662     end backup;                                                                    backup
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 62
 line    source statement                                                               procedure and compiler information
 
 1663  delete_move:                                                                     *
 1664     procedure (p,op,ac,ind,operand,index,reloc);                                  *
 1665     /*  check stillinzero flag to see if the datum about to                        delete_move
 1666          be moved is still in register zero.  if so, then delete                   delete_move
 1667          the last instruction generated (if a "move"),                             delete_move
 1668          and move it directly from 0 to the desried dest.                          delete_move
 1669          this is designed to eliminate most extra moves                            delete_move
 1670          of function results. */                                                   delete_move
 1671        declare p fixed;                                                            delete_move
 1672        declare op fixed, ac fixed, ind fixed, operand fixed,                       delete_move
 1673             index fixed, reloc fixed;                                              delete_move
 1674        if stillinzero ~= 0 then                                                    delete_move
 1675           do;                                                                      delete_move
 1676              if op = movem & stillinzero = ac then                                 delete_move
 1677                 do;                                                                delete_move
 1678                    call backup;                                                    delete_move
 1679                    acc(reg(p)) = AVAIL;                                            delete_move
 1680                    reg(p) = 0;                                                     delete_move
 1681                    ac = 0;                                                         delete_move
 1682                 end;                                                               delete_move
 1683              else if op = move  & stillinzero = operand                            delete_move
 1684                                 & (ind + index + reloc) = 0 then                   delete_move
 1685                 do;                                                                delete_move
 1686                    call backup;                                                    delete_move
 1687                    acc(reg(p)) = AVAIL;                                            delete_move
 1688                    reg(p) = 0;                                                     delete_move
 1689                    operand = 0;                                                    delete_move
 1690                 end;                                                               delete_move
 1691           end;                                                                     delete_move
 1692        call emitinst (op,ac,ind,operand,index,reloc);                              delete_move
 1693     end delete_move;                                                               delete_move
 
symbol table dump
 
symbol          type       loc   segment defined ref count
ac              fixed      9607     data   1664       3
ind             fixed      9608     data   1664       2
index           fixed      9610     data   1664       2
op              fixed      9606     data   1664       3
operand         fixed      9609     data   1664       3
p               fixed      9605     data   1664       4
reloc           fixed      9611     data   1664       2
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 63
 line    source statement                                                               procedure and compiler information
 
 1694  emit_inline:                                                                     *
 1695     procedure (flag);                                                             *
 1696     /* generate an arbitrary instruction specified by programmer */                emit_inline
 1697        declare flag bit(1);                                                        emit_inline
 1698        declare fl fixed;                                                           emit_inline
 1699        declare inst(5) fixed;                                                      emit_inline
 1700        declare binlm character initial ('improper argument to inline');            emit_inline
 1701        if cnt(mp) < 5 then                                                         emit_inline
 1702           do;                                                                      emit_inline
 1703              if type(mpp1) = CONSTANT then inst(cnt(mp)-1) = fixv(mpp1);           emit_inline
 1704              else call error (binlm,1);                                            emit_inline
 1705              if flag then call error (binlm,1);                                    emit_inline
 1706           end;                                                                     emit_inline
 1707        else if cnt(mp) = 5 then                                                    emit_inline
 1708           do;                                                                      emit_inline
 1709              if type(mpp1) = CONSTANT then                                         emit_inline
 1710                 do;                                                                emit_inline
 1711                    inst(4) = fixv(mpp1);                                           emit_inline
 1712                    inst(5) = 0;                                                    emit_inline
 1713                 end;                                                               emit_inline
 1714              else if type(mpp1) = VARIABLE then                                    emit_inline
 1715                 do;                                                                emit_inline
 1716                    fl = fixl(mpp1);                                                emit_inline
 1717                    inst(4) = sytloc(fl);                                           emit_inline
 1718                    inst(5) = sytseg(fl);                                           emit_inline
 1719                 end;                                                               emit_inline
 1720              else call error (binlm,1);                                            emit_inline
 1721              call emitinst (inst(0),inst(1),inst(2),inst(4),inst(3),inst(5));      emit_inline
 1722              reg(mp) = inst(1);                                                    emit_inline
 1723              type(mp) = ACCUMULATOR;                                               emit_inline
 1724           end;                                                                     emit_inline
 1725        else call error (binlm,1);  /* too many args to inline */                   emit_inline
 1726     end emit_inline;                                                               emit_inline
 
symbol table dump
 
symbol          type       loc   segment defined ref count
binlm           character   820   string   1700       4
fl              fixed      9613     data   1698       3
flag            bit (9)    9612     data   1695       1
inst            fixed      9614     data   1699      12
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 64
 line    source statement                                                               procedure and compiler information
 
 1727  library_call:   procedure (result, code, mp, sp);                                *
 1728     /*                                                                             library_call
 1729     generate the code for a call to the run-time routines.                         library_call
 1730     */                                                                             library_call
 1731     declare result fixed,   /* 0 = l.h.s. of = */                                  library_call
 1732             code fixed,     /* code for run-time routine*/                         library_call
 1733             mp   fixed,     /* stack pointer */                                    library_call
 1734             sp   fixed;     /* top of stack pointer */                             library_call
 1735     declare r    fixed;                                                            library_call
 1736                                                                                    library_call
 1737     if result = 0 then                                                             library_call
 1738        do;                                                                         library_call
 1739           if stillinzero = reg(sp) then                                            library_call
 1740              do;                                                                   library_call
 1741                 call backup;                                                       library_call
 1742                 acc(reg(sp)) = AVAIL;                                              library_call
 1743                 reg(sp) = 0;                                                       library_call
 1744              end;                                                                  library_call
 1745           r = reg(sp);                                                             library_call
 1746        end;                                                                        library_call
 1747     else                                                                           library_call
 1748        r = findar;                                                                 library_call
 1749     if cnt(mp) > 0 then call emitinst (code+1,r,0,0,reg(mp),0);                    library_call
 1750                    else call emitinst (code+1,r,0,0,0,0);                          library_call
 1751     if result ~= 0 then                                                            library_call
 1752        do;                                                                         library_call
 1753           reg(mp) = r;                                                             library_call
 1754           type(mp) = result;                                                       library_call
 1755        end;                                                                        library_call
 1756     end library_call;                                                              library_call
 
symbol table dump
 
symbol          type       loc   segment defined ref count
code            fixed      9628     data   1727       2
mp              fixed      9629     data   1727       4
r               fixed      9631     data   1735       5
result          fixed      9627     data   1727       3
sp              fixed      9630     data   1727       4
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 65
 line    source statement                                                               procedure and compiler information
 
 1757  monitor_call:   procedure (code, p, jobflg);                                     *
 1758     /*                                                                             monitor_call
 1759     routine to generate code for pdp-10 calli uuo.                                 monitor_call
 1760     */                                                                             monitor_call
 1761     declare code  fixed,    /* calli number */                                     monitor_call
 1762            jobflg fixed,  /* clear ac flag */                                      monitor_call
 1763             p     fixed;    /* stack pointer*/                                     monitor_call
 1764     declare r     fixed;    /* contains register to use */                         monitor_call
 1765                                                                                    monitor_call
 1766     r = findar;                                                                    monitor_call
 1767     if jobflg then call emitinst (movei,r,0,0,0,0);                                monitor_call
 1768     call emitinst (calli,r,0,code,0,0);                                            monitor_call
 1769     reg(p) = r;                                                                    monitor_call
 1770     type(p) = ACCUMULATOR;                                                         monitor_call
 1771  end monitor_call;                                                                 monitor_call
 
symbol table dump
 
symbol          type       loc   segment defined ref count
code            fixed      9632     data   1757       1
jobflg          fixed      9633     data   1757       1
p               fixed      9634     data   1757       2
r               fixed      9635     data   1764       4
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 66
 line    source statement                                                               procedure and compiler information
 
 1772  forceaccumulator:procedure (p);                                                  *
 1773        declare p fixed;                                                            forceaccumulator
 1774        /* force the operand at p into an ACCUMULATOR */                            forceaccumulator
 1775        declare sl fixed, tp fixed, sfp fixed, ss fixed;                            forceaccumulator
 1776        declare t1 character;                                                       forceaccumulator
 1777        declare r fixed;                                                            forceaccumulator
 1778        count_force = count_force + 1;                                              forceaccumulator
 1779        tp = type(p);                                                               forceaccumulator
 1780        if tp = VARIABLE then                                                       forceaccumulator
 1781            do;                                                                     forceaccumulator
 1782              sl = sytloc(fixl(p));                                                 forceaccumulator
 1783              ss = sytseg(fixl(p));                                                 forceaccumulator
 1784              sfp = sytype(fixl(p));                                                forceaccumulator
 1785              if sfp = PROCTYPE | sfp = FORWARDCALL | sfp = CHARPROCTYPE then       forceaccumulator
 1786                 do;                                                                forceaccumulator
 1787                    call callsub (sl,calltype,p);                                   forceaccumulator
 1788                    r = fixl(p)+cnt(p)+1;                                           forceaccumulator
 1789                    if length(syt(r)) = 0 then                                      forceaccumulator
 1790                       if r <= ndecsy then                                          forceaccumulator
 1791                          call printline ('** warning--not all parameters supplied.',-1); forceaccumulator
 1792                    if sfp = CHARPROCTYPE then type(p) = DESCRIPT;                  forceaccumulator
 1793                 end;                                                               forceaccumulator
 1794              else if sfp = SPECIAL then                                            forceaccumulator
 1795                 do;                                                                forceaccumulator
 1796                    if sl = 6 then                                                  forceaccumulator
 1797                       do;  /* builtin function input */                            forceaccumulator
 1798                          call check_string_overflow;                               forceaccumulator
 1799                          call emitinst (move,13,0,tsa,0,1);                        forceaccumulator
 1800                          call library_call (DESCRIPT,1,p,0);                       forceaccumulator
 1801                          call emitinst (movem,13,0,tsa,0,1);                       forceaccumulator
 1802                          call emitinst (movem,12,0,str,0,3);                       forceaccumulator
 1803                       end;                                                         forceaccumulator
 1804                    else if sl = 8 then                                             forceaccumulator
 1805                       do;  /* built-in function file */                            forceaccumulator
 1806                        if cnt(p) ~= 1 then call error (filemsg,0);                 forceaccumulator
 1807                           else call library_call (ACCUMULATOR,5,p,0);              forceaccumulator
 1808                       end;                                                         forceaccumulator
 1809                    else if sl = 12 then                                            forceaccumulator
 1810                       do;  /* exit */                                              forceaccumulator
 1811                          call emitinst (4,0,0,0,0,0);                              forceaccumulator
 1812                       end;                                                         forceaccumulator
 1813                    else if sl = 13 then call monitor_call (19,p,0);                forceaccumulator
 1814                    else if sl = 14 then call monitor_call (12,p,0);                forceaccumulator
 1815                    else if sl = 19 then call monitor_call (23,p,1);                forceaccumulator
 1816                    else call error ('illegal use of ' || syt(fixl(p)),0);          forceaccumulator
 1817                 end;                                                               forceaccumulator
 1818              else                                                                  forceaccumulator
 1819                 do;  /* fetch the VARIABLE (all else has failed) */                forceaccumulator
 1820                    if sfp ~= BYTETYPE then                                         forceaccumulator
 1821                       do;   /* we don't have to do crazy addressing */             forceaccumulator
 1822                          r = findar;     /* get reg for result */                  forceaccumulator
 1823                          call emitinst (move,r,0,sl,inx(p),ss);                    forceaccumulator
 1824                       end;                                                         forceaccumulator
 1825                    else                                                            forceaccumulator
 1826                       do;  /* byte addressing */                                   forceaccumulator
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 67
 line    source statement                                                               procedure and compiler information
 
 1827                          if inx(p) ~= 0 then                                       forceaccumulator
 1828                             do; /* good grief, subscripting of bytes */            forceaccumulator
 1829                                r = findar;                                         forceaccumulator
 1830                                call emitinst (move,12,0,inx(p),0,0);               forceaccumulator
 1831                                call emitinst (lsh,12,0,    -2,0,0);                forceaccumulator
 1832                                call emitinst (andi,inx(p),0,3,0,0);                forceaccumulator
 1833                                if (sl | ss) ~= 0 then call emitinst (addi,12,0,sl,0,ss); forceaccumulator
 1834                                call emitinst (ldb,r,0,byteptrs,inx(p),1);          forceaccumulator
 1835                             end;                                                   forceaccumulator
 1836                           else                                                     forceaccumulator
 1837                             do; /* non-subscripted byte */                         forceaccumulator
 1838                                r = findar;                                         forceaccumulator
 1839                                call emitinst (movei,12,0,sl,0,ss);                 forceaccumulator
 1840                                call emitinst (ldb,r,0,byteptrs,0,1);               forceaccumulator
 1841                             end;                                                   forceaccumulator
 1842                       end;                                                         forceaccumulator
 1843                    if sfp = CHRTYPE then type(p) = DESCRIPT;                       forceaccumulator
 1844                    else type(p) = ACCUMULATOR;                                     forceaccumulator
 1845                    reg(p) = r;                                                     forceaccumulator
 1846                    if inx(p) ~= 0 then acc(inx(p)) = AVAIL;                        forceaccumulator
 1847                 end;                                                               forceaccumulator
 1848           end;                                                                     forceaccumulator
 1849        else if tp = CONSTANT then                                                  forceaccumulator
 1850           do;  /* fetch a CONSTANT into an ACCUMULATOR */                          forceaccumulator
 1851              r = findar;                                                           forceaccumulator
 1852              if fixv(p) < "20000" & fixv(p) > - "20000" then                       forceaccumulator
 1853                 call emitinst (hrrei,r,0,fixv(p),0,0);                             forceaccumulator
 1854              else                                                                  forceaccumulator c18 = -131072
 1855                 do;  /* put down a CONSTANT and pick it up */                      forceaccumulator
 1856                    call emitconstant (fixv(p));                                    forceaccumulator
 1857                    call emitinst (move,r,0,adr,0,1);                               forceaccumulator
 1858                 end;                                                               forceaccumulator
 1859              reg(p) = r;                                                           forceaccumulator
 1860              type(p) = ACCUMULATOR;                                                forceaccumulator
 1861           end;                                                                     forceaccumulator
 1862        else if tp = CHRTYPE then                                                   forceaccumulator
 1863           do;  /* fetch a descriptor into an ACCUMULATOR */                        forceaccumulator
 1864              r = findar;                                                           forceaccumulator
 1865              type(p) = DESCRIPT;                                                   forceaccumulator
 1866              reg(p) = r;                                                           forceaccumulator
 1867              t1 = var(p);                                                          forceaccumulator
 1868              sl = length(t1);                                                      forceaccumulator
 1869              if sl = 0 then call emitinst (movei,r,0,0,0,0);                       forceaccumulator
 1870              else                                                                  forceaccumulator
 1871                 do;  /* generate descriptor and string, then pick it up */         forceaccumulator
 1872                    call emitinst (move,r,0,dsp,0,3);                               forceaccumulator
 1873                    call emitdesc (sl,shl(dp,2)+dpoffset);                          forceaccumulator
 1874                    do sl = 0 to sl-1;                                              forceaccumulator
 1875                       call emitbyte (byte(t1,sl));                                 forceaccumulator
 1876                    end;                                                            forceaccumulator
 1877                 end;                                                               forceaccumulator
 1878           end;                                                                     forceaccumulator
 1879        else if tp ~= ACCUMULATOR then if tp ~= DESCRIPT then                       forceaccumulator
 1880                 call error ('forceaccumulator failed ***',1);                      forceaccumulator
 1881  end forceaccumulator;                                                             forceaccumulator
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 68
 line    source statement                                                               procedure and compiler information
 
 
symbol table dump
 
symbol          type       loc   segment defined ref count
p               fixed      9636     data   1772      34
r               fixed      9641     data   1777      18
sfp             fixed      9639     data   1775       8
sl              fixed      9637     data   1775      18
ss              fixed      9640     data   1775       5
t1              character   821   string   1776       3
tp              fixed      9638     data   1775       6
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 69
 line    source statement                                                               procedure and compiler information
 
 1882  forcedescriptor:                                                                 *
 1883     procedure (p);                                                                *
 1884        /* get a descriptor for the operand p */                                    forcedescriptor
 1885        declare p fixed;                                                            forcedescriptor
 1886        call forceaccumulator (p);                                                  forcedescriptor
 1887        if type (p) ~= DESCRIPT then                                                forcedescriptor
 1888           do; /* use the number to decimal string conversion routine */            forcedescriptor
 1889              call delete_move (p,movem,reg(p),0,c,0,1);  /* save as c */           forcedescriptor
 1890              acc(reg(p)) = AVAIL;                                                  forcedescriptor
 1891              call save_acs (1);                                                    forcedescriptor
 1892              call emitinst (pushj,15,0,nmbrentry,0,2);                             forcedescriptor
 1893              call restore_acs (1);                                                 forcedescriptor
 1894              acc(reg(p)) = BUSY;                                                   forcedescriptor
 1895              if reg(p) ~= 0 then call emitinst (move,reg(p),0,0,0,0);              forcedescriptor
 1896              type (p) = DESCRIPT;             /* it is now a string */             forcedescriptor
 1897              stillinzero = reg(p);                                                 forcedescriptor
 1898           end;                                                                     forcedescriptor
 1899  end forcedescriptor;                                                              forcedescriptor
 
symbol table dump
 
symbol          type       loc   segment defined ref count
p               fixed      9665     data   1883      10
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 70
 line    source statement                                                               procedure and compiler information
 
 1900  genstore:procedure (mp, sp);                                                     *
 1901        declare mp fixed, sp fixed;                                                 genstore
 1902        /* generate type conversion (if necessary) & storage code --                genstore
 1903           also handles output on the left of the replacement operator              genstore
 1904        */                                                                          genstore
 1905        declare sl fixed, sfp fixed, ss fixed;                                      genstore
 1906        count_store = count_store + 1;                                              genstore
 1907        sl = sytloc(fixl(mp));                                                      genstore
 1908        ss = sytseg(fixl(mp));                                                      genstore
 1909        sfp = sytype(fixl(mp));                                                     genstore
 1910        if sfp = SPECIAL then                                                       genstore
 1911           do;                                                                      genstore
 1912              if sl = 7 then                                                        genstore
 1913                 do;  /* builtin function output */                                 genstore
 1914                    call forcedescriptor(sp);                                       genstore
 1915                    call library_call (0,2,mp,sp);                                  genstore
 1916                 end;                                                               genstore
 1917              else if sl = 8 then                                                   genstore
 1918                 do;   /* builtin function file */                                  genstore
 1919                    if cnt(mp) ~= 1 then                                            genstore
 1920                       call error (filemsg,0);                                      genstore
 1921                    call forceaccumulator (sp);                                     genstore
 1922                    call library_call (0,6,mp,sp);                                  genstore
 1923                 end;                                                               genstore
 1924              else if sl = 20 then                                                  genstore
 1925                 do;    /* built-in function  filename */                           genstore
 1926                    call forcedescriptor(sp);                                       genstore
 1927                    call library_call (0,7,mp,sp);                                  genstore
 1928                 end;                                                               genstore
 1929              else call error ('illegal use of ' || syt(fixl(mp)),0);               genstore
 1930           end;                                                                     genstore
 1931        else                                                                        genstore
 1932           do;                                                                      genstore
 1933              if sfp = CHRTYPE then                                                 genstore
 1934                 do;                                                                genstore
 1935                    call forcedescriptor(sp);                                       genstore
 1936                    call delete_move (sp,movem,reg(sp),0,sl,inx(mp),ss);            genstore
 1937                 end;                                                               genstore
 1938              else if type(sp) = DESCRIPT | type(sp) = CHRTYPE then                 genstore
 1939                   call error ('assignment requires illegal type conversion.',0);   genstore
 1940              else                                                                  genstore
 1941                 do;     /* FIXEDTYPE or BYTETYPE */                                genstore
 1942                    if sfp = FIXEDTYPE then                                         genstore
 1943                       do;                                                          genstore
 1944                       if type(sp) = CONSTANT & fixv(sp) = 0 then                   genstore
 1945                          call emitinst(setzm,0,0,sl,inx(mp),ss);                   genstore
 1946                          else                                                      genstore
 1947                             do;                                                    genstore
 1948                                call forceaccumulator(sp);                          genstore
 1949                                call delete_move (sp,movem,reg(sp),0,sl,inx(mp),ss); genstore
 1950                             end;                                                   genstore
 1951                       end;                                                         genstore
 1952                    else                                                            genstore
 1953                       do;      /* must be BYTETYPE */                              genstore
 1954                          call forceaccumulator(sp);                                genstore
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 71
 line    source statement                                                               procedure and compiler information
 
 1955                          if inx(mp) ~= 0 then                                      genstore
 1956                             do;  /* good grief, subscripting */                    genstore
 1957                                 call emitinst (move,12,0,inx(mp),0,0);             genstore
 1958                                 call emitinst (lsh,12,0,    -2,0,0);               genstore
 1959                                 call emitinst (andi,inx(mp),0,3,0,0);              genstore
 1960                                 if (sl | ss) ~= 0 then call emitinst (addi,12,0,sl,0,ss); genstore
 1961                                 call emitinst (dpb,reg(sp),0,byteptrs,inx(mp),1);  genstore
 1962                             end;                                                   genstore
 1963                          else                                                      genstore
 1964                             do;                                                    genstore
 1965                                 call emitinst (movei,12,0,sl,0,ss);                genstore
 1966                                 call emitinst (dpb,reg(sp),0,byteptrs,0,1);        genstore
 1967                             end;                                                   genstore
 1968                       end;                                                         genstore
 1969                 end;                                                               genstore
 1970           end;                                                                     genstore
 1971        acc(inx(mp)) = AVAIL;                                                       genstore
 1972        call movestacks (sp,mp);                                                    genstore
 1973  end genstore;                                                                     genstore
 
symbol table dump
 
symbol          type       loc   segment defined ref count
mp              fixed      9666     data   1900      17
sfp             fixed      9669     data   1905       4
sl              fixed      9668     data   1905      10
sp              fixed      9667     data   1900      20
ss              fixed      9670     data   1905       7
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 72
 line    source statement                                                               procedure and compiler information
 
 1974  shouldcommute:procedure;                                                         *
 1975        if type(sp) = CONSTANT then return (FALSE);                                 shouldcommute
 1976        if type(mp) = CONSTANT then return (TRUE);                                  shouldcommute
 1977        if type(sp) = VARIABLE & sytype(fixl(sp)) = FIXEDTYPE then return (FALSE);  shouldcommute
 1978        if type(mp) = VARIABLE & sytype(fixl(mp)) = FIXEDTYPE then return (TRUE);   shouldcommute
 1979        return FALSE;                                                               shouldcommute
 1980  end shouldcommute;                                                                shouldcommute
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 73
 line    source statement                                                               procedure and compiler information
 
 1981  arithemit:procedure(op,commutative);                                             *
 1982     declare op fixed, commutative fixed, tp fixed;                                 arithemit
 1983     declare awasd character initial ('arithmetic with a string descriptor');       arithemit
 1984     /* emit an instruction for an infix operator -- connect mp & sp */             arithemit
 1985     count_arith = count_arith + 1;                                                 arithemit
 1986     tp = 0;                                                                        arithemit
 1987     if commutative then                                                            arithemit
 1988        if shouldcommute then                                                       arithemit
 1989           do;                                                                      arithemit
 1990              tp = mp; mp = sp; sp = tp;                                            arithemit
 1991              if op >= cam & op <= cmprhi then op = compareswap(op-cam)+cam;        arithemit
 1992           end;                                                                     arithemit
 1993     call forceaccumulator(mp);  /* get the left one into an ACCUMULATOR */         arithemit
 1994     if type(mp) = DESCRIPT then call error (awasd,0);                              arithemit
 1995     else if type(sp) = VARIABLE & sytype(fixl(sp)) = FIXEDTYPE then                arithemit
 1996        do;  /* operate from storage */                                             arithemit
 1997           call emitinst (op,reg(mp),0,sytloc(fixl(sp)),inx(sp),sytseg(fixl(sp)));  arithemit
 1998           acc(inx(sp)) = AVAIL;                                                    arithemit
 1999        end;                                                                        arithemit
 2000     else if type(sp) = CONSTANT then                                               arithemit
 2001        do;                                                                         arithemit
 2002           if fixv(sp) < "40000" & fixv(sp) >= 0 then /* use immediate */           arithemit
 2003              do;                                                                   arithemit
 2004                 if op >= cam & op <= cmprhi then op=op-9; /* sob code order */     arithemit
 2005                    call emitinst(op+1,reg(mp),0,fixv(sp),0,0);                     arithemit
 2006              end;                                                                  arithemit
 2007           else                                                                     arithemit
 2008              do;                                                                   arithemit
 2009                 call emitconstant (fixv(sp));                                      arithemit
 2010                 call emitinst (op,reg(mp),0,adr,0,1);                              arithemit
 2011              end;                                                                  arithemit
 2012        end;                                                                        arithemit
 2013     else                                                                           arithemit
 2014         do;                                                                        arithemit
 2015           call forceaccumulator(sp);                                               arithemit
 2016           if type(sp) ~= ACCUMULATOR then call error (awasd,0);                    arithemit
 2017           else call emitinst (op,reg(mp),0,reg(sp),0,0);                           arithemit
 2018           acc(reg(sp)) = AVAIL;                                                    arithemit
 2019        end;                                                                        arithemit
 2020     if tp ~= 0 then                                                                arithemit
 2021        do;                                                                         arithemit
 2022           sp = mp; mp = tp;                                                        arithemit
 2023           call movestacks (sp,mp);                                                 arithemit
 2024        end;                                                                        arithemit
 2025  end arithemit;                                                                    arithemit
 
symbol table dump
 
symbol          type       loc   segment defined ref count
awasd           character   827   string   1983       2
commutative     fixed      9687     data   1981       1
op              fixed      9686     data   1981      12
tp              fixed      9688     data   1982       5
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 74
 line    source statement                                                               procedure and compiler information
 
 2026  boolbranch:procedure (sp,mp);                                                    *
 2027     declare sp fixed, mp fixed, r fixed;                                           boolbranch
 2028     /* generate a conditional branch for do while or an if statement               boolbranch
 2029        place the address of this branch in fixl(mp)                                boolbranch
 2030     */                                                                             boolbranch
 2031     if stillcond ~= 0 then                                                         boolbranch
 2032        do;  /* we have not generated code since setting the condition */           boolbranch
 2033           /* remove the movei =1 and movei =0 around the cam? */                   boolbranch
 2034           code_head = (code_head-2) &3; /* back up ptr */                          boolbranch
 2035           r = (code_head + 1) & 3;                                                 boolbranch
 2036           code(code_head) = code(r);                                               boolbranch
 2037           code_rel(code_head) = code_rel(r);                                       boolbranch
 2038           code_pp(code_head) = code_pp(r) -1;                                      boolbranch
 2039           code_rbits(code_head) = code_rbits(r);                                   boolbranch
 2040           code_full(r) = FALSE;                                                    boolbranch
 2041           code_full(r+1&3) = FALSE;                                                boolbranch
 2042           pp = pp - 2;                                                             boolbranch
 2043           code(code_head) = code(code_head) || ' p' || pp-1;                       boolbranch
 2044           if control(byte('E')) then                                               boolbranch
 2045              do;                                                                   boolbranch
 2046                 call printline (backmsg,-1);                                       boolbranch
 2047                 call printline (codemsg || code(code_head),-1);                    boolbranch
 2048              end;                                                                  boolbranch
 2049           instruct(movei) = instruct(movei) - 2;                                   boolbranch
 2050           acc(reg(sp)) = AVAIL;          /* free condition register */             boolbranch
 2051           r = 4;                         /* jump always */                         boolbranch
 2052        end;                                                                        boolbranch
 2053     else                                                                           boolbranch
 2054        do;                                                                         boolbranch
 2055           call forceaccumulator(sp);                                               boolbranch
 2056           call emitinst (andi,reg(sp),0,1,0,0);  /* test only low order bit */     boolbranch
 2057           acc(reg(sp)) = AVAIL;          /* free up VARIABLE register */           boolbranch
 2058           r = 2;                         /* jump if register zero */               boolbranch
 2059        end;                                                                        boolbranch
 2060     fixl(mp) = findlabel;                /* get a new label */                     boolbranch
 2061     call emitinst (jump+r,reg(sp),0,fixl(mp),0,4);                                 boolbranch
 2062  end boolbranch;                                                                   boolbranch
 
symbol table dump
 
symbol          type       loc   segment defined ref count
mp              fixed      9699     data   2026       2
r               fixed      9700     data   2027      10
sp              fixed      9698     data   2026       5
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 75
 line    source statement                                                               procedure and compiler information
 
 2063  setlimit:                                                                        *
 2064     procedure;                                                                    *
 2065        /* sets do loop limit for <iteration control> */                            setlimit
 2066        if type (mpp1) = CONSTANT then                                              setlimit
 2067           call emitconstant (fixv(mpp1));                                          setlimit
 2068        else                                                                        setlimit
 2069           do;                                                                      setlimit
 2070              call forceaccumulator (mpp1);  /* get loop limit */                   setlimit
 2071              call emitdataword (0);                                                setlimit
 2072              adr = dp - 1;                                                         setlimit
 2073              call emitinst(movem,reg(mpp1),0,adr,0,1); /* save it */               setlimit
 2074              acc(reg(mpp1)) = AVAIL;                                               setlimit
 2075           end;                                                                     setlimit
 2076        fixv (mp) = adr;                                                            setlimit
 2077   end setlimit;                                                                    setlimit
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 76
 line    source statement                                                               procedure and compiler information
 
 2078  stuff_parameter:                                                                 *
 2079     procedure;                                                                    *
 2080        /* generate code to send an actual parameter to a procedure */              stuff_parameter
 2081        declare (i,j) fixed;                                                        stuff_parameter
 2082        i = fixl (mp) + cnt (mp);  j = sytloc (i);                                  stuff_parameter
 2083        if length (syt(i)) = 0 then                                                 stuff_parameter
 2084           do;                                                                      stuff_parameter
 2085              sytco (i) = sytco (i) + 1;  /* count the reference                */  stuff_parameter
 2086                 do;                                                                stuff_parameter
 2087                    if sytype(i) = BYTETYPE then                                    stuff_parameter
 2088                      do;                                                           stuff_parameter
 2089                         call forceaccumulator(mpp1);                               stuff_parameter
 2090                         call emitinst (movei,12,0,j,0,sytseg(i));                  stuff_parameter
 2091                         call emitinst (dpb,reg(mpp1),0,byteptrs,0,1);              stuff_parameter
 2092                      end;                                                          stuff_parameter
 2093                    else                                                            stuff_parameter
 2094                      do;                                                           stuff_parameter
 2095                         if type(mpp1) = CONSTANT & fixv(mpp1) = 0 then             stuff_parameter
 2096                            do;                                                     stuff_parameter
 2097                               call emitinst (setzm,0,0,j,0,sytseg(i));             stuff_parameter
 2098                               return;                                              stuff_parameter
 2099                            end;                                                    stuff_parameter
 2100                         call forceaccumulator (mpp1);                              stuff_parameter
 2101                         call delete_move (mpp1,movem,reg(mpp1),0,j,0,sytseg(i));   stuff_parameter
 2102                      end;                                                          stuff_parameter
 2103                    acc(reg(mpp1)) = AVAIL;                                         stuff_parameter
 2104                 end;                                                               stuff_parameter
 2105           end;                                                                     stuff_parameter
 2106        else                                                                        stuff_parameter
 2107           call error ('too many actual parameters', 1);                            stuff_parameter
 2108  end stuff_parameter;                                                              stuff_parameter
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9702     data   2081       9
j               fixed      9703     data   2081       4
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 77
 line    source statement                                                               procedure and compiler information
 
 2109  divide_code:procedure(t);                                                        *
 2110     declare t fixed, i fixed;                                                      divide_code
 2111     /* emit code to perform a divide (t=1) or mod (t=0) */                         divide_code
 2112     /* find a free register pair for the dividend */                               divide_code
 2113     if type(mp) = ACCUMULATOR then                                                 divide_code
 2114        do;   /* we may be able to use the register to the right */                 divide_code
 2115           i = reg(mp);                                                             divide_code
 2116           if acc(i+1) = AVAIL then goto fits;                                      divide_code
 2117        end;                                                                        divide_code
 2118     do i = t to 11;                                                                divide_code
 2119        if acc(i) = AVAIL then if acc(i+1) = AVAIL then goto fit;                   divide_code
 2120     end;                                                                           divide_code
 2121     call error ('no free registers for division or mod.',0);                       divide_code
 2122     return;                                                                        divide_code
 2123  fit:                                                                              divide_code
 2124     target_register = i;                                                           divide_code
 2125     call forceaccumulator(mp);                                                     divide_code
 2126     target_register = -1;                                                          divide_code
 2127     if reg(mp) ~= i then                                                           divide_code
 2128        do;                                                                         divide_code
 2129           call emitinst (move,i,0,reg(mp),0,0);                                    divide_code
 2130           acc(reg(mp)) = AVAIL;                                                    divide_code
 2131           reg(mp) = i;                                                             divide_code
 2132        end;                                                                        divide_code
 2133        acc(i) = BUSY;                                                              divide_code
 2134   fits:                                                                            divide_code
 2135     acc(i+1) = BUSY;                                                               divide_code
 2136     call arithemit (idiv,0);                                                       divide_code
 2137     if t = 0 then                                                                  divide_code
 2138        do;  /* mod, switch register to point to remainder */                       divide_code
 2139           acc(i) = AVAIL;                /* free quotient */                       divide_code
 2140           reg(mp) = i+1;                 /* point to remainder */                  divide_code
 2141        end;                                                                        divide_code
 2142     else acc(i+1) = AVAIL;               /* free remainder */                      divide_code
 2143     if reg(mp) =12 then                                                            divide_code
 2144        do;  /* transfer the mod remainder from a scratch register */               divide_code
 2145           i = findar;                                                              divide_code
 2146           call emitinst (move,i,0,reg(mp),0,0);                                    divide_code
 2147           acc(reg(mp)) = AVAIL;                                                    divide_code
 2148           reg(mp) = i;                                                             divide_code
 2149        end;                                                                        divide_code
 2150  end divide_code;                                                                  divide_code
 
symbol table dump
 
symbol          type       loc   segment defined ref count
fit             label      5434  program   2119       1
fits            label      5465  program   2116       1
i               fixed      9712     data   2110      17
t               fixed      9711     data   2109       2
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 78
 line    source statement                                                               procedure and compiler information
 
 2151  shift_code:                                                                      *
 2152     procedure (op);                                                               *
 2153        declare op fixed;                                                           shift_code
 2154        /* generate code for the builtin functions shl and shr */                   shift_code
 2155        /* op: left = 0, right = 1 */                                               shift_code
 2156        sp = mpp1;                                                                  shift_code
 2157        if cnt (mp) ~= 2 then                                                       shift_code
 2158           call error ('shift requires two arguments', 0);                          shift_code
 2159        else                                                                        shift_code
 2160           if type (mpp1) = CONSTANT then                                           shift_code
 2161              do;                                                                   shift_code
 2162                 if op = 1 then fixv(mpp1) = -fixv(mpp1);                           shift_code
 2163                 call emitinst(lsh,reg(mp),0,fixv(mpp1),0,0);                       shift_code
 2164              end;                                                                  shift_code
 2165        else                                                                        shift_code
 2166           do;                                                                      shift_code
 2167              /* do shift with VARIABLE */                                          shift_code
 2168              call forceaccumulator(mpp1);                                          shift_code
 2169              if op = 1 then                                                        shift_code
 2170                    call emitinst (movn,reg(mpp1),0,reg(mpp1),0,0);                 shift_code
 2171              call emitinst (lsh,reg(mp),0,0,reg(mpp1),0);                          shift_code
 2172              acc(reg(mpp1)) = AVAIL;                                               shift_code
 2173           end;                                                                     shift_code
 2174        type(mp) = ACCUMULATOR;                                                     shift_code
 2175  end shift_code;                                                                   shift_code
 
symbol table dump
 
symbol          type       loc   segment defined ref count
op              fixed      9723     data   2152       2
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 79
 line    source statement                                                               procedure and compiler information
 
 2176  stringcompare:                                                                   *
 2177     procedure;                                                                    *
 2178        /* generates code to compare the strings at sp and mp.                      stringcompare
 2179           comparisons are done first on length, and second on a                    stringcompare
 2180           character by character comparison using the pdp-10 collating             stringcompare
 2181           sequence.                                                                stringcompare
 2182        */                                                                          stringcompare
 2183        call forcedescriptor (sp);                                                  stringcompare
 2184        call delete_move (sp,movem,reg(sp),0,b,0,3);                                stringcompare
 2185        acc(reg(sp)) = AVAIL;                                                       stringcompare
 2186        call forcedescriptor (mp);                                                  stringcompare
 2187        call delete_move (mp,movem,reg(mp),0,a,0,3);                                stringcompare
 2188        call save_acs (5);                                                          stringcompare
 2189        call emitinst (pushj,15,0,strcomp,0,2); /* call string compare */           stringcompare
 2190        call restore_acs (5);                                                       stringcompare
 2191        call emitinst (movei,reg(mp),0,1,0,0);                                      stringcompare
 2192         call emitinst (skip+inx(mpp1),0,0,0,0,0);                                  stringcompare
 2193        call emitinst (movei,reg(mp),0,0,0,0);                                      stringcompare
 2194        type(mp) = ACCUMULATOR;                                                     stringcompare
 2195        stillcond = inx(mpp1);                                                      stringcompare
 2196  end stringcompare;                                                                stringcompare
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 80
 line    source statement                                                               procedure and compiler information
 
 2197  symboldump:                                                                      *
 2198     procedure;                                                                    *
 2199        /* list the symbols in the procedure that has just been                     symboldump
 2200           compiled if toggle s is enabled and l is enabled.                        symboldump
 2201        */                                                                          symboldump
 2202        declare subtitle_save character;                                            symboldump
 2203        declare heading character initial ('type       loc   segment defined ref count'); symboldump
 2204        declare seg(4) character initial ('absolute','    data',' program',         symboldump
 2205                 '  string','   label');                                            symboldump
 2206        declare exchanges fixed, i fixed, lmax fixed,                               symboldump
 2207           j fixed, k fixed, l fixed, m fixed, sytsort (SYTSIZE) fixed;             symboldump
 2208        declare blanks character,                                                   symboldump
 2209                tag    character;                                                   symboldump
 2210                                                                                    symboldump
 2211     string_gt:                                                                     symboldump
 2212        procedure (a,b);                                                            symboldump
 2213           /* do an honest string comparison:                                       string_gt
 2214              xpl can be trusted only if strings are of the same length.            string_gt
 2215              if lengths differ, let xpl see only the shorter, and the              string_gt
 2216              matching part of the longer, and arrange comparisons so               string_gt
 2217              that result is right.   */                                            string_gt
 2218           declare a character,                                                     string_gt
 2219                   b character;                                                     string_gt
 2220           declare la fixed,  lb fixed;                                             string_gt
 2221                                                                                    string_gt
 2222           la = length (a);                                                         string_gt
 2223           lb = length (b);                                                         string_gt
 2224           if la = lb then return (a > b);                                          string_gt
 2225           else if la > lb then return (substr (a,0,lb) >= b);                      string_gt
 2226                else return (a > substr(b,0,la));                                   string_gt
 2227        end string_gt;                                                              string_gt
 
symbol table dump
 
symbol          type       loc   segment defined ref count
a               character   841   string   2212       4
b               character   842   string   2212       4
la              fixed     10180     data   2220       4
lb              fixed     10181     data   2220       4
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 81
 line    source statement                                                               procedure and compiler information
 
 2228                                                                                    symboldump
 2229        if control(byte('L'))  = 0 then return; /* don't dump if not listing */     symboldump
 2230        if procmark <= ndecsy then                                                  symboldump
 2231           do;                                                                      symboldump
 2232              call printline ('symbol table dump',0);                               symboldump
 2233              lmax = 15;                                                            symboldump
 2234              do i = procmark to ndecsy;  /* pad all names to the same length */    symboldump
 2235                 if length (syt (i)) > lmax then                                    symboldump
 2236                    lmax = length (syt (i));                                        symboldump
 2237                 sytsort (i) = i;                                                   symboldump
 2238              end;                                                                  symboldump
 2239              if lmax > 70 then lmax = 70;                                          symboldump
 2240              blanks = substr (x70,0,lmax);                                         symboldump
 2241              exchanges = TRUE;                                                     symboldump
 2242              k = ndecsy - procmark;                                                symboldump
 2243              do while exchanges;                                                   symboldump
 2244                 exchanges = FALSE;                                                 symboldump
 2245                 do j = 0 to k - 1;                                                 symboldump
 2246                    i = ndecsy - j;                                                 symboldump
 2247                    l = i - 1;                                                      symboldump
 2248                    if string_gt(syt (sytsort(l)),syt(sytsort(i))) then             symboldump
 2249                       do;                                                          symboldump
 2250                          m = sytsort (i);                                          symboldump
 2251                          sytsort (i) = sytsort (l);                                symboldump
 2252                          sytsort (l) = m;                                          symboldump
 2253                          exchanges = TRUE;                                         symboldump
 2254                          k = j;          /* record the last swap */                symboldump
 2255                       end;                                                         symboldump
 2256                  end;                                                              symboldump
 2257              end;                                                                  symboldump
 2258              i = procmark;                                                         symboldump
 2259              do while length (syt (sytsort (i))) = 0;                              symboldump
 2260                 i = i + 1;               /* ignore null names */                   symboldump
 2261              end;                                                                  symboldump
 2262              subtitle_save = subtitle;                                             symboldump
 2263              subtitle = 'symbol' || substr(blanks,0,lmax-5) || heading;            symboldump
 2264              call printline (subtitle,0);                                          symboldump
 2265              do i = i to ndecsy;                                                   symboldump
 2266                 k = sytsort (i);                                                   symboldump
 2267                 tag = syt(k) || substr(x70,0,lmax-length(syt(k)));                 symboldump
 2268                 call i_format (sytloc(k),5);                                       symboldump
 2269                 tag = tag || x1 || typename(sytype(k)) || x1 || i_string;          symboldump
 2270                 call i_format (sytcard(k),5);                                      symboldump
 2271                 tag = tag || x1 || seg(sytseg(k)) || x2 || i_string;               symboldump
 2272                 call i_format (sytco(k),5);                                        symboldump
 2273                 if sytco(k) = 0 then i_string = i_string || ' *';                  symboldump
 2274                 call printline (tag || x3 || i_string,-1);                         symboldump
 2275                                                                                    symboldump
 2276                 k = k + 1;                                                         symboldump
 2277                 do while (length (syt (k)) = 0) & (k <= ndecsy);                   symboldump
 2278                    j = k - sytsort (i);                                            symboldump
 2279                    tag = '  parameter  ' || j || substr(blanks,13) ||              symboldump
 2280                          typename(sytype(k));                                      symboldump c19 = 1744830451
 2281                    call i_format (sytloc(k),5);                                    symboldump
 2282                    tag = tag || x1 || i_string;                                    symboldump
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 82
 line    source statement                                                               procedure and compiler information
 
 2283                    call i_format (sytcard(k),5);                                   symboldump
 2284                    tag = tag || x1 || seg(sytseg(k)) || x2 || i_string;            symboldump
 2285                    call i_format (sytco(k),5);                                     symboldump
 2286                    call printline (tag || x3 || i_string,-1);                      symboldump
 2287                    k = k + 1;                                                      symboldump
 2288                 end;                                                               symboldump
 2289              end;                                                                  symboldump
 2290              subtitle = subtitle_save;                                             symboldump
 2291           end;                                                                     symboldump
 2292           EJECT_PAGE;                                                              symboldump
 2293  end symboldump;                                                                   symboldump
 
symbol table dump
 
symbol          type       loc   segment defined ref count
blanks          character   839   string   2208       3
exchanges       fixed      9752     data   2206       4
heading         character   833   string   2203       1
i               fixed      9753     data   2206      18
j               fixed      9755     data   2207       5
k               fixed      9756     data   2207      24
l               fixed      9757     data   2207       4
lmax            fixed      9754     data   2206       8
m               fixed      9758     data   2207       2
seg             character   834   string   2204       2
string_gt       procedure  5679  program   2211       1
  parameter  1  character   841   string   2212       5
  parameter  2  character   842   string   2212       5
subtitle_save   character   832   string   2202       2
sytsort         fixed      9759     data   2207      10
tag             character   840   string   2209      12
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 83
 line    source statement                                                               procedure and compiler information
 
 2294  dumpit:                                                                          *
 2295     procedure;                                                                    *
 2296        declare char360 character;                                                  dumpit
 2297        declare t1 character, t2 character, l fixed, ll fixed;                      dumpit
 2298        /* put out statistics kept within the compiler */                           dumpit
 2299       if top_macro >= 0 then                                                       dumpit
 2300            do; /* dump macro dictionary */                                         dumpit
 2301               call printline ( 'macro definitions:',0);                            dumpit
 2302               call printline (x1,-1);                                              dumpit
 2303               l = length (macro_name(top_macro));                                  dumpit
 2304               if l > 70 then l = 70;                                               dumpit
 2305               subtitle = 'name' || substr (x70,0,l-2) ||                           dumpit
 2306                          'at line ref count literal value';                        dumpit
 2307               call printline (subtitle,-1);                                        dumpit
 2308               do i = 0 to top_macro;                                               dumpit
 2309                  k = length (macro_name(i));                                       dumpit
 2310                  if k < l then                                                     dumpit
 2311                     do;                                                            dumpit
 2312                         char360 = substr (x70,0,l-k);                              dumpit
 2313                         macro_name (i) = macro_name (i) || char360;                dumpit
 2314                     end;                                                           dumpit
 2315                  else                                                              dumpit
 2316                     macro_name(i) = substr(macro_name(i),0,l);                     dumpit
 2317                  t1 = macro_declare(i);                                            dumpit
 2318                  t2 = macro_count(i);                                              dumpit
 2319                  ll = length (t1);                                                 dumpit
 2320                  if ll < 8 then t1 = substr(x70,0,8-ll) || t1;                     dumpit
 2321                  ll = length (t2);                                                 dumpit
 2322                  if ll < 9 then t2 = substr(x70,0,9-ll) || t2;                     dumpit
 2323                  call printline (macro_name(i) || t1 || t2 || x4 || macro_text(i),-1); dumpit
 2324               end;                                                                 dumpit
 2325            end;                                                                    dumpit
 2326        subtitle = '';                                                              dumpit
 2327        call printline (x1,-1);                                                     dumpit
 2328        call printline ('id compares       = ' || idcompares,-1);                   dumpit
 2329        call printline ('symbol table size = ' || maxndecsy,-1);                    dumpit
 2330        call printline ('macro definitions = ' || top_macro + 1,-1);                dumpit
 2331        call printline ('scan              = ' || count_scan,-1);                   dumpit
 2332        call printline ('emitinst          = ' || count_inst,-1);                   dumpit
 2333        call printline ('force ACCUMULATOR = ' || count_force,-1);                  dumpit
 2334        call printline ('arithemit         = ' || count_arith,-1);                  dumpit
 2335        call printline ('generate store    = ' || count_store,-1);                  dumpit
 2336        call printline ('free string area  = ' || freelimit - freebase,-1);         dumpit
 2337        call printline ('compactifications = ' || count_compact,-1);                dumpit
 2338        subtitle = 'instruction frequencies';                                       dumpit
 2339        EJECT_PAGE;                                                                 dumpit
 2340        do i = 0 to 15;                                                             dumpit
 2341           j = i * 32;                                                              dumpit c20 = 15
 2342           do k = 0 to 31;                                                          dumpit
 2343              if instruct(j+k) > 0 then                                             dumpit c21 = 31
 2344                  call printline (substr(opname(i),k*6,6) || x4 || instruct(j+k),-1); dumpit
 2345           end;                                                                     dumpit
 2346        end;                                                                        dumpit
 2347  end dumpit;                                                                       dumpit
 
symbol table dump
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 84
symbol          type       loc   segment defined ref count
 
 
symbol          type       loc   segment defined ref count
char360         character   847   string   2296       2
l               fixed     10197     data   2297       7
ll              fixed     10198     data   2297       6
t1              character   848   string   2297       5
t2              character   849   string   2297       5
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 85
 line    source statement                                                               procedure and compiler information
 
 2348     initialize:                                                                   *
 2349        procedure;                                                                 *
 2350        declare ch character;                                                       initialize
 2351        declare time1 fixed, hours fixed, minutes fixed, secs fixed;                initialize
 2352        declare date1 fixed, day fixed, year fixed, l fixed;                        initialize
 2353        declare month character;                                                    initialize
 2354        declare months (11)character initial ('-jan-',                              initialize
 2355              '-feb-','-mar-','-apr-','-may-','-jun-','-jul-','-aug-',              initialize
 2356              '-sep-','-oct-','-nov-','-dec-');                                     initialize
 2357        output(-2) = 'filename to be compiled: ';                                   initialize
 2358        char_temp = input(-1);                                                      initialize
 2359        source = '';                                                                initialize
 2360        control(byte('A')) = FALSE;                                                 initialize
 2361        control(byte('D')) = TRUE;                                                  initialize
 2362        control(byte('S')) = TRUE;                                                  initialize
 2363        do i = 0 to length(char_temp)-1;                                            initialize
 2364           ch =  substr(char_temp,i,1);                                             initialize
 2365           if byte(ch) = byte('/') then                                             initialize
 2366              do;                                                                   initialize
 2367                 ch = substr(char_temp,i+1,1);                                      initialize
 2368                 control(byte(ch)) = ~ control(byte(ch));                           initialize
 2369                 i = i + 1;                                                         initialize
 2370              end;                                                                  initialize
 2371           else                                                                     initialize
 2372              source = source || ch;                                                initialize
 2373           end;                                                                     initialize
 2374        filename (0) = 'sysin:' || source || '.xpl';                                initialize
 2375        filename (1) = 'sysout:' || source || '.lst';                               initialize
 2376        if control(byte('A')) then                                                  initialize
 2377           do;                                                                      initialize
 2378              filename (DATAFILE) = source || '.mac';                               initialize
 2379              filename(CODEFILE) = source || '.tmp';                                initialize
 2380           end;                                                                     initialize
 2381        filename(RELFILE) = source || '.rel';                                       initialize
 2382        time1 = (time+500)/ 1000;                                                   initialize
 2383        hours = time1 /3600;                                                        initialize
 2384        minutes = (time1 mod 3600) / 60;                                            initialize
 2385        secs = time1 mod 60;                                                        initialize
 2386        date1 = date;                                                               initialize
 2387        day = date1 mod 31 + 1;                                                     initialize
 2388        date1 = date1 / 31;                                                         initialize
 2389        month = months(date1 mod 12);                                               initialize
 2390        year = date1 / 12 + 1964;                                                   initialize
 2391        title = '1' || source || '.xpl  compiled ' || day || month ||               initialize
 2392               year || '  at ' ||hours || ':' || minutes || ':' || secs             initialize
 2393               || ' by VERSION ' || VERSION;                                        initialize
 2394        l = length (title);                                                         initialize
 2395        title = title || substr(x70,0,90-l) || 'page ';                             initialize
 2396        subtitle = ' line    source statement' || substr(x70,7)                     initialize
 2397              || 'procedure and compiler information';                              initialize c22 = 939524089
 2398        page_count = 0;                                                             initialize
 2399        line_count = 99;                                                            initialize
 2400        do i = 1 to TERMINAL#;                                                      initialize
 2401           s = vocab(i);                                                            initialize
 2402           if s = '<number>' then number = i;  else                                 initialize
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 86
 line    source statement                                                               procedure and compiler information
 
 2403           if s = '<identifier>' then ident = i;  else                              initialize
 2404           if s = '<string>' then string = i;  else                                 initialize
 2405           if s = '/' then divide = i;  else                                        initialize
 2406           if s = 'eof' then eofile = i;  else                                      initialize
 2407           if s = 'declare' then stopit(i) = TRUE;  else                            initialize
 2408           if s = 'procedure' then stopit(i) = TRUE;  else                          initialize
 2409           if s = 'end' then stopit(i) = TRUE;  else                                initialize
 2410           if s = 'do' then stopit(i) = TRUE;  else                                 initialize
 2411           if s = ';' then stopit(i) = TRUE;  else                                  initialize
 2412           if s = '|' then orsymbol = i; else                                       initialize
 2413           if s = '||' then concatenate = i;                                        initialize
 2414        end;                                                                        initialize
 2415        if ident = TERMINAL# then reserved_limit = length(vocab(TERMINAL#-1));      initialize
 2416        else reserved_limit = length(vocab(TERMINAL#));                             initialize
 2417        stopit(eofile) = TRUE;                                                      initialize
 2418     do i = TERMINAL# to  VOCAB#;                                                   initialize
 2419        s = vocab(i);                                                               initialize c23 = 91
 2420        if s = '<label definition>' then labelset = i;                              initialize
 2421     end;                                                                           initialize
 2422        chartype (byte(' ')) = 1;                                                   initialize
 2423        chartype (byte('''')) = 2;                                                  initialize
 2424        chartype (byte('"')) = 3;                                                   initialize
 2425        do i = 0 to 255;                                                            initialize
 2426           not_letter_or_digit(i) = TRUE;                                           initialize c24 = 255
 2427        end;                                                                        initialize
 2428        do i = 0 to 29;                                                             initialize
 2429           j = byte('abcdefghijklmnopqrstuvwxyz_$@#', i);                           initialize c25 = 29
 2430           not_letter_or_digit(j) = FALSE;                                          initialize
 2431           chartype(j) = 4;                                                         initialize
 2432        end;                                                                        initialize
 2433        do i = 0 to 9;                                                              initialize
 2434           j = byte('0123456789', i);                                               initialize c26 = 9
 2435           not_letter_or_digit(j) = FALSE;                                          initialize
 2436           chartype(j) = 5;                                                         initialize
 2437         end;                                                                       initialize
 2438        i = 1;                                                                      initialize
 2439        do while (length(vocab(i))= 1);                                             initialize
 2440           j = byte(vocab(i));                                                      initialize
 2441           tx(j) = i;                                                               initialize
 2442           chartype(j) = 7;                                                         initialize
 2443           i = i + 1;                                                               initialize
 2444        end;                                                                        initialize
 2445        chartype(byte('|')) = 8;                                                    initialize
 2446        chartype (byte('/')) = 6;                                                   initialize
 2447        pp = 0;            /* program origin */                                     initialize
 2448        dp = 0;            /* data origin */                                        initialize
 2449        dpoffset = 0;                                                               initialize
 2450        dsp = 0;           /* descriptor origin */                                  initialize
 2451        returned_type = FIXEDTYPE;     /* initial default type */                   initialize
 2452        top_macro = -1;                                                             initialize
 2453        target_register = -1;                                                       initialize
 2454                                                                                    initialize
 2455        codemsg = x70 || codemsg;                                                   initialize
 2456        datamsg = x70 || datamsg;                                                   initialize
 2457        backmsg = x70 || backmsg;                                                   initialize
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 87
 line    source statement                                                               procedure and compiler information
 
 2458                                                                                    initialize
 2459  /*    initialize the symbol table and its hash table */                           initialize
 2460        procmark = 25; ndecsy = 27; parct = 0;                                      initialize
 2461        do i = 0 to SYTSIZE;                                                        initialize
 2462           ptr (i) = -1;                                                            initialize c27 = 420
 2463        end;                                                                        initialize
 2464        do i = 0 to "ff";                                                           initialize
 2465           hash (i) = -1;                                                           initialize
 2466        end;                                                                        initialize
 2467        do i = 0 to ndecsy;                                                         initialize
 2468           idx = hasher (syt(i));                                                   initialize
 2469           ptr (i) = hash (idx);                                                    initialize
 2470           hash (idx) = i;                                                          initialize
 2471        end;                                                                        initialize
 2472        rptr, dptr, dloc,for_count, label_count = 0;                                initialize
 2473        rctr, dctr = 1;                                                             initialize
 2474                                                                                    initialize
 2475        file(RELFILE) = NAME_TYPE + 2;                                              initialize
 2476        file(RELFILE) = 0;                                                          initialize c28 = 1572864
 2477        file(RELFILE) = radix50(source);                                            initialize
 2478        file(RELFILE) = "(3)17000000" + 0;                                          initialize
 2479        file(RELFILE) = HISEG_TYPE + 1;                                             initialize c29 = 3932160
 2480        file(RELFILE) = "(3)200000000000" ;                                         initialize c30 = 786432
 2481        file(RELFILE) = "(3)400000400000";                                          initialize
 2482                                                                                    initialize c31 = -34359607296
 2483        code_head, code_tail = 0;                                                   initialize
 2484        code_full(0) = FALSE;                                                       initialize
 2485        if control(byte('A')) then                                                  initialize
 2486           do;                                                                      initialize
 2487              label_gen = 'p:';                /* org the code segment */           initialize
 2488              output (DATAFILE) = '       title ' || source ;                       initialize
 2489              output (DATAFILE) = '       twoseg 400000;';                          initialize
 2490              output (DATAFILE) = '       reloc 0;';                                initialize
 2491              output (DATAFILE) = '       radix 10;';                               initialize
 2492              output (CODEFILE) = '       reloc |o400000;';                         initialize
 2493              output (DATAFILE) = '       opdef   .init. [1b8];';                   initialize
 2494              output (DATAFILE) = '       opdef   .inpt. [2b8];';                   initialize
 2495              output (DATAFILE) = '       opdef   .outp. [3b8];';                   initialize
 2496              output (DATAFILE) = '       opdef   .exit. [4b8];';                   initialize
 2497              output (DATAFILE) = '       opdef   .fili. [6b8];';                   initialize
 2498              output (DATAFILE) = '       opdef   .filo. [7b8];';                   initialize
 2499              output (DATAFILE) = '       opdef   .name. [8b8];';                   initialize
 2500              output (DATAFILE) = 'd:';                                             initialize
 2501           end;                                                                     initialize
 2502        byteptrs = dp;                                                              initialize
 2503        call emitdataword ("(3)331114000000"); /*   point 9,0(12),8 */              initialize
 2504        call emitdataword ("(3)221114000000"); /*   point 9,0(12),17 */             initialize c32 = 29145169920
 2505        call emitdataword ("(3)111114000000"); /*   point 9,0(12),26 */             initialize c33 = 19481493504
 2506        call emitdataword ("(3)001114000000"); /*   point 9,0(12),35 */             initialize c34 = 9817817088
 2507        psbits = dp;                                                                initialize c35 = 154140672
 2508        call emitdataword ("(3)331100000000"); /*   point 9,0,8  */                 initialize
 2509        call emitdataword ("(3)221100000000"); /*   point 9,0,17 */                 initialize c36 = 29142024192
 2510        call emitdataword ("(3)111100000000"); /*   point 9,0,26 */                 initialize c37 = 19478347776
 2511        call emitdataword ("(3)001100000000"); /*   point 9,0,35 */                 initialize c38 = 9814671360
 2512        call emitconstant (1);            /* enter a 1 */                           initialize c39 = 150994944
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 88
 line    source statement                                                               procedure and compiler information
 
 2513        trueloc = adr;                    /* save its address */                    initialize
 2514        call emitconstant (0);            /* enter a 0 */                           initialize
 2515        falseloc = adr;                   /* save its address */                    initialize
 2516        tsa = dp; sytloc(2) = dp;         /* freepoint */                           initialize
 2517        call emitdataword (0);                                                      initialize
 2518        ndesc, sytloc(4) = findlabel;     /* ndescript */                           initialize
 2519        corebyteloc = 1;                  /* syt location of corebyte */            initialize
 2520        string_recover = 25;              /* syt location of compactify */          initialize
 2521        sytloc(25) = findlabel;           /* label for compactify */                initialize
 2522        limitword = dp; sytloc(26) = dp;  /* freelimit */                           initialize
 2523        call emitdataword (0);                                                      initialize
 2524        str = dsp;                        /* place to save last string generated */ initialize
 2525        call emitdesc (0,0);                                                        initialize
 2526        library_save = dp;                /* place to save r11 on lib calls */      initialize
 2527        call emitdataword (0);                                                      initialize
 2528        library = dp;                     /* address of library goes here */        initialize
 2529        if control(byte('A')) then                                                  initialize
 2530           do;                                                                      initialize
 2531              output (DATAFILE) = '       xpllib;';                                 initialize
 2532              output (DATAFILE) = '       extern xpllib;';                          initialize
 2533           end;                                                                     initialize
 2534        dp = dp + 1;                                                                initialize
 2535        call emitconstant ("fffff");      /* mask for addresses only  */            initialize
 2536        addrmask = adr;                   /* save it                  */            initialize
 2537        call emitconstant(-134217728);  /* dv length field */                       initialize
 2538        lengthmask = adr;                                                           initialize
 2539                                                                                    initialize
 2540  /* check-string-overflow  see if compactify needs to be called */                 initialize
 2541                                                                                    initialize
 2542        call emitblock (15);                                                        initialize
 2543        i = dp - 15;                                                                initialize
 2544        string_check = pp;                                                          initialize
 2545        call emitinst (move,0,0,tsa,0,1); /* pick up top of strings */              initialize
 2546        call emitinst (camge,0,0,limitword,0,1); /* compare with limit word */      initialize
 2547        call emitinst (popj,15,0,0,0,0);                                            initialize
 2548        call emitinst (movei,0,0,i,0,1);                                            initialize
 2549        call emitinst (hrli,0,0,1,0,0);                                             initialize
 2550        call emitinst (blt,0,0,i+14,0,1);                                           initialize
 2551        call emitinst (pushj,15,0,sytloc(string_recover),0,sytseg(string_recover)); initialize
 2552        call emitinst (movei,0,0,1,0,0);                                            initialize
 2553        call emitinst (hrli,0,0,i,0,1);                                             initialize
 2554        call emitinst (blt,0,0,14,0,0);                                             initialize
 2555        call emitinst (popj,15,0,0,0,0);                                            initialize
 2556        sytco (string_recover) = sytco (string_recover) + 1;                        initialize
 2557                                                                                    initialize
 2558   /* string comparison */                                                          initialize
 2559                                                                                    initialize
 2560        a = dsp;                                                                    initialize
 2561        call emitdesc (0,0);                                                        initialize
 2562        b = dsp;                                                                    initialize
 2563        call emitdesc (0,0);                                                        initialize
 2564        strcomp = pp;                                                               initialize
 2565        call emitinst (move,0,0,a,0,3);   /* fetch left descriptor */               initialize
 2566        call emitinst (lsh,0,0,    -27,0,0);                                        initialize
 2567        call emitinst (move,1,0,b,0,3);    /* fetch right descriptor */             initialize
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 89
 line    source statement                                                               procedure and compiler information
 
 2568        call emitinst (lsh,1,0,    -27,0,0);                                        initialize
 2569        call emitinst (sub,0,0,1,0,0);    /* subtract the lengths */                initialize
 2570        call emitinst (jumpe,0,0,pp+2,0,2);                                         initialize
 2571        call emitinst (popj,15,0,0,0,0);   /* return w/ -, 0, or + if length ~= */  initialize
 2572        call emitinst (movei,2,0,0,0,0);  /* clear a length register */             initialize
 2573        call emitinst (move,3,0,a,0,3);                                             initialize
 2574        call emitinst (subi,3,0,1,0,0);                                             initialize
 2575        call emitinst (lshc,2,0,  9,0,0); /* isolate the length */                  initialize
 2576        call emitinst (lshc,3,0,-11,0,0); /* isolate byte index in r4 */            initialize
 2577        call emitinst (lsh,4,0,    -34,0,0);                                        initialize
 2578        call emitinst (hll,3,0,psbits,4,1); /* build byte ptr in r3 */              initialize
 2579        call emitinst (move,4,0,b,0,3);                                             initialize
 2580        call emitinst (subi,4,0,1,0,0);                                             initialize
 2581        call emitinst (lshc,4,0,    -2,0,0);                                        initialize
 2582        call emitinst (lsh,5,0,    -34,0,0);                                        initialize
 2583        call emitinst (hll,4,0,psbits,5,1); /* build byte ptr in r4 */              initialize
 2584                                                                                    initialize
 2585        /* one character goes into r0 while the other goes into r1.  length is      initialize
 2586           controlled in r2 and the byte ptrs are in r3 & r4 for speed.             initialize
 2587        */                                                                          initialize
 2588        call emitinst (ildb,0,0,3,0,0);   /* fetch 1st byte */                      initialize
 2589        call emitinst (ildb,1,0,4,0,0);   /* fetch 2nd byte */                      initialize
 2590        call emitinst (camn,0,0,1,0,0);   /* skip if ~= */                          initialize
 2591        call emitinst (sojg,2,0,pp-3,0,2);/* loop for all bytes */                  initialize
 2592        call emitinst (sub,0,0,1,0,0);    /* sub diff bytes or last two equal */    initialize
 2593        call emitinst (popj,15,0,0,0,0);                                            initialize
 2594                                                                                    initialize
 2595   /* move character subroutine */                                                  initialize
 2596                                                                                    initialize
 2597        mover = pp;                                                                 initialize
 2598        /* uses registers 1, 2, 11, 12, & 13 */                                     initialize
 2599        call emitinst (subi,12,0,1,0,0);  /* decr addr of source */                 initialize
 2600        call emitinst (movei,11,0,0,0,0); /* clear length reg */                    initialize
 2601        call emitinst (lshc,11,0,  9,0,0);/* isolate length */                      initialize
 2602        call emitinst (lshc,12,0,-11,0,0);/* isolate byte index */                  initialize
 2603        call emitinst (lsh,13,0,    -34,0,0);                                       initialize
 2604        call emitinst (hll,12,0,psbits,13,1); /* make from byteptr */               initialize
 2605        call emitinst (move,13,0,11,0,0); /* copy length */                         initialize
 2606        call emitinst (add,13,0,1,0,0);   /* create new tsa */                      initialize
 2607        call emitinst (subi,1,0,1,0,0);   /* decr to addr */                        initialize
 2608        call emitinst (lshc,1,0,    -2,0,0); /* isolate byte index */               initialize
 2609        call emitinst (lsh,2,0,    -34,0,0);                                        initialize
 2610        call emitinst (hll,1,0,psbits,2,1);  /* to byteptr */                       initialize
 2611                                                                                    initialize
 2612        /* character goes into r2, length is in r11, and the new tsa is in r13.     initialize
 2613           byteptrs are in r1 & r12 for speed.                                      initialize
 2614        */                                                                          initialize
 2615        call emitinst (ildb,2,0,12,0,0);  /* fetch a byte */                        initialize
 2616        call emitinst (idpb,2,0,1,0,0);   /* store a byte */                        initialize
 2617        call emitinst (sojg,11,0,pp-2,0,2);  /* loop for all bytes */               initialize
 2618        call emitinst (move,1,0,13,0,0);  /* return with new tsa */                 initialize
 2619        call emitinst (popj,15,0,0,0,0);                                            initialize
 2620                                                                                    initialize
 2621   /* catenation subroutine */                                                      initialize
 2622                                                                                    initialize
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 90
 line    source statement                                                               procedure and compiler information
 
 2623        catentry = pp;                                                              initialize
 2624        call check_string_overflow;       /* squeeze core if necessary */           initialize
 2625        call emitinst (move,0,0,b,0,3);   /* see if length (b) = 0 */               initialize
 2626        call emitinst (and,0,0,lengthmask,0,1);                                     initialize
 2627        call emitinst (jumpn,0,0,pp+3,0,2);                                         initialize
 2628        call emitinst (move,0,0,a,0,3);   /* yes, return with a */                  initialize
 2629        call emitinst (popj,15,0,0,0,0);                                            initialize
 2630        call emitinst (move,1,0,a,0,3);   /* see if length(a) = 0 */                initialize
 2631        call emitinst (and,1,0,lengthmask,0,1);                                     initialize
 2632        call emitinst (jumpn,1,0,pp+3,0,2);                                         initialize
 2633        call emitinst (move,0,0,b,0,3);   /* yes, return with b */                  initialize
 2634        call emitinst (popj,15,0,0,0,0);                                            initialize
 2635                                                                                    initialize
 2636        /*  we have to construct a new string.  check to see if string 'a'          initialize
 2637          is adjacent to the first available byte.  if it is, we need               initialize
 2638          only actually move string 'b' and dummy up a new descriptor.  */          initialize
 2639                                                                                    initialize
 2640        call emitinst (rot,1,0,9,0,0);     /* put l(a) in low end */                initialize
 2641        call emitinst (add,1,0,a,0,3);     /* add a desc. */                        initialize
 2642        call emitinst (and,1,0,addrmask,0,1); /* keep only byte address */          initialize
 2643        call emitinst (add,0,0,a,0,3);     /* add l(b) to desc. a */                initialize
 2644        call emitinst (move,12,0,b,0,3);     /* ge desc. b */                       initialize
 2645        call emitinst (and,12,0,addrmask,0,1);/* keep byte address */               initialize
 2646        call emitinst (camn,12,0,1,0,0);    /* is this same as end(a)+1? */         initialize
 2647        call emitinst (jrst,0,0,pp+11,0,2);  /*yes. then done */                    initialize
 2648        call emitinst (caml,1,0,tsa,0,1);  /* is 'a' last string ? */               initialize
 2649        call emitinst (jrst,0,0,pp+6,0,2); /* yes. jump to just move b */           initialize
 2650        call emitinst (and,0,0,lengthmask,0,1); /* no. make new desc. */            initialize
 2651        call emitinst (ior,0,0,tsa,0,1);  /* new dope vector */                     initialize
 2652        call emitinst (move,1,0,tsa,0,1); /* target of move */                      initialize
 2653        call emitinst (move,12,0,a,0,3);  /* source of move & length */             initialize
 2654        call emitinst (pushj,15,0,mover,0,2);   /* call move subroutine */          initialize
 2655        call emitinst (move,12,0,b,0,3);  /* source of move */                      initialize
 2656        call emitinst (pushj,15,0,mover,0,2);   /* call move subroutine*/           initialize
 2657        call emitinst (movem,1,0,tsa,0,1);/* save new tsa */                        initialize
 2658        call emitinst (movem,0,0,str,0,3);  /* save last string descriptor */       initialize
 2659        call emitinst (popj,15,0,0,0,0);                                            initialize
 2660                                                                                    initialize
 2661   /* number to string conversion */                                                initialize
 2662                                                                                    initialize
 2663        nmbrentry = pp;                                                             initialize
 2664        /* uses registers 0,1,12,13 */                                              initialize
 2665                                                                                    initialize
 2666        call emitblock (1);                                                         initialize
 2667        c = dp - 1;                                                                 initialize
 2668        call check_string_overflow;                                                 initialize
 2669        call emitinst (move,12,0,tsa,0,1);   /* get loc'n first free byte*/         initialize
 2670        call emitinst (subi,12,0,1,0,0);    /* adjust for idbp */                   initialize
 2671        call emitinst (movei,13,0,0,0,0);    /* clear 13 for shift */               initialize
 2672        call emitinst (lshc,12,0,-2,0,0);    /* word address to 12 */               initialize
 2673        call emitinst (rot,13,0,2,0,0);      /* displ. to 13 */                     initialize
 2674        call emitinst (hll,12,0,psbits,13,1);/* make byte pointer in 12 */          initialize
 2675        call emitinst (move,0,0,c,0,1);      /* load number to be converted */      initialize
 2676        call emitinst (movei,13,0,0,0,0);    /* clear count of bytes */             initialize
 2677        call emitinst (jumpge,0,0,pp+5,0,2); /* jump around sign if >= 0 */         initialize
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 91
 line    source statement                                                               procedure and compiler information
 
 2678        call emitinst (movei,1,0,byte('-'),0,0);/* put - into reg. */               initialize
 2679        call emitinst (idpb,1,0,12,0,0);     /* put byte away */                    initialize
 2680        call emitinst (movei,13,0,1,0,0);    /* set byte count to 1 */              initialize
 2681        call emitinst (movm,0,0,0,0,0);      /* make number positive */             initialize
 2682        call emitinst (pushj,15,0,pp+8,0,2); /* generate byte string */             initialize
 2683        call emitinst (rot,13,0,-9,0,0);     /* put byte count in length */         initialize
 2684        call emitinst (move,0,0,tsa,0,1);    /* pick starting address of string */  initialize
 2685        call emitinst (add,0,0,13,0,0);      /* add length to make desc. */         initialize
 2686        call emitinst (rot,13,0,9,0,0);      /* put count back */                   initialize
 2687        call emitinst (addm,13,0,tsa,0,1);   /* adjust tsa for next time */         initialize
 2688        call emitinst (movem,0,0,str,0,3);   /* save new descriptor */              initialize
 2689        call emitinst (popj,15,0,0,0,0);     /* return */                           initialize
 2690                                                                                    initialize
 2691        /* subroutine to convert number to char string by repetitive                initialize
 2692           division.  puts out digits from high-to-low order. */                    initialize
 2693                                                                                    initialize
 2694        call emitinst (idivi,0,0,10,0,0);    /* quotient to 0, remainder to 1 */    initialize
 2695        call emitinst (hrlm,1,0,0,15,0);     /* save remainder on stack */          initialize
 2696        call emitinst (jumpe,0,0,pp+2,0,2);  /* if quotient = 0, all digits */      initialize
 2697        call emitinst (pushj,15,0,pp-3,0,2); /* loop back for next digit */         initialize
 2698        call emitinst (hlrz,1,0,0,15,0);     /* retrieve digit from stack */        initialize
 2699        call emitinst (addi,1,0,byte('0'),0,0); /* convert to ascii character */    initialize
 2700        call emitinst (idpb,1,0,12,0,0);     /* stuff byte out */                   initialize
 2701        call emitinst (addi,13,0,1,0,0);     /* increment byte counter */           initialize
 2702        call emitinst (popj,15,0,0,0,0);     /* return (for more or to caller */    initialize
 2703                                                                                    initialize
 2704     /* the compiled program will begin execution here.  make the first jump        initialize
 2705        point here, initialize the library, and fall into compile code.             initialize
 2706     */                                                                             initialize
 2707                                                                                    initialize
 2708        startloc = pp;                      /* start location */                    initialize
 2709        call emitlabel (0,4);               /* org program here */                  initialize
 2710        /* initialize library routine, freebase, freelimit, & freepoint */          initialize
 2711        call emitinst (jump,0,0,0,0,0);   /* patch nop */                           initialize
 2712        call emitinst (1,0,0,0,0,0);      /* init lib code */                       initialize
 2713        call emitinst (movem,12,0,tsa,0,1); /* save as freepoint */                 initialize
 2714        call emitinst (movem,12,0,dp,0,1); /* save as freebase */                   initialize
 2715        sytloc (27) = dp;                                                           initialize
 2716        call emitdataword (0);                                                      initialize
 2717        call emitinst (subi,13,0,256,0,0);                                          initialize
 2718        call emitinst (movem,13,0,limitword,0,1); /* save as freelimit */           initialize
 2719        /* routine to relocate string descriptors */                                initialize
 2720        call emitinst (movei,12,0,0,0,1); /* get address of data segment */         initialize
 2721        call emitinst (lsh,12,0,  2,0,0);    /* multiply by 4 for byte address*/    initialize
 2722        call emitinst (move,13,0,ndesc,0,5);   /* get # descriptors as index */     initialize
 2723        call emitinst (skipe,0,0,0,13,3); /* don't change null desc.s */            initialize
 2724        call emitinst (addm,12,0,0,13,3); /* add reloc to a descriptor */           initialize
 2725        call emitinst (sojg,13,0,pp-2,0,2);    /* loop thru all descriptors */      initialize
 2726        cp = 0;  text = '';  text_limit = -1;                                       initialize
 2727        compiling = TRUE;                                                           initialize
 2728        reading = control(byte('X'));                                               initialize
 2729        if reading then                                                             initialize
 2730            control(byte('L')) = ~ (control(byte('K')) | control(byte('M'))) & 1;   initialize
 2731        filename(LIBFILE) = 'lib:xpl.lib';                                          initialize
 2732        current_procedure = '*';                                                    initialize
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 92
 line    source statement                                                               procedure and compiler information
 
 2733        call scan;                                                                  initialize
 2734        no_look_ahead_done = FALSE;                                                 initialize
 2735     end initialize;                                                                initialize
 
symbol table dump
 
symbol          type       loc   segment defined ref count
ch              character   864   string   2350       6
date1           fixed     10276     data   2352       6
day             fixed     10277     data   2352       2
hours           fixed     10273     data   2351       2
l               fixed     10279     data   2352       2
minutes         fixed     10274     data   2351       2
month           character   865   string   2353       2
months          character   866   string   2354       1
secs            fixed     10275     data   2351       2
time1           fixed     10272     data   2351       4
year            fixed     10278     data   2352       2
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 93
 line    source statement                                                               procedure and compiler information
 
 2736  stack_dump:                                                                      *
 2737     procedure;                                                                    *
 2738        declare line character;                                                     stack_dump
 2739        if ~ control(byte('R')) then return;  /* 'r' is barf switch */              stack_dump
 2740        line = 'partial parse to this point is: ';                                  stack_dump
 2741        do i = 0 to sp;                                                             stack_dump
 2742           if length(line) > 105 then                                               stack_dump
 2743              do;                                                                   stack_dump
 2744                 call printline (line,-1);                                          stack_dump
 2745                 line = x4;                                                         stack_dump
 2746              end;                                                                  stack_dump
 2747           line = line || x1 || vocab(state_name(state_stack(i)));                  stack_dump
 2748        end;                                                                        stack_dump
 2749        call printline (line,-1);                                                   stack_dump
 2750     end stack_dump;                                                                stack_dump
 
symbol table dump
 
symbol          type       loc   segment defined ref count
line            character   929   string   2738       7
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 94
 line    source statement                                                               procedure and compiler information
 
 2751                                                                                   *
 2752    /*                  the synthesis algorithm for xpl                      */    *
 2753                                                                                   *
 2754                                                                                   *
 2755  synthesize:                                                                      *
 2756  procedure(production_number);                                                    *
 2757     declare production_number fixed;                                               synthesize
 2758     declare toomsg character initial ('too many arguments for ');                  synthesize
 2759                                                                                    synthesize
 2760     stack_case:                                                                    synthesize
 2761        procedure (datum);                                                          synthesize
 2762           declare datum fixed;                                                     stack_case
 2763           declare dclrm character                                                  stack_case
 2764                 initial ('too many cases or factored declarations');               stack_case
 2765           if casep >= CASELIMIT then call error (dclrm,1);                         stack_case
 2766                                 else casep = casep + 1;                            stack_case
 2767           casestack(casep) = datum;                                                stack_case
 2768     end stack_case;                                                                stack_case
 
symbol table dump
 
symbol          type       loc   segment defined ref count
datum           fixed     10486     data   2761       1
dclrm           character   932   string   2764       1
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 95
 line    source statement                                                               procedure and compiler information
 
 2769                                                                                    synthesize
 2770        do case (production_number);                                                synthesize
 2771     /*  one statement for each production of the grammar*/                         synthesize case 0.
 2772     ;      /*  case 0 is a dummy, because we number productions from 1  */         synthesize
 2773                                                                                    synthesize case 1.
 2774  /*      1   <program> ::= <statement list> eof                       */           synthesize
 2775  do;  /* end of compiling */                                                       synthesize
 2776     compiling = FALSE;                                                             synthesize
 2777     if mp ~= 0  then                                                               synthesize
 2778        do;                                                                         synthesize
 2779           call error ('input did not parse to <program>.', 1);                     synthesize
 2780           call stack_dump;                                                         synthesize
 2781        end;                                                                        synthesize
 2782     do i = procmark to ndecsy;                                                     synthesize
 2783        if sytype (i) = FORWARDTYPE | sytype (i) = FORWARDCALL then                 synthesize
 2784           if sytco (i) > 0 then                                                    synthesize
 2785               call error ('undefined label or procedure: ' || syt(i),1);           synthesize
 2786     end;                                                                           synthesize
 2787        if dpoffset > 0 then call flush_datacard;                                   synthesize
 2788  end;                                                                              synthesize
 2789                                                                                    synthesize case 2.
 2790  /*      2   <statement list> ::= <statement>                         */           synthesize
 2791     ;                                                                              synthesize
 2792  /*      3                      | <statement list> <statement>        */           synthesize case 3.
 2793     ;                                                                              synthesize
 2794  /*      4   <statement> ::= <basic statement>                        */           synthesize case 4.
 2795     do;                                                                            synthesize
 2796        statement_count = statement_count + 1;                                      synthesize
 2797        call clearars;                                                              synthesize
 2798     end;                                                                           synthesize
 2799                                                                                    synthesize case 5.
 2800  /*      5                 | <if statement>                           */           synthesize
 2801     call clearars;                                                                 synthesize
 2802  /*      6   <basic statement> ::= <assignment> ;                     */           synthesize case 6.
 2803     ;                                                                              synthesize
 2804  /*      7                       | <group> ;                          */           synthesize case 7.
 2805     ;                                                                              synthesize
 2806  /*      8                       | <procedure definition> ;           */           synthesize case 8.
 2807     ;                                                                              synthesize
 2808  /*      9                       | <return statement> ;               */           synthesize case 9.
 2809     ;                                                                              synthesize
 2810  /*     10                       | <call statement> ;                 */           synthesize case 10.
 2811     ;                                                                              synthesize
 2812  /*     11                       | <go to statement> ;                */           synthesize case 11.
 2813     ;                                                                              synthesize
 2814  /*     12                       | <declaration statement> ;          */           synthesize case 12.
 2815     ;                                                                              synthesize
 2816  /*     13                       | ;                                  */           synthesize case 13.
 2817     ;                                                                              synthesize
 2818  /*     14                       | <label definition>                 */           synthesize case 14.
 2819  /*     14                         <basic statement>                  */           synthesize
 2820     ;                                                                              synthesize
 2821  /*     15   <if statement> ::= <if clause> <statement>               */           synthesize case 15.
 2822     call emitlabel(fixl(mp),4);            /* fix escape branch */                 synthesize
 2823  /*     16                    | <if clause> <TRUE part> <statement>   */           synthesize case 16.
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 96
 line    source statement                                                               procedure and compiler information
 
 2824     call emitlabel (fixl(mpp1),4);         /* fix escape branch */                 synthesize
 2825  /*     17                    | <label definition> <if statement>     */           synthesize case 17.
 2826     ;                                                                              synthesize
 2827  /*     18   <if clause> ::= if <expression> then                     */           synthesize case 18.
 2828        call boolbranch(mpp1,mp);  /* branch on FALSE over TRUE part */             synthesize
 2829                                                                                    synthesize case 19.
 2830  /*     19   <TRUE part> ::= <basic statement> else                   */           synthesize
 2831     do; /* save the program pointer and emit the conditional branch */             synthesize
 2832        fixl(mp) = findlabel;                                                       synthesize
 2833        call emitinst(jrst ,0,0,fixl(mp),0,4);                                      synthesize
 2834        call emitlabel (fixl(mp-1),4);      /* complete hop around TRUE */          synthesize
 2835        call clearars;                                                              synthesize
 2836     end;                                                                           synthesize
 2837                                                                                    synthesize case 20.
 2838  /*     20   <group> ::= <group head> <ending>                        */           synthesize
 2839          /* branch back to loop and fix escape branch */                           synthesize
 2840        if inx (mp) = 1 | inx (mp) = 2 then                                         synthesize
 2841           do;  /* step or while loop fixup */                                      synthesize
 2842              call emitinst (jrst ,0,0,ppsave(mp),0,2);                             synthesize
 2843              call emitlabel(fixl(mp),4);                                           synthesize
 2844           end;                                                                     synthesize
 2845         else if inx (mp) = 3 then                                                  synthesize
 2846           do;  /* case group */                                                    synthesize
 2847              call emitlabel(fixl(mp),4);   /* fix branch into jump list */         synthesize
 2848              do i = ppsave (mp) to casep - 1;                                      synthesize
 2849                 call emitinst (jrst ,0,0,casestack(i),0,2); /* jump list */        synthesize
 2850                 end;                                                               synthesize
 2851              casep = ppsave (mp) - 1;                                              synthesize
 2852              call emitlabel(fixv(mp),4);   /* fix escape branch */                 synthesize
 2853           end;                                                                     synthesize
 2854                                                                                    synthesize
 2855  /*     21   <group head> ::= do ;                                    */           synthesize
 2856     inx (mp) = 0;                       /* zero denotes ordinary group */          synthesize
 2857                                                                                    synthesize case 21. case 22.
 2858  /*     22                  | do <step definition> ;                  */           synthesize
 2859     do;                                                                            synthesize
 2860        call movestacks (mpp1, mp);                                                 synthesize
 2861        inx (mp) = 1;                    /* one denotes step */                     synthesize
 2862        call clearars;                                                              synthesize
 2863     end;                                                                           synthesize
 2864                                                                                    synthesize case 23.
 2865  /*     23                  | do <while clause> ;                     */           synthesize
 2866     do;                                                                            synthesize
 2867        call movestacks (mpp1,mp);                                                  synthesize
 2868        inx (mp) = 2;                    /* two denotes while */                    synthesize
 2869        call clearars;                                                              synthesize
 2870     end;                                                                           synthesize
 2871                                                                                    synthesize case 24.
 2872  /*     24                  | do <case selector> ;                    */           synthesize
 2873     do;                                                                            synthesize
 2874        call movestacks (mpp1, mp);                                                 synthesize
 2875        inx (mp) = 3;                    /* three denotes case */                   synthesize
 2876        call clearars;                                                              synthesize
 2877        info = info || ' case 0.';                                                  synthesize
 2878     end;                                                                           synthesize
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 97
 line    source statement                                                               procedure and compiler information
 
 2879                                                                                    synthesize case 25.
 2880  /*     25                  | <group head> <statement>                */           synthesize
 2881     if inx (mp) = 3 then                                                           synthesize
 2882        do; /* case group, must record statement addresses */                       synthesize
 2883           call emitinst (jrst ,0,0,fixv(mp),0,4);                                  synthesize
 2884           call stack_case (pp);                                                    synthesize
 2885           info = info || ' case ' || casep - ppsave(mp) || '.';                    synthesize
 2886        end;                                                                        synthesize
 2887                                                                                    synthesize
 2888  /*     26   <step definition> ::= <VARIABLE> <replace>               */           synthesize
 2889  /*     26                         <expression> <iteration control>   */           synthesize
 2890     do; /* emit code for stepping do loops */                                      synthesize
 2891        call forceaccumulator (mp+2);     /* get initial value */                   synthesize case 26.
 2892        stepk = findlabel;                                                          synthesize
 2893        call emitinst (jrst ,0,0,stepk,0,4);/* branch around incr code */           synthesize
 2894        ppsave(mp) = pp;                  /* save address for later fix */          synthesize
 2895        if cnt (mp) > 0 then call error ('do index may not be subscripted',0);      synthesize
 2896                                                                                    synthesize
 2897                         /*  increment induction VARIABLE */                        synthesize
 2898        if sytype(fixl(mp)) = FIXEDTYPE & fixl(sp) = trueloc then                   synthesize
 2899           do;           /* use aos if incrementing by 1 */                         synthesize
 2900              reg(mp) = reg(mp+2);                                                  synthesize
 2901              call emitinst (aosa,reg(mp),0,sytloc(fixl(mp)),0,1);                  synthesize
 2902              type(mp) = ACCUMULATOR;                                               synthesize
 2903           end;                                                                     synthesize
 2904        else                                                                        synthesize
 2905           do;           /* can't use aos inst. */                                  synthesize
 2906              acc(reg(mp+2)) = AVAIL;     /* make sure same register is used */     synthesize
 2907              target_register = reg(mp+2);                                          synthesize
 2908              call forceaccumulator (mp); /* fetch the index     */                 synthesize
 2909              target_register = -1;                                                 synthesize
 2910              call emitinst(add,reg(mp),0,fixl(mp+3),0,1);                          synthesize
 2911           end;                                                                     synthesize
 2912                         /* update induction VARIABLE and test for end */           synthesize
 2913        call emitlabel(stepk,4);                                                    synthesize
 2914        call genstore (mp,mp);                                                      synthesize
 2915        call emitinst (camle,reg(mp),0,fixv(sp),0,1);                               synthesize
 2916        fixl (mp) = findlabel;                                                      synthesize
 2917        call emitinst (jrst ,0,0,fixl(mp),0,4);                                     synthesize
 2918        acc(reg(mp)) = AVAIL;                                                       synthesize
 2919     end;                                                                           synthesize
 2920                                                                                    synthesize case 27.
 2921  /*     27   <iteration control> ::= to <expression>                  */           synthesize
 2922     do;                                                                            synthesize
 2923        fixl(mp) = trueloc;   /* point at the CONSTANT one for step */              synthesize
 2924        call setlimit;                                                              synthesize
 2925     end;                                                                           synthesize
 2926                                                                                    synthesize case 28.
 2927  /*     28                         | to <expression> by               */           synthesize
 2928  /*     28                           <expression>                     */           synthesize
 2929     do;                                                                            synthesize
 2930        if type (sp) = CONSTANT then call emitconstant (fixv(sp));                  synthesize
 2931        else                                                                        synthesize
 2932           do;                                                                      synthesize
 2933              call forceaccumulator (sp);                                           synthesize
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 98
 line    source statement                                                               procedure and compiler information
 
 2934              call emitdataword (0);                                                synthesize
 2935              adr = dp - 1;                                                         synthesize
 2936              call emitinst (movem,reg(sp),0,adr,0,1);                              synthesize
 2937              acc(reg(sp)) = AVAIL;                                                 synthesize
 2938           end;                                                                     synthesize
 2939        fixl (mp) =adr;                                                             synthesize
 2940        call setlimit;                                                              synthesize
 2941     end;                                                                           synthesize
 2942                                                                                    synthesize case 29.
 2943  /*     29   <while clause> ::= while <expression>                    */           synthesize
 2944     call boolbranch (sp,mp);                                                       synthesize
 2945                                                                                    synthesize case 30.
 2946  /*     30   <case selector> ::= case <expression>                    */           synthesize
 2947     /* the following use is made of the parallel stacks below <case selector>      synthesize
 2948           ppsave     previous maximum case stack pointer                           synthesize
 2949           fixl       address of indexed goto into list                             synthesize
 2950           fixv       address of escape goto for cases                              synthesize
 2951     */                                                                             synthesize
 2952     do;                                                                            synthesize
 2953        call forceaccumulator (sp);       /* get the index in to ar */              synthesize
 2954        acc(reg(sp)) = AVAIL;                                                       synthesize
 2955        fixl(mp) = findlabel;                                                       synthesize
 2956        call emitinst (jrst ,0,1,fixl(mp),reg(sp),4);/* indirect indexed branch */  synthesize
 2957        fixv(mp) = findlabel;             /* address of escape branch */            synthesize
 2958        call stack_case (pp);                                                       synthesize
 2959        ppsave (mp) = casep;                                                        synthesize
 2960     end;                                                                           synthesize
 2961                                                                                    synthesize case 31.
 2962  /*     31   <procedure definition> ::= <procedure head>              */           synthesize
 2963  /*     31                              <statement list> <ending>     */           synthesize
 2964     /* the following use is made of the parallel stacks below                      synthesize
 2965        <procedure head>                                                            synthesize
 2966        ppsave           address of previous proc return                            synthesize
 2967        fixl             address of previous proc ACCUMULATOR area                  synthesize
 2968        fixv             pointer to symbol table for this block                     synthesize
 2969        cnt              count of the parameters of previous proc                   synthesize
 2970     */                                                                             synthesize
 2971     do;   /* procedure is defined, restore symbol table */                         synthesize
 2972        if length (var(sp)) > 0 then                                                synthesize
 2973           if substr (current_procedure,1) ~= var(sp) then                          synthesize
 2974              call error ('procedure' || current_procedure || ' closed by end '     synthesize
 2975                          || var(sp), 0);                                           synthesize
 2976        if control(byte('S')) then call symboldump;                                 synthesize
 2977        do i = procmark to ndecsy;                                                  synthesize
 2978           if sytype (i) = FORWARDTYPE | sytype (i) = FORWARDCALL then              synthesize
 2979              if sytco (i) > 0 then                                                 synthesize
 2980                 call error ('undefined label or procedure: ' || syt (i), 1);       synthesize
 2981        end;                                                                        synthesize
 2982        do i = 0 to (ndecsy + 1) - (procmark + parct);                              synthesize
 2983           j = ndecsy - i;                                                          synthesize
 2984           if (j >= (procmark + parct)) & (length(syt(j)) > 0) then                 synthesize
 2985              do;                                                                   synthesize
 2986                 hash (hasher(syt(j))) = ptr (j);                                   synthesize
 2987                 ptr (j) = -1;                                                      synthesize
 2988              end;                                                                  synthesize
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 99
 line    source statement                                                               procedure and compiler information
 
 2989        end;                                                                        synthesize
 2990        do i = procmark + parct to ndecsy;                                          synthesize
 2991            syt (i) = x1;                                                           synthesize
 2992        end;                                                                        synthesize
 2993        ndecsy = procmark + parct - 1;                                              synthesize
 2994        /* parameter addresses must be saved but names discarded */                 synthesize
 2995        if parct > 0 then                                                           synthesize
 2996           do j = 0 to ndecsy - procmark;                                           synthesize
 2997              i = ndecsy - j;                                                       synthesize
 2998              if sytype (i) = 0 then                                                synthesize
 2999                 do;                                                                synthesize
 3000                    call error ('undeclared parameter: ' || syt (i), 0);            synthesize
 3001                    sytype (i) = FIXEDTYPE;                                         synthesize
 3002                    call emitdataword (0);                                          synthesize
 3003                    sytloc(i) = dp -1;                                              synthesize
 3004                 end;                                                               synthesize
 3005              hash (hasher(syt(i))) = ptr (i);                                      synthesize
 3006              ptr (i) = -1;                                                         synthesize
 3007              syt (i) = '';                                                         synthesize
 3008           end;                                                                     synthesize
 3009        procmark = fixv (mp);                                                       synthesize
 3010        parct = cnt (mp);                                                           synthesize
 3011        current_procedure = var (mp);                                               synthesize
 3012        /* emit a gratuitous return */                                              synthesize
 3013        call emitinst (popj,15,0,0,0,0);                                            synthesize
 3014        /* complete jump around the procedure definition */                         synthesize
 3015        call emitlabel(ppsave(mp),4);                                               synthesize
 3016        returned_type = type(mp);                                                   synthesize
 3017     end;                                                                           synthesize
 3018                                                                                    synthesize case 32.
 3019  /*     32   <procedure head> ::= <procedure name> ;                  */           synthesize
 3020     do;      /* must point at first parameter even if non existant */              synthesize
 3021        /* save old parameter count */                                              synthesize
 3022        cnt (mp) = parct;                                                           synthesize
 3023        parct = 0;                                                                  synthesize
 3024        /* save old procedure mark in symbol table */                               synthesize
 3025        fixv(mp) = procmark;                                                        synthesize
 3026        procmark = ndecsy + 1;                                                      synthesize
 3027        type(mp) = returned_type;                                                   synthesize
 3028        returned_type = 0;                                                          synthesize
 3029        call proc_start;                                                            synthesize
 3030     end;                                                                           synthesize
 3031                                                                                    synthesize case 33.
 3032  /*     33                      | <procedure name> <type> ;           */           synthesize
 3033     do;                                                                            synthesize
 3034        cnt (mp) = parct;           /* save old parameter count */                  synthesize
 3035        parct = 0;                                                                  synthesize
 3036        fixv(mp) = procmark;        /* save old procedure mark in symbol table */   synthesize
 3037        procmark = ndecsy + 1;                                                      synthesize
 3038        type(mp) = returned_type;                                                   synthesize
 3039        returned_type = type(sp-1);                                                 synthesize
 3040        if returned_type = CHRTYPE then sytype(fixl(mp)) = CHARPROCTYPE;            synthesize
 3041        call proc_start;                                                            synthesize
 3042     end;                                                                           synthesize
 3043                                                                                    synthesize case 34.
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 100
 line    source statement                                                               procedure and compiler information
 
 3044  /*     34                      | <procedure name> <parameter list>   */           synthesize
 3045  /*     34                        ;                                   */           synthesize
 3046     do;                                                                            synthesize
 3047        cnt(mp) = cnt(mpp1);  /* save parameter count */                            synthesize
 3048        fixv(mp) = fixv (mpp1);                                                     synthesize
 3049        type(mp) = returned_type;                                                   synthesize
 3050        returned_type = 0;                                                          synthesize
 3051        call proc_start;                                                            synthesize
 3052     end;                                                                           synthesize
 3053                                                                                    synthesize case 35.
 3054  /*     35                      | <procedure name> <parameter list>   */           synthesize
 3055  /*     35                        <type> ;                            */           synthesize
 3056     do;                                                                            synthesize
 3057        cnt(mp) = cnt(mpp1);  /* save parameter count */                            synthesize
 3058        fixv(mp) = fixv (mpp1);                                                     synthesize
 3059        type(mp) = returned_type;                                                   synthesize
 3060        returned_type = type(sp-1);                                                 synthesize
 3061        if returned_type = CHRTYPE then sytype(fixl(mp)) = CHARPROCTYPE;            synthesize
 3062        call proc_start;                                                            synthesize
 3063     end;                                                                           synthesize
 3064                                                                                    synthesize case 36.
 3065  /*     36   <procedure name> ::= <label definition> procedure        */           synthesize
 3066     do;                                                                            synthesize
 3067        sytype (fixl (mp)) = PROCTYPE;                                              synthesize
 3068        s = current_procedure;                                                      synthesize
 3069        current_procedure = x1 || var (mp);                                         synthesize
 3070        var (mp) = s;                                                               synthesize
 3071     end;                                                                           synthesize
 3072                                                                                    synthesize case 37.
 3073                                                                                    synthesize
 3074  /*     37   <parameter list> ::= <parameter head> <identifier> )     */           synthesize
 3075     do;                                                                            synthesize
 3076        parct = parct + 1;   /* bump the parameter count */                         synthesize
 3077        call enter (var(mpp1), 0, 0, 0);                                            synthesize
 3078     end;                                                                           synthesize
 3079                                                                                    synthesize case 38.
 3080  /*     38   <parameter head> ::= (                                   */           synthesize
 3081     do;  /* point at the first parameter for symbol table */                       synthesize
 3082        fixv(mp) = procmark;                                                        synthesize
 3083        procmark = ndecsy + 1;                                                      synthesize
 3084        cnt (mp) = parct;        /* save old parameter count */                     synthesize
 3085        parct = 0;                                                                  synthesize
 3086     end;                                                                           synthesize
 3087                                                                                    synthesize case 39.
 3088  /*     39                      | <parameter head> <identifier> ,     */           synthesize
 3089     do;                                                                            synthesize
 3090         parct = parct + 1;          /* bump the parameter count */                 synthesize
 3091        call enter (var(mpp1), 0, 0, 0);                                            synthesize
 3092     end;                                                                           synthesize
 3093                                                                                    synthesize case 40.
 3094  /*     40   <ending> ::= end                                         */           synthesize
 3095     ;                                                                              synthesize
 3096  /*     41              | end <identifier>                            */           synthesize case 41.
 3097     var (mp) = var (sp);                                                           synthesize
 3098                                                                                    synthesize case 42.
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 101
 line    source statement                                                               procedure and compiler information
 
 3099  /*     42              | <label definition> <ending>                 */           synthesize
 3100     ;                                                                              synthesize
 3101  /*     43   <label definition> ::= <identifier> :                    */           synthesize case 43.
 3102     fixl(mp) = enter (var(mp), LABELTYPE, pp, 2);                                  synthesize
 3103                                                                                    synthesize case 44.
 3104  /*     44   <return statement> ::= return                            */           synthesize
 3105     do;                                                                            synthesize
 3106        call emitinst (popj,15,0,0,0,0);                                            synthesize
 3107     end;                                                                           synthesize
 3108                                                                                    synthesize case 45.
 3109  /*     45                        | return <expression>               */           synthesize
 3110     do;  /* emit a return and pass a value */                                      synthesize
 3111        target_register = 0;                                                        synthesize
 3112        if returned_type = CHRTYPE then                                             synthesize
 3113           call forcedescriptor(sp);                                                synthesize
 3114        else                                                                        synthesize
 3115           call forceaccumulator (sp);                                              synthesize
 3116        target_register = -1;                                                       synthesize
 3117        if reg(sp) ~= 0 then call emitinst(move,0,0,reg(sp),0,0);                   synthesize
 3118        call emitinst (popj,15,0,0,0,0);                                            synthesize
 3119     end;                                                                           synthesize
 3120                                                                                    synthesize case 46.
 3121  /*     46   <call statement> ::= call <VARIABLE>                     */           synthesize
 3122     do;                                                                            synthesize
 3123        i = sytype(fixl(sp));                                                       synthesize
 3124        if i=PROCTYPE | i=FORWARDCALL | i = CHARPROCTYPE                            synthesize
 3125                      | (i=SPECIAL & sytloc(fixl(sp))=12)                           synthesize
 3126                      | (i=SPECIAL & sytloc(fixl(sp))=9)  then                      synthesize
 3127           do;                                                                      synthesize
 3128              calltype = 0;               /* no return value */                     synthesize
 3129              call forceaccumulator(sp);                                            synthesize
 3130              calltype = 1;                                                         synthesize
 3131           end;                                                                     synthesize
 3132        else call error ('undefined procedure: ' || syt(fixl(sp)),0);               synthesize
 3133     end;                                                                           synthesize
 3134                                                                                    synthesize case 47.
 3135  /*     47   <go to statement> ::= <go to> <identifier>               */           synthesize
 3136     do;                                                                            synthesize
 3137        call id_lookup(sp);                                                         synthesize
 3138        j = fixl (sp);                                                              synthesize
 3139        if j < 0 then                                                               synthesize
 3140           do;  /* first ocurrance of the label */                                  synthesize
 3141              i = findlabel;                                                        synthesize
 3142              call emitinst (jrst ,0,0,i,0,4);                                      synthesize
 3143              j = enter (var(sp),FORWARDTYPE,i,4);                                  synthesize
 3144              sytco (j) = 1;                                                        synthesize
 3145           end;                                                                     synthesize
 3146        else if sytype(j) = LABELTYPE | sytype(j) = FORWARDTYPE then                synthesize
 3147            call emitinst (jrst ,0,0,sytloc(j),0,sytseg(j));                        synthesize
 3148        else                                                                        synthesize
 3149          call error ('target of goto is not a label', 0);                          synthesize
 3150     end;                                                                           synthesize
 3151                                                                                    synthesize case 48.
 3152  /*     48   <go to> ::= go to                                        */           synthesize
 3153     ;                                                                              synthesize
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 102
 line    source statement                                                               procedure and compiler information
 
 3154  /*     49             | goto                                         */           synthesize case 49.
 3155     ;                                                                              synthesize
 3156  /*     50   <declaration statement> ::= declare                      */           synthesize case 50.
 3157  /*     50                               <declaration element>        */           synthesize
 3158     ;                                                                              synthesize
 3159  /*     51                             | <declaration statement> ,    */           synthesize case 51.
 3160  /*     51                               <declaration element>        */           synthesize
 3161     ;                                                                              synthesize
 3162  /*     52   <declaration element> ::= <type declaration>             */           synthesize case 52.
 3163        if type (mp) = CHRTYPE then                                                 synthesize
 3164           do while (dsp < newdsp);                                                 synthesize
 3165              call emitdesc (0,0);                                                  synthesize
 3166           end;                                                                     synthesize
 3167        else                                                                        synthesize
 3168           do;                                                                      synthesize
 3169              if dp < newdp then                                                    synthesize
 3170                 do;                                                                synthesize
 3171                    if dpoffset > 0 then call flush_datacard;                       synthesize
 3172                    if dp < newdp then call emitblock (newdp-dp);                   synthesize
 3173                 end;                                                               synthesize
 3174              do while (dpoffset < newdpoffset);                                    synthesize
 3175                 call emitbyte(0);                                                  synthesize
 3176              end;                                                                  synthesize
 3177           end;                                                                     synthesize
 3178                                                                                    synthesize case 53.
 3179  /*     53                           | <identifier> literally         */           synthesize
 3180  /*     53                             <string>                       */           synthesize
 3181     if top_macro >= MACRO_LIMIT then                                               synthesize
 3182        call error ('macro table overflow', 1);                                     synthesize
 3183     else do;                                                                       synthesize
 3184        top_macro = top_macro + 1;                                                  synthesize
 3185        i = length(var(mp));                                                        synthesize
 3186        j = macro_index(i);                                                         synthesize
 3187        do l = 1 to top_macro - j;                                                  synthesize
 3188           k = top_macro - l;                                                       synthesize
 3189           macro_name(k+1) = macro_name(k);                                         synthesize
 3190           macro_text(k+1) = macro_text(k);                                         synthesize
 3191           macro_count(k+1) = macro_count(k);                                       synthesize
 3192           macro_declare(k+1) = macro_declare(k);                                   synthesize
 3193        end;                                                                        synthesize
 3194        macro_name(j) = var(mp);                                                    synthesize
 3195        macro_text(j) = var(sp);                                                    synthesize
 3196        macro_count(j) = 0;                                                         synthesize
 3197        macro_declare(j) = card_count;                                              synthesize
 3198        do j = i to 255;                                                            synthesize
 3199           macro_index(j) = macro_index(j) + 1;                                     synthesize
 3200        end;                                                                        synthesize
 3201     end;                                                                           synthesize
 3202                                                                                    synthesize case 54.
 3203  /*     54   <type declaration> ::= <identifier specification>        */           synthesize
 3204  /*     54                          <type>                            */           synthesize
 3205     call tdeclare (0);                                                             synthesize
 3206                                                                                    synthesize case 55.
 3207  /*     55                        | <bound head> <number> ) <type>    */           synthesize
 3208     call tdeclare (fixv(mpp1));                                                    synthesize
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 103
 line    source statement                                                               procedure and compiler information
 
 3209                                                                                    synthesize case 56.
 3210  /*     56                        | <type declaration>                */           synthesize
 3211  /*     56                          <initial list>                    */           synthesize
 3212     ;                                                                              synthesize
 3213  /*     57   <type> ::= fixed                                         */           synthesize case 57.
 3214     type (mp) = FIXEDTYPE;                                                         synthesize
 3215  /*     58            | character                                     */           synthesize case 58.
 3216     type (mp) = CHRTYPE;                                                           synthesize
 3217  /*     59            | label                                         */           synthesize case 59.
 3218     type (mp) = FORWARDTYPE;                                                       synthesize
 3219                                                                                    synthesize case 60.
 3220  /*     60            | <bit head> <number> )                         */           synthesize
 3221     if fixv(mpp1) <= 9 then type (mp) = BYTETYPE; else                             synthesize
 3222        if fixv (mpp1) <= 36 then type (mp) = FIXEDTYPE; else                       synthesize
 3223           type (mp) = CHRTYPE;                                                     synthesize
 3224                                                                                    synthesize case 61.
 3225  /*     61   <bit head> ::= bit (                                     */           synthesize
 3226     ;                                                                              synthesize
 3227  /*     62   <bound head> ::= <identifier specification> (            */           synthesize case 62.
 3228     ;                                                                              synthesize
 3229  /*     63   <identifier specification> ::= <identifier>              */           synthesize case 63.
 3230     do;                                                                            synthesize
 3231        inx(mp) = 1;                                                                synthesize
 3232        fixl(mp) = casep;                                                           synthesize
 3233        call stack_case (enter(var(mp),0,0,0));                                     synthesize
 3234     end;                                                                           synthesize
 3235  /*     64                                | <identifier list>         */           synthesize case 64.
 3236  /*     64                                  <identifier> )            */           synthesize
 3237     do;                                                                            synthesize
 3238        inx(mp) = inx(mp) + 1;                                                      synthesize
 3239        call stack_case (enter(var(mpp1),0,0,0));                                   synthesize
 3240     end;                                                                           synthesize
 3241  /*     65   <identifier list> ::= (                                  */           synthesize case 65.
 3242     do;                                                                            synthesize
 3243        inx(mp) = 0;                                                                synthesize
 3244        fixl(mp) = casep;                                                           synthesize
 3245     end;                                                                           synthesize
 3246  /*     66                       | <identifier list> <identifier> ,   */           synthesize case 66.
 3247     do;                                                                            synthesize
 3248        inx(mp) = inx(mp) + 1;                                                      synthesize
 3249        call stack_case (enter(var(mpp1),0,0,0));                                   synthesize
 3250     end;                                                                           synthesize
 3251                                                                                    synthesize case 67.
 3252  /*     67   <initial list> ::= <initial head> <CONSTANT> )           */           synthesize
 3253     call setinit;                                                                  synthesize
 3254                                                                                    synthesize case 68.
 3255  /*     68   <initial head> ::= initial (                             */           synthesize
 3256     if inx(mp-1) = 1 then                                                          synthesize
 3257        itype = type (mp-1);  /* copy information from <type declaration> */        synthesize
 3258     else                                                                           synthesize
 3259        do;                                                                         synthesize
 3260           call error ('initial may not be used with identifier list',0);           synthesize
 3261           itype = 0;                                                               synthesize
 3262        end;                                                                        synthesize
 3263                                                                                    synthesize case 69.
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 104
 line    source statement                                                               procedure and compiler information
 
 3264  /*     69                    | <initial head> <CONSTANT> ,           */           synthesize
 3265     call setinit;                                                                  synthesize
 3266  /*     70   <assignment> ::= <VARIABLE> <replace> <expression>       */           synthesize case 70.
 3267     call genstore(mp,sp);                                                          synthesize
 3268  /*     71                  | <left part> <assignment>                */           synthesize case 71.
 3269     call genstore(mp,sp);                                                          synthesize
 3270  /*     72   <replace> ::= =                                          */           synthesize case 72.
 3271     ;                                                                              synthesize
 3272  /*     73   <left part> ::= <VARIABLE> ,                             */           synthesize case 73.
 3273     ;                                                                              synthesize
 3274  /*     74   <expression> ::= <logical factor>                        */           synthesize case 74.
 3275     ;                                                                              synthesize
 3276  /*     75                  | <expression> | <logical factor>         */           synthesize case 75.
 3277     call arithemit (ior,1);                                                        synthesize
 3278  /*     76   <logical factor> ::= <logical secondary>                 */           synthesize case 76.
 3279     ;                                                                              synthesize
 3280  /*     77                      | <logical factor> &                  */           synthesize case 77.
 3281  /*     77                        <logical secondary>                 */           synthesize
 3282     call arithemit (and,1);                                                        synthesize
 3283  /*     78   <logical secondary> ::= <logical primary>                */           synthesize case 78.
 3284     ;                                                                              synthesize
 3285  /*     79                         | ~ <logical primary>              */           synthesize case 79.
 3286     do;                                                                            synthesize
 3287        call movestacks (sp, mp);                                                   synthesize
 3288         /* get 1's complement */                                                   synthesize
 3289        call forceaccumulator(mp);                                                  synthesize
 3290        call emitinst (setca,reg(mp),0,0,0,0);                                      synthesize
 3291     end;                                                                           synthesize
 3292                                                                                    synthesize case 80.
 3293  /*     80   <logical primary> ::= <string expression>                */           synthesize
 3294     ;                                                                              synthesize
 3295  /*     81                       | <string expression> <relation>     */           synthesize case 81.
 3296  /*     81                         <string expression>                */           synthesize
 3297        /* relations are encoded as to their cam? instriction code */               synthesize
 3298        /*                                                                          synthesize
 3299           <     1                                                                  synthesize
 3300           >     7                                                                  synthesize
 3301           ~=    6                                                                  synthesize
 3302           =     2                                                                  synthesize
 3303           <=    3                                                                  synthesize
 3304           ~>    3                                                                  synthesize
 3305           >=    5                                                                  synthesize
 3306           ~<    5                                                                  synthesize
 3307        */                                                                          synthesize
 3308     do;                                                                            synthesize
 3309        i = type (mp);                                                              synthesize
 3310        j = type (sp);                                                              synthesize
 3311        if i = DESCRIPT | i = CHRTYPE then call stringcompare; else                 synthesize
 3312        if i = VARIABLE & sytype(fixl(mp)) = CHRTYPE then call stringcompare; else  synthesize
 3313        if j = DESCRIPT | j = CHRTYPE then call stringcompare; else                 synthesize
 3314        if j = VARIABLE & sytype(fixl(sp)) = CHRTYPE then call stringcompare; else  synthesize
 3315           do;                                                                      synthesize
 3316              if i = VARIABLE & sytype(fixl(mp)) = BYTETYPE then                    synthesize
 3317                     call forceaccumulator(mp);                                     synthesize
 3318              if j = VARIABLE & sytype(fixl(sp)) = BYTETYPE then                    synthesize
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 105
 line    source statement                                                               procedure and compiler information
 
 3319                     call forceaccumulator(sp);                                     synthesize
 3320              if shouldcommute then call forceaccumulator(sp);                      synthesize
 3321              else call forceaccumulator(mp);                                       synthesize
 3322              i = findar;                                                           synthesize
 3323              call emitinst(movei,i,0,1,0,0);                                       synthesize
 3324              call arithemit (cam+inx(mpp1),1);                                     synthesize
 3325              call emitinst (movei,i,0,0,0,0);                                      synthesize
 3326              stillcond = inx(mpp1);                                                synthesize
 3327              acc(reg(mp))=AVAIL;                                                   synthesize
 3328              reg(mp) = i;                                                          synthesize
 3329              type(mp) = ACCUMULATOR;                                               synthesize
 3330           end;                                                                     synthesize
 3331     end;                                                                           synthesize
 3332                                                                                    synthesize case 82.
 3333  /*     82   <relation> ::= =                                         */           synthesize
 3334     inx(mp) = 2;                                                                   synthesize
 3335  /*     83                | <                                         */           synthesize case 83.
 3336     inx(mp) = 1;                                                                   synthesize
 3337  /*     84                | >                                         */           synthesize case 84.
 3338     inx(mp) = 7;                                                                   synthesize
 3339  /*     85                | ~ =                                       */           synthesize case 85.
 3340     inx(mp) = 6;                                                                   synthesize
 3341  /*     86                | ~ <                                       */           synthesize case 86.
 3342     inx (mp) = 5;                                                                  synthesize
 3343  /*     87                | ~ >                                       */           synthesize case 87.
 3344     inx(mp) = 3;                                                                   synthesize
 3345  /*     88                | < =                                       */           synthesize case 88.
 3346     inx(mp) = 3;                                                                   synthesize
 3347  /*     89                | > =                                       */           synthesize case 89.
 3348     inx (mp) = 5;                                                                  synthesize
 3349  /*     90   <string expression> ::= <arithmetic expression>          */           synthesize case 90.
 3350     ;                                                                              synthesize
 3351                                                                                    synthesize case 91.
 3352  /*     91                         | <string expression> ||           */           synthesize
 3353  /*     91                           <arithmetic expression>          */           synthesize
 3354      do; /* catenate two strings */                                                synthesize
 3355        call forcedescriptor (mp);                                                  synthesize
 3356        call delete_move (mp,movem,reg(mp),0,a,0,3);                                synthesize
 3357        acc(reg(mp)) = AVAIL;                                                       synthesize
 3358        call forcedescriptor (sp);                                                  synthesize
 3359        call delete_move (sp,movem,reg(sp),0,b,0,3);                                synthesize
 3360        acc(reg(sp)) = AVAIL;                                                       synthesize
 3361        call save_acs (2);                                                          synthesize
 3362        if acc(11) ~= AVAIL then call emitinst (push,15,0,11,0,0);                  synthesize
 3363        call emitinst (pushj,15,0,catentry,0,2);                                    synthesize
 3364        if acc(11) ~= AVAIL then call emitinst (pop,15,0,11,0,0);                   synthesize
 3365        call restore_acs (2);                                                       synthesize
 3366        i = findar;                                                                 synthesize
 3367        call emitinst (move,i,0,0,0,0);                                             synthesize
 3368        stillinzero = i;                                                            synthesize
 3369        reg(mp) = i;                                                                synthesize
 3370     end;                                                                           synthesize
 3371                                                                                    synthesize case 92.
 3372  /*     92   <arithmetic expression> ::= <term>                       */           synthesize
 3373     ;                                                                              synthesize
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 106
 line    source statement                                                               procedure and compiler information
 
 3374  /*     93                             | <arithmetic expression> +    */           synthesize case 93.
 3375  /*     93                               <term>                       */           synthesize
 3376     call arithemit (add,1);                                                        synthesize
 3377  /*     94                             | <arithmetic expression> -    */           synthesize case 94.
 3378  /*     94                               <term>                       */           synthesize
 3379     call arithemit (sub,0);                                                        synthesize
 3380  /*     95                             | + <term>                     */           synthesize case 95.
 3381     call movestacks (mpp1, mp);                                                    synthesize
 3382                                                                                    synthesize case 96.
 3383  /*     96                             | - <term>                     */           synthesize
 3384     do;                                                                            synthesize
 3385        call movestacks (mpp1, mp);                                                 synthesize
 3386        if type (mp) = CONSTANT then fixv (mp) = - fixv (mp);                       synthesize
 3387        else                                                                        synthesize
 3388           do;                                                                      synthesize
 3389              call forceaccumulator (mp);                                           synthesize
 3390              call emitinst (movn,reg(mp),0,reg(mp),0,0);                           synthesize
 3391           end;                                                                     synthesize
 3392     end;                                                                           synthesize
 3393                                                                                    synthesize case 97.
 3394  /*     97   <term> ::= <primary>                                     */           synthesize
 3395     ;                                                                              synthesize
 3396  /*     98            | <term> * <primary>                            */           synthesize case 98.
 3397     call arithemit (imul,1);                                                       synthesize
 3398  /*     99            | <term> / <primary>                            */           synthesize case 99.
 3399     call divide_code(1);                                                           synthesize
 3400  /*    100            | <term> mod <primary>                          */           synthesize case 100.
 3401     call divide_code(0);                                                           synthesize
 3402  /*    101   <primary> ::= <CONSTANT>                                 */           synthesize case 101.
 3403     ;                                                                              synthesize
 3404  /*    102               | <VARIABLE>                                 */           synthesize case 102.
 3405     ;                                                                              synthesize
 3406  /*    103               | ( <expression> )                           */           synthesize case 103.
 3407     call movestacks (mpp1, mp);                                                    synthesize
 3408                                                                                    synthesize case 104.
 3409  /*    104   <VARIABLE> ::= <identifier>                              */           synthesize
 3410     /* the following use is made of the parallel stacks below <VARIABLE>           synthesize
 3411            cnt      the number of subscripts                                       synthesize
 3412            fixl     the symbol table pointer                                       synthesize
 3413            fixv     builtin code if SPECIAL                                        synthesize
 3414            type     VARIABLE                                                       synthesize
 3415            inx      zero or ACCUMULATOR of subscript                               synthesize
 3416        after the VARIABLE is forced into an ACCUMULATOR                            synthesize
 3417            type     ACCUMULATOR or DESCRIPT                                        synthesize
 3418            reg      current ACCUMULATOR                                            synthesize
 3419     */                                                                             synthesize
 3420     do;   /* find the identifier in the symbol table */                            synthesize
 3421        call id_lookup (mp);                                                        synthesize
 3422         if fixl (mp) = -1 then call undeclared_id (mp);                            synthesize
 3423     end;                                                                           synthesize
 3424                                                                                    synthesize case 105.
 3425  /*    105                | <subscript head> <expression> )           */           synthesize
 3426                                                                                    synthesize
 3427     do; /* either a procedure call, array, or builtin function */                  synthesize
 3428        cnt (mp) = cnt (mp) + 1;          /* count subscripts */                    synthesize
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 107
 line    source statement                                                               procedure and compiler information
 
 3429        i = fixv (mp);                    /* zero or builtin function number */     synthesize
 3430        if i < 6 then do case i;                                                    synthesize
 3431           /* case 0 -- array or call */                                            synthesize case 0.
 3432           do;                                                                      synthesize
 3433              if sytype (fixl (mp)) = PROCTYPE                                      synthesize
 3434               | sytype (fixl (mp)) = CHARPROCTYPE then call stuff_parameter;       synthesize
 3435              else                                                                  synthesize
 3436                 if cnt (mp) > 1 then                                               synthesize
 3437                    call error ('multiple subscripts not allowed', 0);              synthesize
 3438                 else                                                               synthesize
 3439                    do;                                                             synthesize
 3440                       call forceaccumulator (mpp1);                                synthesize
 3441                       inx (mp) = reg(mpp1);                                        synthesize
 3442                    end;                                                            synthesize
 3443           end;                                                                     synthesize
 3444           /* case 1 -- builtin function length */                                  synthesize case 1.
 3445           do;                                                                      synthesize
 3446              call forcedescriptor (mpp1);                                          synthesize
 3447              call emitinst(lsh,reg(mpp1),0,    -27,0,0);/* shift out address */    synthesize
 3448              type (mp) = ACCUMULATOR;                                              synthesize
 3449              reg(mp) = reg(mpp1);                                                  synthesize
 3450           end;                                                                     synthesize
 3451           /* case 2 -- builtin function substr */                                  synthesize case 2.
 3452           do;  /* builtin function substr */                                       synthesize
 3453              if cnt(mp) = 2 then                                                   synthesize
 3454                 do;                                                                synthesize
 3455                    if type(mpp1) = CONSTANT then                                   synthesize
 3456                       do;  /* emit a complex CONSTANT */                           synthesize
 3457                          call emitconstant (shl(fixv(mpp1),27)-fixv(mpp1));        synthesize
 3458                          call emitinst (sub,reg(mp),0,adr,0,1);                    synthesize
 3459                       end;                                                         synthesize
 3460                    else                                                            synthesize
 3461                       do;                                                          synthesize
 3462                         call forceaccumulator (mpp1);                              synthesize
 3463                         call emitinst (add,reg(mp),0,reg(mpp1),0,0);               synthesize
 3464                         call emitinst (lsh,reg(mpp1),0,    27,0,0);                synthesize
 3465                         call emitinst (sub,reg(mp),0,reg(mpp1),0,0);               synthesize
 3466                         acc(reg(mpp1)) = AVAIL;                                    synthesize
 3467                       end;                                                         synthesize
 3468                 end;                                                               synthesize
 3469              else                                                                  synthesize
 3470                 do;  /* three arguments */                                         synthesize
 3471                    if type(mpp1) = CONSTANT then                                   synthesize
 3472                       do;  /* make a CONSTANT length to or in */                   synthesize
 3473                          call emitconstant (shl(fixv(mpp1),27));                   synthesize
 3474                          call emitinst (ior,reg(mp),0,adr,0,1);                    synthesize
 3475                       end;                                                         synthesize
 3476                    else                                                            synthesize
 3477                       do;                                                          synthesize
 3478                          call forceaccumulator (mpp1);                             synthesize
 3479                          call emitinst (lsh,reg(mpp1),0,    27,0,0);               synthesize
 3480                          call emitinst(ior,reg(mp),0,reg(mpp1),0,0);               synthesize
 3481                           acc(reg(mpp1)) = AVAIL;                                  synthesize
 3482                       end;                                                         synthesize
 3483                 end;                                                               synthesize
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 108
 line    source statement                                                               procedure and compiler information
 
 3484              type (mp) = DESCRIPT;                                                 synthesize
 3485           end;                                                                     synthesize
 3486           /* case 3 -- builtin function byte */                                    synthesize case 3.
 3487           do;  /* builtin function byte */                                         synthesize
 3488              if cnt(mp) = 1 then                                                   synthesize
 3489                 do;                                                                synthesize
 3490                    if type (mpp1) = CHRTYPE then                                   synthesize
 3491                       do;                                                          synthesize
 3492                          fixv(mp) = byte(var(mpp1));                               synthesize
 3493                          type (mp) = CONSTANT;                                     synthesize
 3494                       end;                                                         synthesize
 3495                    else                                                            synthesize
 3496                       do;                                                          synthesize
 3497                          call forcedescriptor (mpp1);                              synthesize
 3498                          call emitinst (and,reg(mpp1),0,addrmask,0,1);             synthesize
 3499                          /* fake a corebyte */                                     synthesize
 3500                          type(mpp1) = VARIABLE;                                    synthesize
 3501                          fixl(mpp1) = corebyteloc;                                 synthesize
 3502                          inx(mpp1) = reg(mpp1);                                    synthesize
 3503                          cnt(mpp1) = 1;                                            synthesize
 3504                          call forceaccumulator (mpp1);                             synthesize
 3505                          type(mp) = type(mpp1);                                    synthesize
 3506                          reg(mp) = reg(mpp1);                                      synthesize
 3507                       end;                                                         synthesize
 3508                 end;                                                               synthesize
 3509              else if cnt (mp) = 2 then                                             synthesize
 3510                 do;                                                                synthesize
 3511                    sp = mpp1;  /* so we can use arithemit */                       synthesize
 3512                    call arithemit (add,1);                                         synthesize
 3513                    /* fake a corebyte */                                           synthesize
 3514                    type(mpp1) = VARIABLE;                                          synthesize
 3515                    fixl(mpp1) = corebyteloc;                                       synthesize
 3516                          cnt(mpp1) = 1;                                            synthesize
 3517                    inx(mpp1) = reg(mp);                                            synthesize
 3518                    call forceaccumulator(mpp1);                                    synthesize
 3519                    type(mp) = type(mpp1);                                          synthesize
 3520                    reg(mp) = reg(mpp1);                                            synthesize
 3521                 end;                                                               synthesize
 3522              else call error (toomsg || syt(fixl(mp)),0);                          synthesize
 3523           end;                                                                     synthesize
 3524           /* case 4 -- builtin function shl */                                     synthesize case 4.
 3525           call shift_code (0);           /* <- */                                  synthesize
 3526           /* case 5 -- builtin function shr */                                     synthesize case 5.
 3527           call shift_code (1);           /* -> */                                  synthesize
 3528        end; /* case on i */                                                        synthesize case 6.
 3529        else if i = 9 then call emit_inline(1);  /*built-in function inline */      synthesize
 3530        else if i = 18 then                                                         synthesize
 3531           do;  /* builtin function addr */                                         synthesize
 3532              call forceaddress (mpp1);                                             synthesize
 3533              type (mp) = ACCUMULATOR;                                              synthesize
 3534           end;                                                                     synthesize
 3535        else do;    /* some sort of builtin function */                             synthesize
 3536                call forceaccumulator(mpp1);                                        synthesize
 3537                if cnt(mp) = 1 then reg(mp) = reg(mpp1);                            synthesize
 3538                 else inx(mp) = reg(mpp1);                                          synthesize
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 109
 line    source statement                                                               procedure and compiler information
 
 3539             end;                                                                   synthesize
 3540     end;                                                                           synthesize
 3541                                                                                    synthesize case 106.
 3542  /*    106   <subscript head> ::= <identifier> (                      */           synthesize
 3543     do;                                                                            synthesize
 3544        call id_lookup(mp);                                                         synthesize
 3545        if fixl(mp) = -1 then call undeclared_id (mp);                              synthesize
 3546     end;                                                                           synthesize
 3547                                                                                    synthesize case 107.
 3548  /*    107                      | <subscript head> <expression> ,     */           synthesize
 3549                                                                                    synthesize
 3550     do; /* builtin function or procedure call */                                   synthesize
 3551        cnt (mp) = cnt (mp) + 1;                                                    synthesize
 3552        if fixv (mp) = 0 then                                                       synthesize
 3553           do; /* not a builtin function */                                         synthesize
 3554              if sytype(fixl(mp)) = PROCTYPE                                        synthesize
 3555               | sytype(fixl(mp)) = CHARPROCTYPE then call stuff_parameter;         synthesize
 3556              else call forceaccumulator (mpp1);                                    synthesize
 3557           end;                                                                     synthesize
 3558        else if fixv(mp) = 2 | fixv (mp) = 3 then                                   synthesize
 3559           do; /* substr or byte */                                                 synthesize
 3560              if cnt(mp) = 1 then                                                   synthesize
 3561                 do;                                                                synthesize
 3562                    call forcedescriptor (mpp1);                                    synthesize
 3563                    type (mp) = ACCUMULATOR;                                        synthesize
 3564                    reg(mp) = reg(mpp1);                                            synthesize
 3565                 end;                                                               synthesize
 3566              else if cnt (mp) = 2 & fixv (mp) = 2 then                             synthesize
 3567                 do; /* just substr, we'll note error on byte later */              synthesize
 3568                    if type(mpp1) ~= CONSTANT | fixv(mpp1) ~= 0 then                synthesize
 3569                       do;                                                          synthesize
 3570                          sp = mpp1;  /* so we can use arithemit */                 synthesize
 3571                         call arithemit (add,1);                                    synthesize
 3572                          fixv(mp) = 2; /* if it commutes, arithmit changes it */   synthesize
 3573                       end;                                                         synthesize
 3574                    call emitinst(and,reg(mp),0,addrmask,0,1);/* and out length */  synthesize
 3575                 end;                                                               synthesize
 3576              else call error (toomsg || syt(fixl(mp)),0);                          synthesize
 3577           end;                                                                     synthesize
 3578        else if fixv(mp) = 4 | fixv (mp) = 5 then                                   synthesize
 3579           do; /* shr or shl */                                                     synthesize
 3580              call forceaccumulator (mpp1);                                         synthesize
 3581              reg(mp) = reg(mpp1);                                                  synthesize
 3582           end;                                                                     synthesize
 3583        else if fixv(mp) = 9 then call emit_inline(0); /* inline */                 synthesize
 3584        else do; /* some sort of builtin function */                                synthesize
 3585                if cnt (mp) = 1 then                                                synthesize
 3586                   do;                                                              synthesize
 3587                      call forceaccumulator (mpp1); /* pick up the VARIABLE */      synthesize
 3588                      reg(mp) = reg(mpp1);                                          synthesize
 3589                   end;                                                             synthesize
 3590                else call error (toomsg || syt(fixl(mp)),0);                        synthesize
 3591             end;                                                                   synthesize
 3592     end;                                                                           synthesize
 3593                                                                                    synthesize case 108.
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 110
 line    source statement                                                               procedure and compiler information
 
 3594  /*    108   <CONSTANT> ::= <string>                                  */           synthesize
 3595     type (mp) = CHRTYPE;                                                           synthesize
 3596  /*    109                | <number>                                  */           synthesize case 109.
 3597     type (mp) = CONSTANT;                                                          synthesize
 3598                                                                                    synthesize case 110.
 3599  end;  /* of case on production number */                                          synthesize
 3600  end synthesize;                                                                   synthesize
 
symbol table dump
 
symbol            type       loc   segment defined ref count
production_number fixed     10479     data   2756       1
stack_case        procedure  8802  program   2760       5
  parameter  1    fixed     10486     data   2761       6
toomsg            character   931   string   2758       3
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 111
 line    source statement                                                               procedure and compiler information
 
 3601                                                                                   *
 3602    /*              syntactic parsing functions                              */    *
 3603                                                                                   *
 3604                                                                                   *
 3605   conflict: procedure (current_state);                                            *
 3606                                                                                    conflict
 3607           declare i fixed, current_state fixed;                                    conflict
 3608                                                                                    conflict
 3609           /*   this proc is TRUE if the current token is not   */                  conflict
 3610           /*   a transition symbol from the current state      */                  conflict
 3611                                                                                    conflict
 3612           /*   (a conflict therefore exists between the        */                  conflict
 3613           /*   current state and the next token)               */                  conflict
 3614                                                                                    conflict
 3615           i = index1(current_state);   /*   starting point for state        */     conflict
 3616                                        /*   transition symbols              */     conflict
 3617           do i = i to i+index2(current_state)-1;   /*   compare with each   */     conflict
 3618           if read1(i) = token then return (FALSE); /*   found it            */     conflict
 3619           end;                                                                     conflict
 3620           return (TRUE);   /*   not there   */                                     conflict
 3621                                                                                    conflict
 3622           end conflict;                                                            conflict
 
symbol table dump
 
symbol          type       loc   segment defined ref count
current_state   fixed     10589     data   3605       2
i               fixed     10588     data   3607       5
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 112
 line    source statement                                                               procedure and compiler information
 
 3623                                                                                   *
 3624                                                                                   *
 3625   recover: procedure;                                                             *
 3626                                                                                    recover
 3627           declare answer bit(1);                                                   recover
 3628                                                                                    recover
 3629           /*   this is a very crude error recovery procedure               */      recover
 3630           /*   it returns TRUE if the parse must be resumed in             */      recover
 3631           /*   a new state (the one in the current position of the state   */      recover
 3632           /*   stack)                                                      */      recover
 3633           /*   it returns FALSE if the parse is resumed with the same      */      recover
 3634           /*   state as was intended before recover was called             */      recover
 3635                                                                                    recover
 3636           answer = FALSE;                                                          recover
 3637           /*   if this is the second successive call to recover, discard   */      recover
 3638           /*   one symbol (failsoft is set TRUE by scan)                   */      recover
 3639           if ~ failsoft & 1 then call scan;                                        recover
 3640           failsoft = FALSE;                                                        recover
 3641           /*   find something solid in the text   */                               recover
 3642           do while (~stopit(token) & 1);                                           recover
 3643           call scan;                                                               recover
 3644           end;                                                                     recover
 3645           no_look_ahead_done = FALSE;                                              recover
 3646           /*   delete parse stack until the hard token is   */                     recover
 3647           /*   legal as a transition symbol                 */                     recover
 3648           do while conflict (state_stack(sp));                                     recover
 3649           if sp > 0                                                                recover
 3650                then do;                                                            recover
 3651                     /*   delete one item from the stack   */                       recover
 3652                     sp = sp - 1;                                                   recover
 3653                     answer = TRUE;   /*   parse to be resumed in new state   */    recover
 3654                     end;                                                           recover
 3655                else do;   /*   stack is empty   */                                 recover
 3656                     /*   try to find a legal token (for start state)   */          recover
 3657                      call scan;                                                    recover
 3658                     if token = eofile                                              recover
 3659                          then do;                                                  recover
 3660                               /*   must stop compiling                */           recover
 3661                               /*   resume parse in an illegal state   */           recover
 3662                               answer = TRUE;                                       recover
 3663                               state_stack(sp) = 0;                                 recover
 3664                               return (answer);                                     recover
 3665                               end;                                                 recover
 3666                     end;                                                           recover
 3667           end;                                                                     recover
 3668           /*   found an acceptable token from which to resume the parse   */       recover
 3669           call printline ('resume:' || substr(pointer,length(pointer)-             recover
 3670              (line_length+cp-text_limit-lb-1)+length(bcd)),-1);                    recover
 3671           return (answer);                                                         recover
 3672                                                                                    recover
 3673           end recover;                                                             recover
 
symbol table dump
 
symbol          type       loc   segment defined ref count
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 113
symbol          type       loc   segment defined ref count
 
answer          bit (9)   10591     data   3627       5
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 114
 line    source statement                                                               procedure and compiler information
 
 3674                                                                                   *
 3675                                                                                   *
 3676   compilation_loop:                                                               *
 3677     procedure;                                                                    *
 3678                                                                                    compilation_loop
 3679           declare overflow character initial (                                     compilation_loop
 3680           'stack overflow *** compilation aborted ***');                           compilation_loop
 3681           declare i fixed, j fixed, state fixed;                                   compilation_loop
 3682           declare end_of_file character initial (                                  compilation_loop
 3683           'end of file found unexpectedly *** compilation aborted ***');           compilation_loop
 3684                                                                                    compilation_loop
 3685           /*   this proc parses the input string (by calling the scanner)   */     compilation_loop
 3686           /*   and calls the code emission proc (synthesize) whenever a     */     compilation_loop
 3687           /*   production can be applied                                    */     compilation_loop
 3688                                                                                    compilation_loop
 3689           /*   initialize                                                   */     compilation_loop
 3690           compiling = TRUE;                                                        compilation_loop
 3691           state = START_STATE;                                                     compilation_loop
 3692           sp = -1;                                                                 compilation_loop
 3693           /*   stop compiling if finished                                   */     compilation_loop
 3694   comp:   do while (compiling);                                                    compilation_loop
 3695           /*   find which of the four kinds of states we are dealing with:  */     compilation_loop
 3696           /*   read,apply production,lookahead, or push state               */     compilation_loop
 3697           if state <= MAXR#                                                        compilation_loop
 3698                then do;   /*   read state   */                                     compilation_loop
 3699                     sp = sp+1;   /*   add an element to the stack   */             compilation_loop
 3700                     if sp = STACKSIZE                                              compilation_loop
 3701                          then do;                                                  compilation_loop
 3702                               call error (overflow,2);                             compilation_loop
 3703                               return;                                              compilation_loop
 3704                               end;                                                 compilation_loop
 3705                     state_stack(sp) = state;   /*   push present state   */        compilation_loop
 3706                     i = index1(state);         /*   get starting point   */        compilation_loop
 3707                     if no_look_ahead_done                                          compilation_loop
 3708                          then do;   /*   read if necessary   */                    compilation_loop
 3709                               call scan;                                           compilation_loop
 3710                               no_look_ahead_done = FALSE;                          compilation_loop
 3711                               end;                                                 compilation_loop
 3712                     /*   compare token with each transition symbol in    */        compilation_loop
 3713                     /*   read state                                      */        compilation_loop
 3714                      do i = i to i+index2(state)-1;                                compilation_loop
 3715                     if read1(i) = token                                            compilation_loop
 3716                          then do;   /*   found it   */                             compilation_loop
 3717                               var(sp) = bcd;                                       compilation_loop
 3718                               fixv(sp) = number_value;                             compilation_loop
 3719                               fixl(sp) = card_count;                               compilation_loop
 3720                               ppsave(sp) = pp;                                     compilation_loop
 3721                               state = read2(i);                                    compilation_loop
 3722                               no_look_ahead_done = TRUE;                           compilation_loop
 3723                               go to comp;                                          compilation_loop
 3724                               end;                                                 compilation_loop
 3725                     end;                                                           compilation_loop
 3726                     /*   found an error   */                                       compilation_loop
 3727                     call error ('illegal symbol pair: ' ||                         compilation_loop
 3728                                 vocab(state_name(state)) || x1 ||                  compilation_loop
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 115
 line    source statement                                                               procedure and compiler information
 
 3729                                 vocab(token),1);                                   compilation_loop
 3730                     call stack_dump;    /*  display the stack   */                 compilation_loop
 3731                     /*   try to recover   */                                       compilation_loop
 3732                     if recover                                                     compilation_loop
 3733                          then do;                                                  compilation_loop
 3734                               state = state_stack(sp);   /*   new starting pt  */  compilation_loop
 3735                               if state = 0                                         compilation_loop
 3736                                    then do;   /*   unexpected eofile   */          compilation_loop
 3737                                         call error (end_of_file,2);                compilation_loop
 3738                                         return;                                    compilation_loop
 3739                                         end;                                       compilation_loop
 3740                               end;                                                 compilation_loop
 3741                     sp = sp-1;   /*   stack at sp contains junk   */               compilation_loop
 3742                     end;                                                           compilation_loop
 3743                else                                                                compilation_loop
 3744           if state > MAXP#                                                         compilation_loop
 3745                then do;   /*   apply production state   */                         compilation_loop
 3746                     /*   sp points at right end of production   */                 compilation_loop
 3747                     /*   mp points at lest end of production   */                  compilation_loop
 3748                     mp = sp-index2(state);                                         compilation_loop
 3749                     mpp1 = mp+1;                                                   compilation_loop
 3750                     call synthesize (state-MAXP#);   /*   apply production   */    compilation_loop
 3751                     sp = mp;   /*   reset stack pointer   */                       compilation_loop
 3752                     i = index1(state);                                             compilation_loop
 3753                     /*   compare top of state stack with tables   */               compilation_loop
 3754                     j = state_stack(sp);                                           compilation_loop
 3755                     do while apply1(i) ~= 0;                                       compilation_loop
 3756                     if j = apply1(i) then go to top_match;                         compilation_loop
 3757                     i = i+1;                                                       compilation_loop
 3758                     end;                                                           compilation_loop
 3759                     /*   has the program goal been reached   */                    compilation_loop
 3760          top_match: if apply2(i) =0                                                compilation_loop
 3761                          then do;   /*   yes it has   */                           compilation_loop
 3762                               compiling = FALSE;                                   compilation_loop
 3763                               return;                                              compilation_loop
 3764                               end;                                                 compilation_loop
 3765                     state = apply2(i);   /*   pick up the next state   */          compilation_loop
 3766                     end;                                                           compilation_loop
 3767                else                                                                compilation_loop
 3768           if state <= MAXL#                                                        compilation_loop
 3769                then do;   /*   lookahead state   */                                compilation_loop
 3770                      i = index1(state);   /*   index into the table   */           compilation_loop
 3771                     if no_look_ahead_done                                          compilation_loop
 3772                          then do;   /*   get a token   */                          compilation_loop
 3773                               call scan;                                           compilation_loop
 3774                               no_look_ahead_done = FALSE;                          compilation_loop
 3775                               end;                                                 compilation_loop
 3776                     /*   check token against legal lookahead transition symbols*/  compilation_loop
 3777                     do while look1(i) ~= 0;                                        compilation_loop
 3778                     if look1(i) = token                                            compilation_loop
 3779                          then go to look_match;   /*   found one   */              compilation_loop
 3780                     i = i+1;                                                       compilation_loop
 3781                     end;                                                           compilation_loop
 3782         look_match: state = look2(i);                                              compilation_loop
 3783                     end;                                                           compilation_loop
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 116
 line    source statement                                                               procedure and compiler information
 
 3784                else do;   /*   push state   */                                     compilation_loop
 3785                     sp = sp+1;   /*   push a non-terminal onto the stack   */      compilation_loop
 3786                     if sp = STACKSIZE                                              compilation_loop
 3787                          then do;                                                  compilation_loop
 3788                               call error (overflow,2);                             compilation_loop
 3789                               return;                                              compilation_loop
 3790                               end;                                                 compilation_loop
 3791                     /*   push a state # into the state_stack   */                  compilation_loop
 3792                     state_stack(sp) = index2(state);                               compilation_loop
 3793                     /*   get next state                        */                  compilation_loop
 3794                     state = index1(state);                                         compilation_loop
 3795                     end;                                                           compilation_loop
 3796           end;   /*   of compile loop   */                                         compilation_loop
 3797                                                                                    compilation_loop
 3798           end compilation_loop;                                                    compilation_loop
 
symbol table dump
 
symbol          type       loc   segment defined ref count
comp            label     11377  program   3694       1
end_of_file     character   950   string   3682       1
i               fixed     10604     data   3681      19
j               fixed     10605     data   3681       2
look_match      label     11615  program   3779       1
overflow        character   949   string   3679       2
state           fixed     10606     data   3681      20
top_match       label     11562  program   3756       1
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 117
 line    source statement                                                               procedure and compiler information
 
 3799                                                                                   *
 3800  print_time:                                                                      *
 3801     procedure (text, time);                                                       *
 3802     /* print text followed by time, which is in milliseconds */                    print_time
 3803        declare text character, time fixed;                                         print_time
 3804        k = time;                                                                   print_time
 3805        i = k / 60000;                                                              print_time
 3806        j = k mod 60000 / 1000;                                                     print_time
 3807        k = k mod 1000;                                                             print_time
 3808        call printline (text || i || ':' || j || '.' || k,-1);                      print_time
 3809     end print_time;                                                                print_time
 
symbol table dump
 
symbol          type       loc   segment defined ref count
text            character   952   string   3801       1
time            fixed     10629     data   3801       1
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 118
 line    source statement                                                               procedure and compiler information
 
 3810                                                                                   *
 3811     /*   e x e c u t i o n   s t a r t s   h e r e                          */    *
 3812                                                                                   *
 3813     declare time_start fixed,                                                     *
 3814             time_init fixed,                                                      *
 3815             time_compile fixed,                                                   *
 3816             time_finish fixed;                                                    *
 3817                                                                                   *
 3818     time_start = runtime;           /* get time(cpu) started*/                    *
 3819     call initialize;                                                              *
 3820     time_init = runtime;     /* time to initialize */                             *
 3821     call compilation_loop;                                                        *
 3822     time_compile = runtime;     /* time to compile the program*/                  *
 3823     control(byte('E')) = FALSE;                                                   *
 3824     control(byte('B')) = FALSE;                                                   *
 3825     subtitle = '';                                                                *
 3826     if control(byte('S')) then call symboldump;                                   *
 3827     else EJECT_PAGE;                                                              *
 3828     /* now enter the value of ndescript                                        */ *
 3829     call emitlabel (ndesc,5);            /* generate label */                     *
 3830     if control(byte('A')) then                                                    *
 3831        output(DATAFILE) = '$' || ndesc || ':'; /* label for assembler */          *
 3832     call emitdataword (dsp-1);           /* put down number of desc's */          *
 3833     if control(byte('A')) then                                                    *
 3834        output(DATAFILE) = 's=.;';           /* start string segment */            *
 3835     /* add the descriptors to the data segment                                 */ *
 3836     do i = 0 to dsp-1;                                                            *
 3837        if control(byte('A')) then                                                 *
 3838           output(DATAFILE)='       byte (9)'||descl(i)|| '(27)' ||desca(i)|| ';'; *
 3839        call output_dataword (shl(descl(i),27) + desca(i), dp);                    *
 3840        call emitlabel (i,3);                                                      *
 3841        dp = dp + 1;                                                               *
 3842     end;                                                                          *
 3843     /* final code for system interface                                         */ *
 3844     call emitinst (4,0,0,0,0,0);                                                  *
 3845     call flush_data_buffer;                                                       *
 3846     call flush_labels;                                                            *
 3847     do while code_tail ~= code_head;                                              *
 3848        call output_codeword;                                                      *
 3849        end;                                                                       *
 3850     call output_codeword;                                                         *
 3851     call flush_code_buffer;                                                       *
 3852     if control(byte('A')) then                                                    *
 3853        do;                                                                        *
 3854           output (CODEFILE) = '       end $0;';                                   *
 3855           /* copy code file to end of data file */                                *
 3856           codestring = input(CODEFILE);                                           *
 3857           do while length(codestring) > 0;                                        *
 3858              output(DATAFILE) = codestring;                                       *
 3859              codestring = input(CODEFILE);                                        *
 3860           end;                                                                    *
 3861           output (CODEFILE) = ' ';                                                *
 3862        end;                                                                       *
 3863                                                                                   *
 3864     file(RELFILE) = SYMB_TYPE + 2;      /* generate external refs */              *
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 119
 line    source statement                                                               procedure and compiler information
 
 3865     file(RELFILE) = "(3)040000000000";                                            * c40 = 524288
 3866     file(RELFILE) = "(3)600000000000" + radix50 ('xpllib');                       * c41 = 4294967296
 3867     file(RELFILE) = library;                                                      * c42 = -17179869184
 3868     file(RELFILE) = START_TYPE + 1;                                               *
 3869     file(RELFILE) = "(3)200000000000";                                            * c43 = 1835008
 3870     file(RELFILE) = "(3)400000" + startloc;                                       *
 3871     file(RELFILE) = END_TYPE + 2;                                                 *
 3872     file(RELFILE) = "(3)240000000000";                                            *
 3873     file(RELFILE) = "(3)400000" + pp;                                             * c44 = 21474836480
 3874     file(RELFILE) = dp;                                                           *
 3875                                                                                   *
 3876     time_finish = runtime;   /* time to do all but final stats */                 *
 3877     call printline (substr(x70, 0, 40) || 'c o m p i l e r   s t a t i s t i c s',-1);*
 3878     call printline (card_count || ' lines containing ' || statement_count ||      * c45 = 5368709120
 3879        ' statements were compiled.',0);                                           *
 3880     if error_count = 0 then call printline ('no errors were detected.',-1);       *
 3881     else if error_count > 1 then                                                  *
 3882        call printline (error_count || ' errors (' || severe_errors                *
 3883        || ' severe) were detected.',-1);                                          *
 3884     else if severe_errors = 1 then call printline ('one severe error was detected.',-1);*
 3885        else call printline ('one error was detected.',-1);                        *
 3886      if previous_error > 0 then                                                   *
 3887         call printline ('last error was on line ' || previous_error ,-1);         *
 3888     call printline (pp || ' words of program, ' || dp-dsp || ' words of data, and ' ||*
 3889        dsp || ' words of descriptors.  total core requirement ' || pp+dp ||       *
 3890        ' words.',-1);                                                             *
 3891                                                                                   *
 3892  /* now compute times and print them */                                           *
 3893     time_init = time_init - time_start;                                           *
 3894     time_compile = time_compile - time_start;                                     *
 3895     time_finish = time_finish - time_start;                                       *
 3896                                                                                   *
 3897     call print_time ('total time in compiler    = ',time_finish);                 *
 3898     call print_time ('initialization time       = ',time_init);                   *
 3899     call print_time ('actual compilation time   = ',time_compile - time_init);    *
 3900     call print_time ('post-compilation clean-up = ',time_finish-time_compile);    *
 3901                                                                                   *
 3902     if control(byte('D')) then call dumpit;                                       *
 3903  eof eof eof eof eof eof eof eof eof eof eof eof eof eof eof eof eof eof eof eof  *
 
symbol table dump
 
symbol                type       loc   segment defined ref count
a                     fixed      1923     data    275      10
acc                   fixed      1929     data    280      43
add                   fixed      6253     data    400       9
addi                  fixed      6254     data    401       4
addm                  fixed      6255     data    402       2
addrmask              fixed      1927     data    277       5
adr                   fixed      2139     data    347      16
and                   fixed      6256     data    403       8
andi                  fixed      6257     data    404       3
aosa                  fixed      6258     data    405       1
apply1                bit (9)     932     data    126       2
apply2                bit (9)    1062     data    155       2
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 120
symbol                type       loc   segment defined ref count
 
arithemit             procedure  4907  program   1981       9
  parameter  1        fixed      9686     data   1981      21
  parameter  2        fixed      9687     data   1981      10
b                     fixed      1924     data    275       9
backmsg               character   750   string    537       4
backup                procedure  3747  program   1653       3
balance               character   103   string    236       8
base                  fixed      1691     data    230       3
bcd                   character    97   string    190      27
bchar                 procedure   920  program    710       2
blt                   fixed      6259     data    406       2
boolbranch            procedure  5099  program   2026       2
  parameter  1        fixed      9698     data   2026       7
  parameter  2        fixed      9699     data   2026       4
buffer                character   100   string    222      15
build_bcd             procedure   561  program    614       2
  parameter  1        bit (9)    9149     data    615       3
byteptrs              fixed      1906     data    258       6
c                     fixed      1925     data    275       3
calli                 fixed      6260     data    407       1
callsub               procedure  3694  program   1635       1
  parameter  1        fixed      9602     data   1635       2
  parameter  2        fixed      9603     data   1635       2
  parameter  3        fixed      9604     data   1635       4
calltype              fixed      1912     data    264       3
cam                   fixed      6261     data    408       5
camge                 fixed      6262     data    409       1
caml                  fixed      6263     data    410       1
camle                 fixed      6264     data    411       1
camn                  fixed      6265     data    412       2
card_count            fixed      1684     data    223      13
casep                 fixed      9095     data    533      12
casestack             fixed      8919     data    532       3
catentry              fixed      1909     data    261       2
ch                    fixed      1384     data    190       7
char                  procedure   894  program    695       7
chartype              bit (9)    1427     data    211       9
char_temp             character   259   string    462       7
check_string_overflow procedure  3681  program   1630       3
clearars              procedure  3199  program   1435       6
cmprhi                fixed      6266     data    413       2
cnt                   fixed      8712     data    524      36
code                  character   231   string    303       8
codemsg               character   748   string    535       4
codestring            character   235   string    309       4
code_buffer           fixed      1959     data    314       7
code_full             bit (9)    1954     data    304       7
code_head             fixed      1955     data    305      26
code_pp               fixed      2020     data    318       4
code_rbits            fixed      2024     data    319       4
code_rel              fixed      2016     data    317       4
code_tail             fixed      1956     data    306      13
compactify            procedure   128  program      0       1
compareswap           fixed      6304     data    451       1
compilation_loop      procedure 11371  program   3676       1
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 121
symbol                type       loc   segment defined ref count
 
compiling             fixed      1901     data    251       6
concatenate           fixed      1699     data    235       2
conflict              procedure 11246  program   3605       1
  parameter  1        fixed     10589     data   3605       3
control               bit (9)    1555     data    211      61
corebyteloc           fixed      1915     data    267       3
count_arith           fixed      1948     data    286       3
count_compact         fixed        33     data      0       3
count_force           fixed      1947     data    285       3
count_inst            fixed      1946     data    284       3
count_scan            fixed      1945     data    283       3
count_store           fixed      1949     data    287       3
cp                    fixed      1385     data    190      62
current_procedure     character   102   string    226       7
datacard              character   230   string    301      13
datamsg               character   749   string    536       5
data_buffer           fixed      1978     data    315       6
dctr                  fixed      2031     data    324      15
deblank               procedure   907  program    703       3
delete_move           procedure  3782  program   1663       8
  parameter  1        fixed      9605     data   1664      12
  parameter  2        fixed      9606     data   1664      11
  parameter  3        fixed      9607     data   1664      11
  parameter  4        fixed      9608     data   1664      10
  parameter  5        fixed      9609     data   1664      11
  parameter  6        fixed      9610     data   1664      10
  parameter  7        fixed      9611     data   1664      10
desca                 fixed      2147     data    352       3
descl                 fixed      3148     data    353       3
descref               fixed      4149     data    354       5
divide                fixed      1695     data    233       2
divide_code           procedure  5399  program   2109       2
  parameter  1        fixed      9711     data   2109       4
dloc                  fixed      2032     data    325       5
dp                    fixed      1957     data    307      60
dpb                   fixed      6267     data    414       3
dpoffset              fixed      1958     data    308      21
dptr                  fixed      2030     data    323      12
dsp                   fixed      5150     data    355      24
dumpit                procedure  6113  program   2294       1
emitblock             procedure  2007  program   1077       3
  parameter  1        fixed      9252     data   1078       5
emitbyte              procedure  2148  program   1103       4
  parameter  1        fixed      9261     data   1104       7
emitcodeword          procedure  2299  program   1133       1
  parameter  1        character   788   string   1133       2
  parameter  2        fixed      9477     data   1133       2
  parameter  3        fixed      9478     data   1133       2
emitconstant          procedure  2204  program   1114      10
  parameter  1        fixed      9266     data   1115      15
emitdataword          procedure  2073  program   1089      19
  parameter  1        fixed      9259     data   1090      21
emitdesc              procedure  2825  program   1307       7
  parameter  1        fixed      9513     data   1307       9
  parameter  2        fixed      9514     data   1307       9
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 122
symbol                type       loc   segment defined ref count
 
emitinst              procedure  2613  program   1231     219
  parameter  1        fixed      9495     data   1231     224
  parameter  2        fixed      9496     data   1231     221
  parameter  3        fixed      9497     data   1231     221
  parameter  4        fixed      9498     data   1231     226
  parameter  5        fixed      9499     data   1231     222
  parameter  6        fixed      9500     data   1231     222
emitlabel             procedure  2396  program   1160      13
  parameter  1        fixed      9480     data   1160      19
  parameter  2        fixed      9481     data   1160      18
emit_inline           procedure  3844  program   1694       2
  parameter  1        bit (9)    9612     data   1695       3
enter                 procedure  2921  program   1338       8
  parameter  1        character   812   string   1338      13
  parameter  2        fixed      9525     data   1338      11
  parameter  3        fixed      9526     data   1338      10
  parameter  4        fixed      9527     data   1338      10
eofile                fixed      1696     data    233       3
error                 procedure   431  program    581      56
  parameter  1        character   760   string    582      60
  parameter  2        fixed      9123     data    582      57
error_count           fixed      1685     data    223       5
expansion_count       fixed      1888     data    241       4
failsoft              fixed      1900     data    251       3
falseloc              fixed      1905     data    257       1
filemsg               character   751   string    538       2
findar                procedure  3210  program   1442      12
findlabel             procedure  2888  program   1322      11
fixl                  fixed      8865     data    528      78
fixv                  fixed      8763     data    526      58
flush_code_buffer     procedure  1634  program    953       3
flush_datacard        procedure  1940  program   1065       6
flush_data_buffer     procedure  1598  program    936       3
flush_labels          procedure  1843  program   1020       2
forceaccumulator      procedure  4037  program   1772      33
  parameter  1        fixed      9636     data   1772      67
forceaddress          procedure  3280  program   1475       1
  parameter  1        fixed      9568     data   1476       2
forcedescriptor       procedure  4502  program   1882      11
  parameter  1        fixed      9665     data   1883      21
for_count             fixed      2136     data    331      13
for_label             fixed      2085     data    330       6
for_ref               fixed      2034     data    329       7
freebase              fixed        32     data      0       2
freelimit             fixed        11     data      0       2
genstore              procedure  4569  program   1900       3
  parameter  1        fixed      9666     data   1900      20
  parameter  2        fixed      9667     data   1900      23
get_card              procedure   590  program    621       5
hash                  fixed      7868     data    512       9
hasher                procedure  2895  program   1330       5
  parameter  1        character   811   string   1331       8
hll                   fixed      6268     data    415       5
hlrz                  fixed      6269     data    416       1
hrli                  fixed      6270     data    417       2
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 123
symbol                type       loc   segment defined ref count
 
hrlm                  fixed      6271     data    418       1
hrrei                 fixed      6272     data    419       1
i                     fixed      6321     data    464     144
idcompares            fixed      6315     data    455       5
ident                 fixed      1692     data    233       3
idiv                  fixed      6273     data    420       1
idivi                 fixed      6274     data    421       1
idpb                  fixed      6275     data    422       3
idx                   fixed      8545     data    514       7
id_lookup             procedure  3089  program   1386       3
  parameter  1        fixed      9548     data   1387      12
ildb                  fixed      6276     data    423       3
imul                  fixed      6277     data    424       1
index1                fixed      1089     data    162       5
index2                bit (9)    1324     data    175       4
info                  character   258   string    461       8
initialize            procedure  6436  program   2348       1
instruct              fixed      5741     data    398       8
inx                   fixed      8661     data    523      53
ior                   fixed      6278     data    425       4
itype                 fixed      2140     data    348       4
i_format              procedure   351  program    545       6
  parameter  1        fixed      9111     data    546       7
  parameter  2        fixed      9112     data    546       8
i_string              character   260   string    463      12
j                     fixed      6322     data    464      46
jbase                 fixed      1690     data    230      10
jrst                  fixed      6279     data    426      12
jump                  fixed      6280     data    427       2
jumpe                 fixed      6281     data    428       2
jumpge                fixed      6282     data    429       1
jumpn                 fixed      6283     data    430       2
k                     fixed      6323     data    464      22
l                     fixed      6324     data    464       2
labelset              fixed      1697     data    234       1
label_buffer          fixed      1997     data    316       5
label_count           fixed      2033     data    326      10
label_gen             character   226   string    279       7
label_sink            fixed      1928     data    278       3
lb                    fixed      1700     data    236      12
ldb                   fixed      6284     data    431       2
lengthmask            fixed      1926     data    276       4
library               fixed      1919     data    271       2
library_call          procedure  3948  program   1727       5
  parameter  1        fixed      9627     data   1727       8
  parameter  2        fixed      9628     data   1727       7
  parameter  3        fixed      9629     data   1727       9
  parameter  4        fixed      9630     data   1727       9
library_save          fixed      1920     data    272       1
limitword             fixed      1916     data    268       3
line_count            fixed      1951     data    292      10
line_length           fixed      1688     data    225       3
look1                 bit (9)     914     data    120       2
look2                 bit (9)    1044     data    150       1
lsh                   fixed      6285     data    432      14
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 124
symbol                type       loc   segment defined ref count
 
lshc                  fixed      6286     data    433       7
macro_count           fixed      1765     data    239       6
macro_declare         fixed      1826     data    239       4
macro_index           bit (9)    1701     data    238       5
macro_name            character   104   string    237      11
macro_text            character   165   string    238       5
maxndecsy             fixed      6327     data    465       3
monitor_call          procedure  4005  program   1757       3
  parameter  1        fixed      9632     data   1757       4
  parameter  2        fixed      9634     data   1757       5
  parameter  3        fixed      9633     data   1757       4
move                  fixed      6287     data    434      34
movei                 fixed      6288     data    435      21
movem                 fixed      6289     data    436      19
mover                 fixed      1913     data    265       3
movestacks            procedure  3246  program   1462       9
  parameter  1        fixed      9566     data   1463      17
  parameter  2        fixed      9567     data   1463      17
movm                  fixed      6290     data    437       1
movn                  fixed      6291     data    438       2
mp                    fixed      8917     data    529     252
mpp1                  fixed      8918     data    529     112
ndecsy                fixed      6326     data    465      38
ndesc                 fixed      1918     data    270       4
newdp                 fixed      2141     data    349      10
newdpoffset           fixed      2143     data    349       6
newdsp                fixed      2142     data    349       4
nmbrentry             fixed      1910     data    262       2
not_letter_or_digit   bit (9)    1619     data    212       4
no_look_ahead_done    bit (9)    1902     data    254       7
number                fixed      1694     data    233       3
number_value          fixed      1689     data    230       8
olddp                 fixed      2144     data    350       4
olddpoffset           fixed      2146     data    350       4
olddsp                fixed      2145     data    350       2
opname                character   237   string    357       2
orsymbol              fixed      1698     data    235       2
outputlabel           procedure  2374  program   1152       2
  parameter  1        fixed      9479     data   1153       3
output_codeword       procedure  1760  program    994       5
output_dataword       procedure  1880  program   1040       3
  parameter  1        fixed      9248     data   1041       5
  parameter  2        fixed      9249     data   1041       6
page_count            fixed      1950     data    291       4
parct                 fixed      6328     data    465      18
pointer               character    99   string    198       4
pop                   fixed      6292     data    439       2
popj                  fixed      6293     data    440      13
pp                    fixed      1953     data    302      42
ppsave                fixed      8814     data    527      12
previous_error        fixed      1687     data    224       5
printline             procedure   374  program    556      50
  parameter  1        character   752   string    557      52
  parameter  2        fixed      9114     data    557      54
print_time            procedure 11653  program   3800       4
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 125
symbol                type       loc   segment defined ref count
 
  parameter  1        character   952   string   3801       5
  parameter  2        fixed     10629     data   3801       5
procmark              fixed      6325     data    465      21
proc_start            procedure  3473  program   1542       4
psbits                fixed      1907     data    259       6
ptr                   fixed      8124     data    513       9
push                  fixed      6294     data    441       2
pushj                 fixed      6295     data    442      10
pword                 fixed      2137     data    332       4
radix50               procedure  1670  program    970       2
  parameter  1        character   777   string    971       6
rctr                  fixed      2029     data    322      15
read1                 bit (9)     829     data    105       2
read2                 bit (9)     959     data    132       1
reading               bit (9)    1952     data    300       4
recover               procedure 11279  program   3625       1
refcheck              procedure  2554  program   1201       3
  parameter  1        fixed      9486     data   1202      12
reg                   fixed      8610     data    522     123
reserved_limit        fixed      1426     data    201       3
restore_acs           procedure  3444  program   1532       4
  parameter  1        fixed      9591     data   1533       6
returned_type         fixed      6329     data    466      13
rot                   fixed      6296     data    443       4
rptr                  fixed      2028     data    321      13
s                     character   236   string    356      21
save_acs              procedure  3419  program   1523       4
  parameter  1        fixed      9588     data   1524       5
scan                  procedure   988  program    729       6
setca                 fixed      6297     data    444       1
setinit               procedure  3307  program   1486       2
setlimit              procedure  5242  program   2063       2
setzm                 fixed      6298     data    445       2
severe_errors         fixed      1686     data    224       5
shift_code            procedure  5511  program   2151       2
  parameter  1        fixed      9723     data   2152       4
shouldcommute         procedure  4851  program   1974       2
skip                  fixed      6299     data    446       1
skipe                 fixed      6300     data    447       1
sojg                  fixed      6301     data    448       3
source                character   229   string    295      11
sp                    fixed      8916     data    529      97
stack_dump            procedure  8740  program   2736       2
startloc              fixed      2138     data    333       2
statement_count       fixed      6314     data    454       4
state_name            bit (9)     804     data     93       2
state_stack           bit (9)    8546     data    520       7
stepk                 fixed      1922     data    274       3
stillcond             fixed      6312     data    452       5
stillinzero           fixed      6313     data    453      11
stopit                bit (9)    1889     data    251       7
str                   fixed      1921     data    273       4
strcomp               fixed      1911     data    263       2
string                fixed      1693     data    233       5
stringcompare         procedure  5585  program   2176       4
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 126
symbol                type       loc   segment defined ref count
 
string_check          fixed      1908     data    260       2
string_recover        fixed      1914     data    266       5
stuff_parameter       procedure  5279  program   2078       2
sub                   fixed      6302     data    449       5
subi                  fixed      6303     data    450       6
subtitle              character   228   string    290      11
symboldump            procedure  5678  program   2197       2
synthesize            procedure  8801  program   2755       1
  parameter  1        fixed     10479     data   2756       2
syt                   character   276   string    490      28
sytcard               fixed      7447     data    510       4
sytco                 fixed      7026     data    509      14
sytloc                fixed      6499     data    504      26
sytseg                bit (9)    6920     data    507      18
sytype                bit (9)    6393     data    497      34
target_register       fixed      1903     data    255      11
tdeclare              procedure  3519  program   1551       2
  parameter  1        fixed      9595     data   1552       3
text                  character   101   string    222      44
text_limit            fixed      1683     data    222      18
time_compile          fixed     10633     data   3815       5
time_finish           fixed     10634     data   3816       5
time_init             fixed     10632     data   3814       5
time_start            fixed     10631     data   3813       4
title                 character   227   string    289       5
token                 fixed      1383     data    190      18
top_macro             fixed      1887     data    240      10
trueloc               fixed      1904     data    256       3
tsa                   fixed      1917     data    269      12
tx                    bit (9)    1491     data    211       2
type                  fixed      8559     data    521      80
typename              character   261   string    480       2
undeclared_id         procedure  3156  program   1416       2
  parameter  1        fixed      9551     data   1417       9
var                   character   697   string    525      27
vocab                 character     5   string     71      10
x1                    character   253   string    456      18
x2                    character   254   string    457       4
x3                    character   255   string    458       2
x4                    character   256   string    459       5
x7                    character   257   string    460       4
x70                   character    98   string    196      19
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 127
 
 
                                        c o m p i l e r   s t a t i s t i c s
 
3903 lines containing 2090 statements were compiled.
no errors were detected.
12136 words of program, 10761 words of data, and 981 words of descriptors.  total core requirement 23878 words.
total time in compiler    = 1:13.356
initialization time       = 0:0.71
actual compilation time   = 0:58.663
post-compilation clean-up = 0:14.622
 
macro definitions:
 
name             at line ref count literal value
P#                   91        0    109
TRUE                194       27    "1"
BUSY                281        8    1
MAXR#                57        2    99
MAXL#                59        1    125
MAXP#                61        2    125
MAXS#                63        2    234
RSIZE                99        2    337
LSIZE               101        2    69
ASIZE               103        2    105
FALSE               194       24    "0"
AVAIL               281       35    0
VOCAB#               69        2    91
dx_size               0        2    500
VERSION              53        1    '4.0'
FOREVER             195        4    while TRUE
RELFILE             298       25    4
LIBFILE             299        2    5
FOR_MAX             328        3    50
CHRTYPE             471       18    6
SPECIAL             476       25    11
SYTSIZE             489       10    420
PAGE_MAX            293        4    54
DATAFILE            296       22    2
CODEFILE            297        7    3
END_TYPE            339        1    "(3)5000000"
VARIABLE            469       13    3
CONSTANT            470       18    4
BYTETYPE            473        6    8
DESCRIPT            475       12    10
PROCTYPE            478        5    13
TERMINAL#            67        7    42
CODE_TYPE           336        2    "(3)1000000"
SYMB_TYPE           337        1    "(3)2000000"
NAME_TYPE           340        1    "(3)6000000"
DESCLIMIT           351        4    1000
LABELTYPE           467        3    1
FIXEDTYPE           472       17    7
STACKSIZE           519       11    50
CASELIMIT           531        2    175
EJECT_PAGE          294        3    line_count = PAGE_MAX+1
BUFFERSIZE          313        7    18
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 128
name             at line ref count literal value
 
HISEG_TYPE          338        1    "(3)3000000"
START_TYPE          341        1    "(3)7000000"
START_STATE          65        1    1
MACRO_LIMIT         237        5    60
INTREQ_TYPE         342        1    "(3)10000000"
ACCUMULATOR         468       16    2
FORWARDTYPE         474        7    9
FORWARDCALL         477        6    12
CHARPROCTYPE        479        7    14
EXPANSION_LIMIT     241        1    300
 
id compares       = 8188
symbol table size = 410
macro definitions = 52
scan              = 26322
emitinst          = 13005
force ACCUMULATOR = 5946
arithemit         = 862
generate store    = 1026
free string area  = 14160
compactifications = 153
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 129
instruction frequencies
 
.init.    1
.inpt.    6
.outp.    41
.exit.    3
.filo.    24
.name.    6
calli     6
ildb      3
ldb       158
idpb      3
dpb       65
move      3163
movei     252
movem     2540
movn      3
movm      1
imuli     11
idivi     18
rot       4
lsh       311
lshc      7
blt       2
jrst      714
pushj     952
push      62
pop       62
popj      137
add       114
addi      308
addm      2
sub       71
subi      80
cail      14
caie      175
caile     7
caige     14
cain      37
caig      54
caml      16
came      21
camle     62
camge     6
camn      7
camg      8
jump      1
jumpe     106
jumpa     284
jumpge    1
jumpn     2
skipe     18
skipge    1
skipn     1
skipg     2
aosa      52
sojg      3
 
xcom.xpl  compiled 12-may-1977  at 22:34:47 by VERSION 4.0                               page 130
instruction frequencies
 
setzm     838
and       79
andi      328
ior       70
setca     7
hll       5
hrli      2
hrlm      1
hlrz      1
hrrei     783
