 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by version 4.0                             page 1
 line    source statement                                                               procedure and compiler information
 
    1   /*                                                                              *
    2                                p d p - 1 0   x p l                                *
    3                                v e r s i o n   1                                  *
    4        a compiler-compiler for programming language 1.                            *
    5                                                 richard l. bisbey ii              *
    6                                                 july 1971                         *
    7                                                                                   *
    8  version 4.0        november 1975.                                                *
    9                                                                                   *
   10        verion 4 of the compiler processes the entire xpl grammar.                 *
   11                                                                                   *
   12  version 3.0        november, 1975.                                               *
   13                                                                                   *
   14        version 3.0 contains the following differences from version 2.0:           *
   15        relocatable binary code output,                                            *
   16        call inline facility implemented,                                          *
   17        uuos used to call the run-time routines,                                   *
   18        some switches can be specified from the terminal,                          *
   19        "compactify" is compiled from a source library,                            *
   20        redundant saves of procedure results in other registers is                 *
   21           avoided in most instances.                                              *
   22                                                                                   *
   23        version 2.0                                                                *
   24        hash-coded symbol table,                                                   *
   25        left-to-right generation of strings from numbers,                          *
   26        special case checks in string catenation routine,                          *
   27        faster, more efficient procedure calls,                                    *
   28        general input/output, file, filename procedures,                           *
   29        better listing, symbol dump format, etc.                                   *
   30                                                                                   *
   31               r. w. hay,                                                          *
   32               computer group,                                                     *
   33               dept. of electrical eng.,                                           *
   34               university of toronto,                                              *
   35               toronto, ontario, canada.                                           *
   36                                                                                   *
   37                                                                                   *
   38        the main structure of the program is as follows:                           *
   39              contents.                                                            *
   40              recognition tables for the syntax analyzer.                          *
   41              declaration of scanner/compiler variables.                           *
   42              storage compactification procedure.                                  *
   43              scanner procedures.                                                  *
   44              parser procedures.                                                   *
   45              code/data emitter procedures.                                        *
   46              symbol table procedures.                                             *
   47              code generation procedures.                                          *
   48              initialization procedure.                                            *
   49              analysis algorithm.                                                  *
   50              production rules.                                                    *
   51     */                                                                            *
   52                                                                                   *
   53     declare VERSION literally '''4.0''';                                          *
   54                                                                                   *
   55           /*   these are lalr parsing tables   */                                 *
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 2
 line    source statement                                                               procedure and compiler information
 
   56                                                                                   *
   57           declare MAXR# literally '99'; /* max read # */                          *
   58                                                                                   *
   59           declare MAXL# literally '125'; /* max look # */                         *
   60                                                                                   *
   61           declare MAXP# literally '125'; /* max push # */                         *
   62                                                                                   *
   63           declare MAXS# literally '234'; /* max state # */                        *
   64                                                                                   *
   65           declare START_STATE literally '1';                                      *
   66                                                                                   *
   67           declare TERMINAL# literally '42'; /* # of terminals */                  *
   68                                                                                   *
   69           declare VOCAB# literally '91';                                          *
   70                                                                                   *
   71           declare vocab(VOCAB#) character initial ('','<','(','+','|','&','*',')' *
   72           ,';','~','-','/',',','>',':','=','||','by','do','go','if','to','bit'    *
   73           ,'end','eof','mod','call','case','else','goto','then','fixed','label'   *
   74           ,'while','return','declare','initial','<number>','<string>','character' *
   75           ,'literally','procedure','<identifier>','<term>','<type>','<go to>'     *
   76           ,'<group>','<ending>','<primary>','<program>','<replace>','<bit head>'  *
   77           ,'<constant>','<relation>','<variable>','<if clause>','<left part>'     *
   78           ,'<statement>','<true part>','<assignment>','<bound head>'              *
   79           ,'<expression>','<group head>','<if statement>','<initial head>'        *
   80           ,'<initial list>','<while clause>','<case selector>','<call statement>' *
   81           ,'<logical factor>','<parameter head>','<parameter list>'               *
   82           ,'<procedure head>','<procedure name>','<statement list>'               *
   83           ,'<subscript head>','<basic statement>','<go to statement>'             *
   84           ,'<identifier list>','<logical primary>','<step definition>'            *
   85           ,'<label definition>','<return statement>','<type declaration>'         *
   86           ,'<iteration control>','<logical secondary>','<string expression>'      *
   87           ,'<declaration element>','<procedure definition>'                       *
   88           ,'<arithmetic expression>','<declaration statement>'                    *
   89           ,'<identifier specification>');                                         *
   90                                                                                   *
   91           declare P# literally '109'; /* # of productions */                      *
   92                                                                                   *
   93           declare state_name(MAXR#) bit(8) initial (0,0,1,2,3,3,4,5,6,7,9,9,10,10 *
   94           ,11,12,13,16,17,18,19,20,21,22,23,25,26,27,33,34,35,36,37,37,40,42,42   *
   95           ,42,42,42,43,43,43,43,43,44,44,45,46,50,50,51,52,53,54,54,55,56,58,59   *
   96           ,60,61,61,61,61,61,61,61,61,61,61,62,64,66,67,68,69,69,70,71,72,73,74   *
   97           ,74,75,76,77,78,80,81,81,82,83,86,86,88,89,89,90,91);                   *
   98                                                                                   *
   99           declare RSIZE literally '337'; /*  read states info  */                 *
  100                                                                                   *
  101           declare LSIZE literally '69'; /* look ahead states info */              *
  102                                                                                   *
  103           declare ASIZE literally '105'; /* apply production states info */       *
  104                                                                                   *
  105           declare read1(RSIZE) bit(8) initial (0,8,18,19,20,26,29,34,35,42,15,2,3 *
  106           ,9,10,37,38,42,2,37,38,42,2,37,38,42,2,3,9,10,37,38,42,2,3,9,10,37,38   *
  107           ,42,2,37,38,42,22,31,32,39,2,3,10,37,38,42,1,13,15,2,37,38,42,2,37,38   *
  108           ,42,2,37,38,42,2,42,15,2,3,10,37,38,42,2,3,9,10,37,38,42,8,27,33,42,21  *
  109           ,2,3,9,10,37,38,42,2,3,9,10,37,38,42,2,42,2,37,38,42,42,2,3,9,10,37,38  *
  110           ,42,2,3,9,10,37,38,42,2,3,9,10,37,38,42,2,42,2,7,7,38,2,14,2,40,7,12,7  *
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 3
 line    source statement                                                               procedure and compiler information
 
  111           ,12,6,11,25,6,11,25,6,11,25,6,11,25,6,11,25,8,8,42,8,2,3,9,10,37,38,42  *
  112           ,2,3,9,10,37,38,42,37,7,12,2,3,10,37,38,42,12,15,15,8,18,19,20,26,29,34 *
  113           ,35,42,42,8,18,19,20,26,29,34,35,42,8,37,4,30,4,4,7,12,4,4,4,7,4,4,21,4 *
  114           ,17,4,8,18,19,20,23,26,29,34,35,42,37,38,8,8,8,5,5,42,8,22,31,32,39,8   *
  115           ,18,19,20,26,29,34,35,42,2,8,22,31,32,39,8,18,19,20,24,26,29,34,35,42,8 *
  116           ,18,19,20,23,26,29,34,35,42,2,3,9,10,37,38,42,28,8,42,8,8,18,19,20,26   *
  117           ,29,34,35,41,42,8,18,19,20,23,26,29,34,35,41,42,8,36,1,9,13,15,16,16,8  *
  118           ,3,10,3,10,8,12,2,22,31,32,39);                                         *
  119                                                                                   *
  120           declare look1(LSIZE) bit(8) initial (0,15,0,15,0,42,0,8,0,2,14,0,2,0,40 *
  121           ,0,6,11,25,0,6,11,25,0,6,11,25,0,6,11,25,0,6,11,25,0,4,0,4,0,4,0,4,0,8  *
  122           ,0,4,0,5,0,5,0,28,0,36,0,1,9,13,15,16,0,16,0,3,10,0,3,10,0);            *
  123                                                                                   *
  124           /*  push states are built-in to the index tables  */                    *
  125                                                                                   *
  126           declare apply1(ASIZE) bit(8) initial (0,0,80,0,56,58,71,82,83,0,56,89   *
  127           ,90,0,89,90,0,0,0,0,0,0,0,0,0,0,0,0,0,0,83,90,0,71,83,90,0,0,0,0,0,0,15 *
  128           ,0,0,9,79,99,0,0,0,0,0,0,0,57,0,55,0,0,3,18,22,27,28,29,49,50,84,0,6,0  *
  129           ,7,0,10,0,0,53,0,17,0,4,5,12,13,0,8,14,25,0,1,19,26,56,57,58,71,80,82   *
  130           ,83,89,90,0,0,72,0);                                                    *
  131                                                                                   *
  132           declare read2(RSIZE) bit(8) initial (0,138,19,20,21,26,174,103,30,104   *
  133           ,213,3,4,10,12,234,233,105,3,234,233,105,3,234,233,105,3,4,10,12,234    *
  134           ,233,105,3,4,10,12,234,233,105,3,234,233,105,23,182,184,183,3,4,12,234  *
  135           ,233,105,211,212,210,3,234,233,105,3,234,233,105,3,234,233,105,190,106  *
  136           ,214,3,4,12,234,233,105,3,4,10,12,234,233,105,146,27,28,105,173,3,4,10  *
  137           ,12,234,233,105,3,4,10,12,234,233,105,186,166,3,234,233,105,105,3,4,10  *
  138           ,12,234,233,105,3,4,10,12,234,233,105,3,4,10,12,234,233,105,190,106,193 *
  139           ,9,185,178,231,168,231,34,189,191,162,164,8,14,25,8,14,25,8,14,25,8,14  *
  140           ,25,8,14,25,158,160,172,132,3,4,10,12,234,233,105,3,4,10,12,234,233,105 *
  141           ,33,192,194,3,4,12,234,233,105,198,197,197,138,19,20,21,26,174,103,30   *
  142           ,104,105,138,19,20,21,26,174,103,30,104,131,32,6,143,6,6,230,232,6,6,6  *
  143           ,228,6,6,22,6,18,6,138,19,20,21,102,26,174,103,30,104,234,233,148,149   *
  144           ,135,7,7,39,159,23,182,184,183,138,19,20,21,26,174,103,30,104,163,157   *
  145           ,23,182,184,183,138,19,20,21,126,26,174,103,30,104,138,19,20,21,102,26  *
  146           ,174,103,30,104,3,4,10,12,234,233,105,144,136,38,147,138,19,20,21,26    *
  147           ,174,103,30,161,104,138,19,20,21,102,26,174,103,30,161,104,134,31,100   *
  148           ,11,101,207,17,17,133,5,13,5,13,137,15,187,23,182,184,183);             *
  149                                                                                   *
  150           declare look2(LSIZE) bit(8) initial (0,2,208,16,209,24,165,169,29,35,35 *
  151           ,229,36,229,37,188,40,40,40,217,41,41,41,220,42,42,42,221,43,43,43,218  *
  152           ,44,44,44,219,62,170,64,155,65,154,67,195,152,69,70,153,76,199,77,200   *
  153           ,85,129,92,177,93,93,93,93,93,205,94,206,96,96,215,97,97,216);          *
  154                                                                                   *
  155           declare apply2(ASIZE) bit(8) initial (0,0,83,82,140,141,150,128,128,127 *
  156           ,120,139,139,129,142,142,130,56,58,48,71,88,151,73,74,95,80,81,79,78    *
  157           ,156,167,145,90,90,90,89,91,75,86,47,98,176,175,121,180,46,179,45,51,60 *
  158           ,99,87,181,72,196,59,50,49,57,66,117,116,113,114,112,115,68,63,61,119   *
  159           ,118,202,201,204,203,53,123,122,125,124,108,110,109,111,107,223,224,225 *
  160           ,222,54,55,171,54,54,54,54,54,54,54,54,54,227,84,52,226);               *
  161                                                                                   *
  162           declare index1(MAXS#) bit(16) initial (0,1,10,11,18,22,26,33,40,44,48   *
  163           ,54,57,61,65,69,71,72,78,85,89,90,97,104,105,106,110,111,118,125,132    *
  164           ,134,135,136,137,138,140,141,142,144,146,149,152,155,158,161,162,163    *
  165           ,164,165,172,179,180,182,188,190,191,200,201,210,211,212,214,215,218    *
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 4
 line    source statement                                                               procedure and compiler information
 
  166           ,219,220,222,223,225,227,228,238,240,241,242,243,244,245,246,251,260    *
  167           ,266,276,286,293,294,295,296,297,307,318,319,320,325,326,327,329,331    *
  168           ,333,1,3,5,7,9,12,14,16,20,24,28,32,36,38,40,42,44,46,48,50,52,54,56,62 *
  169           ,64,67,1,2,2,4,4,10,10,10,10,10,10,10,10,10,14,14,14,17,18,19,20,20,20  *
  170           ,20,20,21,22,22,23,24,25,26,26,26,26,27,28,29,29,30,30,30,33,37,37,38   *
  171           ,39,40,40,41,41,42,42,44,44,44,45,45,45,45,49,50,51,51,52,52,53,54,54   *
  172           ,55,55,57,59,60,60,70,70,72,72,74,74,76,76,76,76,76,76,76,76,77,77,79   *
  173           ,79,79,79,79,81,81,81,81,86,86,86,90,90,103,103,104,104);               *
  174                                                                                   *
  175           declare index2(MAXS#) bit(8) initial (0,9,1,7,4,4,7,7,4,4,6,3,4,4,4,2,1 *
  176           ,6,7,4,1,7,7,1,1,4,1,7,7,7,2,1,1,1,1,2,1,1,2,2,3,3,3,3,3,1,1,1,1,7,7,1  *
  177           ,2,6,2,1,9,1,9,1,1,2,1,3,1,1,2,1,2,2,1,10,2,1,1,1,1,1,1,5,9,6,10,10,7,1 *
  178           ,1,1,1,10,11,1,1,5,1,1,2,2,2,5,2,2,2,2,3,2,2,4,4,4,4,4,2,2,2,2,2,2,2,2  *
  179           ,2,2,6,2,3,3,1,0,1,0,0,1,1,1,1,1,1,1,0,1,1,2,1,2,1,1,1,2,2,2,1,3,1,3,1  *
  180           ,1,2,1,2,2,3,1,2,0,2,0,1,1,1,0,1,1,1,1,0,1,2,0,2,1,3,1,0,0,0,2,1,1,0,2  *
  181           ,0,2,2,1,2,2,1,0,1,0,2,0,2,0,1,0,2,0,0,0,1,1,1,1,1,0,2,0,2,2,1,1,0,2,2  *
  182           ,2,0,0,2,0,2,1,2,0,0);                                                  *
  183                                                                                   *
  184                                                                                   *
  185     /*  declarations for the scanner                                        */    *
  186     /* token is the index into the vocabulary v() of the last symbol scanned,     *
  187        cp is the pointer to the last character scanned in the cardimage,          *
  188        bcd is the last symbol scanned (literal character string). */              *
  189                                                                                   *
  190     declare token fixed, bcd character, ch fixed, cp fixed;                       *
  191                                                                                   *
  192     /* set up some convenient abbreviations for printer control */                *
  193                                                                                   *
  194     declare TRUE literally '"1"', FALSE literally '"0"',                          *
  195        FOREVER literally 'while TRUE',                                            *
  196        x70 character initial ('                                                   *
  197                                ');                                                *
  198     declare pointer character initial    ('                                       *
  199                                                             |');                  *
  200     /* length of longest symbol in v */                                           *
  201     declare reserved_limit fixed;                                                 *
  202                                                                                   *
  203     /* chartype() is used to distinguish classes of symbols in the scanner.       *
  204        tx() is a table used for translating from one character set to another.    *
  205        control() holds the value of the compiler control toggles set in $ cards.  *
  206        not_letter_or_digit() is similiar to chartype() but used in scanning       *
  207        identifiers only.                                                          *
  208                                                                                   *
  209        all are used by the scanner and control() is set there.                    *
  210     */                                                                            *
  211     declare chartype(255) bit(8), tx(255) bit(8), control(255) bit(1),            *
  212        not_letter_or_digit(255) bit(1);                                           *
  213     /* buffer holds the latest cardimage,                                         *
  214        text holds the present state of the input text                             *
  215        (not including the portions deleted by the scanner),                       *
  216        text_limit is a convenient place to store the pointer to the end of text,  *
  217        card_count is incremented by one for every source card read,               *
  218        error_count tabulates the errors as they are detected,                     *
  219        severe_errors tabulates those errors of fatal significance.                *
  220        current_procedure contains the name of the procedure being processed.      *
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 5
 line    source statement                                                               procedure and compiler information
 
  221        procedure_depth contains the current number of procedures nested.          *
  222        alphabet contains the abc's in upper case                                  *
  223     */                                                                            *
  224     declare alphabet character initial ('abcdefghijklmnopqrstuvwxyz');            *
  225     declare buffer character, text character, text_limit fixed,                   *
  226         card_count fixed, error_count fixed,                                      *
  227         severe_errors fixed, previous_error fixed,                                *
  228         line_length  fixed,         /* length of source statement */              *
  229         current_procedure character,                                              *
  230         procedure_depth fixed;                                                    *
  231                                                                                   *
  232     /* number_value contains the numeric value of the last constant scanned,      *
  233     */                                                                            *
  234     declare number_value fixed, jbase fixed, base fixed;                          *
  235     /* each of the following contains the index into v() of the corresponding     *
  236        symbol.   we ask:    if token = ident    etc.    */                        *
  237     declare ident fixed, string fixed, number fixed, divide fixed, eofile fixed,  *
  238        labelset fixed;                                                            *
  239     declare orsymbol fixed, concatenate fixed;                                    *
  240     declare balance character, lb fixed ;                                         *
  241     declare MACRO_LIMIT literally '60', macro_name (MACRO_LIMIT) character,       *
  242        macro_text(MACRO_LIMIT) character, macro_index (255) bit (8),              *
  243        macro_count (MACRO_LIMIT) fixed, macro_declare (MACRO_LIMIT) fixed,        *
  244        top_macro fixed;                                                           *
  245     declare expansion_count fixed, EXPANSION_LIMIT literally '300';               *
  246     /* stopit() is a table of symbols which are allowed to terminate the error    *
  247        flush process.  in general they are symbols of sufficient syntactic        *
  248        hierarchy that we expect to avoid attempting to start checking again       *
  249        right into another error producing situation.  the token stack is also     *
  250        flushed down to something acceptable to a stopit() symbol.                 *
  251        failsoft is a bit which allows the compiler one attempt at a gentle        *
  252        recovery.   then it takes a strong hand.   when there is real trouble      *
  253        compiling is set to FALSE, thereby terminating the compilation.            *
  254     */                                                                            *
  255     declare stopit(TERMINAL#) bit(1), failsoft fixed, compiling fixed;            *
  256     /*   the following switch is used by the lalr parser   */                     *
  257                                                                                   *
  258     declare no_look_ahead_done bit(1);                                            *
  259     declare target_register fixed;       /* for findar */                         *
  260     declare trueloc fixed;               /* location of constant 1 */             *
  261     declare falseloc fixed;              /* location of constant 0 */             *
  262     declare byteptrs fixed,              /* location of 4 ptrs for ldb & dpb */   *
  263             psbits fixed;                /* byte ptrs fore move */                *
  264     declare string_check fixed,          /* compactify caller */                  *
  265             catentry fixed,              /* catenation subroutine */              *
  266             nmbrentry fixed,             /* number to string subroutine */        *
  267             strcomp fixed,               /* string compare subroutine */          *
  268             calltype fixed initial (1),  /* dist between sub & function */        *
  269             mover fixed,                 /* string move subroutine */             *
  270             string_recover fixed,        /* syt location of compactify */         *
  271             corebyteloc fixed,           /* syt location of corebyte */           *
  272             limitword fixed,             /* address of freelimit */               *
  273             tsa fixed;                   /* address of freepoint */               *
  274     declare ndesc fixed;                 /* address of ndescript               */ *
  275     declare library fixed,               /* address of runtime library */         *
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 6
 line    source statement                                                               procedure and compiler information
 
  276             library_save fixed,          /* place to store r11 on lib calls */    *
  277             str  fixed;                  /* descriptor of last string */          *
  278     declare stepk fixed;                 /* used for do loops */                  *
  279     declare a fixed, b fixed, c fixed;   /* for catenation & conversion */        *
  280     declare lengthmask fixed;            /* addr of dv length mask */             *
  281     declare addrmask fixed;              /* address of "fffff" */                 *
  282     declare label_sink fixed initial(0); /* for label generator */                *
  283     declare label_gen character;         /* contains label for next inst*/        *
  284     declare acc(15) fixed;               /* keeps track of accumulators */        *
  285     declare AVAIL literally '0', BUSY literally '1';                              *
  286      /* call counts of important procedures */                                    *
  287     declare count_scan fixed, /* scan               */                            *
  288              count_inst fixed,  /* emitinst           */                          *
  289              count_force fixed, /* forceaccumulator   */                          *
  290              count_arith fixed, /* arithemit          */                          *
  291              count_store fixed; /* genstore           */                          *
  292                                                                                   *
  293     declare title        character,     /*title line for listing */               *
  294             subtitle     character,     /*subtitle for listing */                 *
  295             page_count   fixed,         /*current page number for listing*/       *
  296             line_count   fixed,         /*number of lines printed */              *
  297             PAGE_MAX literally '54',    /*max no of lines on page*/               *
  298             EJECT_PAGE literally 'line_count = PAGE_MAX+1';                       *
  299     declare source character;           /*file name being compiled*/              *
  300     declare DATAFILE literally '2';     /* scratch file for data */               *
  301     declare CODEFILE literally '3';     /* scratch file for code */               *
  302     declare RELFILE  literally '4';     /* binary output file */                  *
  303     declare LIBFILE  literally '5';     /* source library file */                 *
  304     declare reading  bit(1);            /* 0 iff reading LIBFILE */               *
  305     declare datacard character;         /* data buffer */                         *
  306     declare pp      fixed,              /* current program pointer */             *
  307             code(3) character,           /* the code buffer */                    *
  308             code_full(3) bit(1),         /* fullness flag */                      *
  309             code_head fixed,             /* front of buffer */                    *
  310             code_tail fixed,             /* end of buffer */                      *
  311             dp      fixed,              /* current data pointer */                *
  312             dpoffset fixed;             /* current dp byte offset */              *
  313     declare codestring character;     /*for copying code into data file*/         *
  314                                                                                   *
  315     /*   the following are for relocatable binary code emission */                *
  316                                                                                   *
  317     declare BUFFERSIZE literally '18';   /* size of binary buffers */             *
  318     declare code_buffer (BUFFERSIZE) fixed;   /*code (high) buffer */             *
  319     declare data_buffer (BUFFERSIZE) fixed;   /* data (low) buffer */             *
  320     declare label_buffer (BUFFERSIZE) fixed;  /* labels defined buffer */         *
  321     declare code_rel(3) fixed,         /* binary code buffer (see code) */        *
  322             code_pp(3) fixed,                                                     *
  323             code_rbits(3) fixed;                                                  *
  324                                                                                   *
  325     declare rptr fixed,                  /* pointer to code_buffer */             *
  326             rctr fixed,                  /* counter for code_buffer */            *
  327             dptr fixed,                   /* pointer to data_buffer */            *
  328             dctr fixed,                  /* counter for data_buffer */            *
  329             dloc fixed;                   /* location of next word in data buffer */*
  330     declare label_count fixed;            /*no of labels in label_buffer */       *
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 7
 line    source statement                                                               procedure and compiler information
 
  331                                                                                   *
  332     declare FOR_MAX  literally '50';      /* maximum forward references */        *
  333     declare for_ref   (FOR_MAX) fixed,    /* forward referenced labels */         *
  334             for_label (FOR_MAX) fixed,    /* label referenced */                  *
  335             for_count fixed;              /* count of current forward refs */     *
  336     declare pword fixed;                  /* part-word acc. for bytes*/           *
  337     declare startloc fixed;               /* first instruction to be executed */  *
  338                                                                                   *
  339                                                                                   *
  340     declare CODE_TYPE literally '"(3)1000000"';   /* code & data type block */    *
  341     declare SYMB_TYPE literally '"(3)2000000"';   /* symbol defn type block */    *
  342     declare HISEG_TYPE literally '"(3)3000000"';  /* high segment type block */   *
  343     declare END_TYPE literally '"(3)5000000"';    /* end type block */            *
  344     declare NAME_TYPE literally '"(3)6000000"';   /* name type block */           *
  345     declare START_TYPE literally '"(3)7000000"';  /* start address type block */  *
  346     declare INTREQ_TYPE literally '"(3)10000000"'; /* internal request type block */*
  347                                                                                   *
  348                                                                                   *
  349     /* end of definitions for relocatable binary files */                         *
  350                                                                                   *
  351     declare adr     fixed;                                                        *
  352     declare itype fixed;                                                          *
  353     declare newdp fixed, newdsp fixed, newdpoffset fixed; /* for allocation */    *
  354     declare olddp fixed, olddsp fixed, olddpoffset fixed; /* for allocation */    *
  355     declare DESCLIMIT literally '1000', /* number of string descriptors */        *
  356             desca (DESCLIMIT) fixed,     /* string descriptor address */          *
  357             descl (DESCLIMIT) fixed,     /* string descriptor length */           *
  358             descref (DESCLIMIT) fixed,    /* last reference to string */          *
  359             dsp     fixed;              /* descriptor pointer */                  *
  360     declare s character;                                                          *
  361     declare opname (15) character initial (                                       *
  362  '      .init..inpt..outp..exit.      .fili..filo..name.',                        *
  363  'call  init  uuo042uuo043uuo044uuo045uuo046calli open  ttcalluuo052uuo053uuo054  *
  364  renamein    out   setstsstato getstsstatz inbuf outbufinput outputclose          *
  365  releasmtape ugetf useti useto lookupenter ',                                     *
  366  'uuo100uuo101uuo102uuo103uuo104uuo105uuo106uuo107uuo110uuo111uuo112uuo113uuo114u *
  367  uo115uuo116uuo117uuo120uuo121uuo122uuo123uuo124uuo125uuo126uuo127ufa   dfn   fsc *
  368     ibp   ildb  ldb   idpb  dpb   ',                                              *
  369  '',                                                                              *
  370  'move  movei movem moves movs  movsi movsm movss movn  movni movnm movns movm  m *
  371  ovmi movmm movms imul  imuli imulm imulb mul   muli  mulm  mulb  idiv  idivi idi *
  372  vm idivb div   divi  divm  divb  ',                                              *
  373  'ash   rot   lsh   jffo  ashc  rotc  lshc  ......exch  blt   aobjp aobjn jrst  j *
  374  fcl  xct   ......pushj push  pop   popj  jsr   jsp   jsa   jra   add   addi  add *
  375  m  addb  sub   subi  subm  subb  ',                                              *
  376  'cai   cail  caie  caile caia  caige cain  caig  cam   caml  came  camle cama  c *
  377  amge camn  camg  jump  jumpl jumpe jumplejumpa jumpgejumpn jumpg skip  skipl ski *
  378  pe skipleskipa skipgeskipn skipg ',                                              *
  379   'aoj   aojl  aoje  aojle aoja  aojge aojn  aojg  aos   aosl  aose  aosle aosa  a*
  380  osge aosn  aosg  soj   sojl  soje  sojle soja  sojge sojn  sojg  sos   sosl  sos *
  381  e  sosle sosa  sosge sosn  sosg  ',                                              *
  382  'setz  setzi setzm setzb and   andi  anmd  andb  andca andcaiandcamandcabsetm  s *
  383  etmi setmm setmb andcm andcmiandcmmandcmbseta  setai setam setab xor   xori  xor *
  384  m  xorb  ior   iori  iorm  iorb  ',                                              *
  385  'andcb andcbiandcbmandcbbeqv   eqvi  eqvm  eqvb  setca setcaisetcamsetcaborca  o *
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 8
 line    source statement                                                               procedure and compiler information
 
  386  rcai orcam orcab setcm setcmisetcmmsetcmborcm  orcmi orcmm orcmb orcb  orcbi orc *
  387  bm orcbb seto  setoi setom setob ',                                              *
  388  'hll   hlli  hllm  hlls  hrl   hrli  hrlm  hrls  hllz  hllzi hllzm hllzs hrlz  h *
  389  rlzi hrlzm hrlzs hllo  hlloi hllom hllos hrlo  hrloi hrlom hrlos hlle  hllei hll *
  390  em hlles hrle  hrlei hrlem hrles ',                                              *
  391  'hrr   hrri  hrrm  hrrs  hlr   hlri  hlrm  hlrs  hrrz  hrrzi hrrzm hrrzs hlrz  h *
  392  lrzi hlrzm hlrzs hrro  hrroi hrrom hrros hlro  hlroi hlrom hlros hrre  hrrei hrr *
  393  em hrres hlre  hlrei hlrem hlres ',                                              *
  394  'trn   tln   trne  tlne  trna  tlna  trnn  tlnn  tdn   tsn   tdne  tsne  tdna  t *
  395  sna  tdnn  tsnn  trz   tlz   trze  tlze  trza  tlza  trzn  tlzn  tdz   tsz   tdz *
  396  e  tsze  tdza  tsza  tdzn  tszn  ',                                              *
  397  'trc   tlc   trce  tlce  trca  tlca  trcn  tlcn  tdc   tsc   tdce  tsce  tdca  t *
  398  sca  tdcn  tscn  tro   tlo   troe  tloe  troa  tloa  tron  tlon  tdo   tso   tdo *
  399  e  tsoe  tdoa  tsoa  tdon  tson  ',                                              *
  400  '',                                                                              *
  401  '');                                                                             *
  402     declare instruct(511) fixed;         /* count of the instructions issued */   *
  403           /* commonly used opcodes */                                             *
  404     declare add    fixed initial ("(3)270"),                                      *
  405             addi   fixed initial ("(3)271"),                                      *
  406             addm   fixed initial ("(3)272"),                                      *
  407             and    fixed initial ("(3)404"),                                      *
  408             andi   fixed initial ("(3)405"),                                      *
  409             aosa   fixed initial ("(3)354"),                                      *
  410             blt    fixed initial ("(3)251"),                                      *
  411             calli  fixed initial ("(3)047"),                                      *
  412             cam    fixed initial ("(3)310"),                                      *
  413             camge  fixed initial ("(3)315"),                                      *
  414             caml   fixed initial ("(3)311"),                                      *
  415             camle  fixed initial ("(3)313"),                                      *
  416             camn   fixed initial ("(3)316"),                                      *
  417             cmprhi fixed initial ("(3)317"),                                      *
  418             dpb    fixed initial ("(3)137"),                                      *
  419             hll    fixed initial ("(3)500"),                                      *
  420             hlrz   fixed initial ("(3)554"),                                      *
  421             hrli   fixed initial ("(3)505"),                                      *
  422             hrlm   fixed initial ("(3)506"),                                      *
  423             hrrei  fixed initial ("(3)571"),                                      *
  424             idiv   fixed initial ("(3)230"),                                      *
  425             idivi  fixed initial ("(3)231"),                                      *
  426             idpb   fixed initial ("(3)136"),                                      *
  427             ildb   fixed initial ("(3)134"),                                      *
  428             imul   fixed initial ("(3)220"),                                      *
  429             ior    fixed initial ("(3)434"),                                      *
  430             jrst   fixed initial ("(3)254"),                                      *
  431             jump   fixed initial ("(3)320"),                                      *
  432             jumpe  fixed initial ("(3)322"),                                      *
  433             jumpge fixed initial ("(3)325"),                                      *
  434             jumpn  fixed initial ("(3)326"),                                      *
  435             ldb    fixed initial ("(3)135"),                                      *
  436             lsh    fixed initial ("(3)242"),                                      *
  437             lshc   fixed initial ("(3)246"),                                      *
  438             move   fixed initial ("(3)200"),                                      *
  439             movei  fixed initial ("(3)201"),                                      *
  440             movem  fixed initial ("(3)202"),                                      *
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 9
 line    source statement                                                               procedure and compiler information
 
  441             movm   fixed initial ("(3)214"),                                      *
  442             movn   fixed initial ("(3)210"),                                      *
  443             pop    fixed initial ("(3)262"),                                      *
  444             popj   fixed initial ("(3)263"),                                      *
  445             push   fixed initial ("(3)261"),                                      *
  446             pushj  fixed initial ("(3)260"),                                      *
  447             rot    fixed initial ("(3)241"),                                      *
  448             setca  fixed initial ("(3)450"),                                      *
  449             setzm  fixed initial ("(3)402"),                                      *
  450             skip   fixed initial ("(3)330"),                                      *
  451             skipe  fixed initial ("(3)332"),                                      *
  452             sojg   fixed initial ("(3)367"),                                      *
  453             sub    fixed initial ("(3)274"),                                      *
  454             subi   fixed initial ("(3)275");                                      *
  455     declare compareswap (7) fixed initial (0,7,2,5,0,3,6,1);                      *
  456     declare stillcond fixed,            /* peep hole for bool branching */        *
  457             stillinzero fixed;          /* peephole for redundant moves */        *
  458     declare statement_count fixed;      /* a count of the xpl statements */       *
  459     declare idcompares fixed;                                                     *
  460     declare x1 character initial (' ');                                           *
  461     declare x2 character initial ('  ');                                          *
  462     declare x3 character initial ('   ');                                         *
  463     declare x4 character initial ('    ');                                        *
  464     declare x7 character initial ('       ');                                     *
  465     declare info character;         /* for listing information*/                  *
  466     declare char_temp character;                                                  *
  467     declare i_string character;      /* for i_format */                           *
  468     declare i fixed, j fixed, k fixed, l fixed;                                   *
  469     declare procmark fixed, ndecsy fixed, maxndecsy fixed, parct fixed;           *
  470     declare returned_type fixed;                                                  *
  471     declare LABELTYPE     literally  '1',                                         *
  472             ACCUMULATOR   literally  '2',                                         *
  473             VARIABLE      literally  '3',                                         *
  474             CONSTANT      literally  '4',                                         *
  475             CHRTYPE       literally  '6',                                         *
  476             FIXEDTYPE     literally  '7',                                         *
  477             BYTETYPE      literally  '8',                                         *
  478             FORWARDTYPE   literally  '9',                                         *
  479             DESCRIPT      literally '10',                                         *
  480             SPECIAL       literally '11',                                         *
  481             FORWARDCALL   literally '12',                                         *
  482             PROCTYPE      literally '13',                                         *
  483             CHARPROCTYPE  literally '14';                                         *
  484     declare typename (14) character initial ('', 'label    ', '', '', '', '',     *
  485             'character', 'fixed    ', 'bit (9)  ' , '', '', '', '',               *
  486             'procedure','character procedure');                                   *
  487     /*  the symbol table is initialized with the names of all                     *
  488         builtin functions and pseudo variables.  the procedure                    *
  489         initialize depends on the order and placement of these                    *
  490         names.  changes should be made observing due caution to                   *
  491         avoid messing things up.                                                  *
  492     */                                                                            *
  493     declare SYTSIZE literally '420';     /* the symbol table size */              *
  494     declare syt (SYTSIZE) character      /* the VARIABLE name */                  *
  495        initial ('coreword', 'corebyte', 'freepoint', 'descriptor',                *
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 10
 line    source statement                                                               procedure and compiler information
 
  496           'ndescript',   'length', 'substr', 'byte', 'shl', 'shr',                *
  497           'input', 'output', 'file', 'inline', 'trace', 'untrace',                *
  498           'exit', 'time', 'date', 'clock_trap', 'interrupt_trap',                 *
  499           'monitor', 'addr', 'runtime', 'filename',                               *
  500           'compactify', 'freelimit', 'freebase');                                 *
  501     declare sytype (SYTSIZE) bit (8)     /* type of VARIABLE */                   *
  502        initial (FIXEDTYPE, BYTETYPE, FIXEDTYPE, FIXEDTYPE,                        *
  503           FIXEDTYPE, SPECIAL, SPECIAL, SPECIAL, SPECIAL, SPECIAL,                 *
  504           SPECIAL, SPECIAL, SPECIAL, SPECIAL, SPECIAL, SPECIAL,                   *
  505            SPECIAL, SPECIAL, SPECIAL, SPECIAL, SPECIAL,                           *
  506           SPECIAL, SPECIAL, SPECIAL, SPECIAL,                                     *
  507           FORWARDCALL, FIXEDTYPE, FIXEDTYPE);                                     *
  508     declare sytloc (SYTSIZE) fixed       /* location of VARIABLE */               *
  509        initial (0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,     *
  510            0,0,0);                                                                *
  511     declare sytseg (SYTSIZE) bit(8)      /* segment of VARIABLE */                *
  512        initial (0,0,1,3,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,1,1);         *
  513     declare sytco (SYTSIZE) fixed;       /* a count of references */              *
  514     declare sytcard (SYTSIZE) fixed;     /* where symbol is defined */            *
  515                                                                                   *
  516     declare hash (255)      fixed,       /* hash table into symbol table*/        *
  517             ptr  (SYTSIZE)  fixed,       /* points to next symbol in hash*/       *
  518             idx             fixed;       /* index while using hash*/              *
  519                                                                                   *
  520     /*  the compiler stacks declared below are used to drive the syntactic        *
  521        analysis algorithm and store information relevant to the interpretation    *
  522        of the text.  the stacks are all pointed to by the stack pointer sp.  */   *
  523     declare STACKSIZE literally '50';  /* size of stack  */                       *
  524     declare state_stack (STACKSIZE)  bit (8);                                     *
  525     declare type        (STACKSIZE)  fixed;                                       *
  526     declare reg         (STACKSIZE)  fixed;                                       *
  527     declare inx         (STACKSIZE)  fixed;                                       *
  528     declare cnt         (STACKSIZE)  fixed;                                       *
  529     declare var         (STACKSIZE)  character;                                   *
  530     declare fixv        (STACKSIZE)  fixed;                                       *
  531     declare ppsave      (STACKSIZE)  fixed;                                       *
  532     declare fixl        (STACKSIZE)  fixed;                                       *
  533     declare sp fixed, mp fixed, mpp1 fixed;                                       *
  534                                                                                   *
  535     declare CASELIMIT literally '175',                                            *
  536             casestack (CASELIMIT) fixed, /* contains addr of stmts of case */     *
  537             casep  fixed;                /* points to current casestack entry */  *
  538                                                                                   *
  539     declare codemsg  character initial ('code = '),                               *
  540             datamsg  character initial ('data = '),                               *
  541             backmsg  character initial ('back up code emitter'),                  *
  542             filemsg  character initial ('missing number for file');               *
  543                                                                                   *
  544                                                                                   *
  545  /*                                                                               *
  546            g l o b a l   p r o c e d u r e s                                      *
  547  */                                                                               *
  548                                                                                   *
  549  i_format:                                                                        *
  550     procedure (number, width);                                                    *
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 11
 line    source statement                                                               procedure and compiler information
 
  551     declare number  fixed,                                                         i_format
  552             width   fixed;                                                         i_format
  553     declare l       fixed;                                                         i_format
  554     i_string = number;                                                             i_format
  555     l = length (i_string);                                                         i_format
  556     if l < width then                                                              i_format
  557           i_string = substr(x70,0,width-l) || i_string;                            i_format
  558     end  i_format;                                                                 i_format
 
symbol table dump
 
symbol          type       loc   segment defined ref count
l               fixed      9121     data    553       3
number          fixed      9119     data    550       1
width           fixed      9120     data    550       2
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 12
 line    source statement                                                               procedure and compiler information
 
  559                                                                                   *
  560  printline:                                                                       *
  561     procedure (line, ind);                                                        *
  562     declare line character,             /*line to be printed */                    printline
  563             ind fixed;                  /*format indicator*/                       printline
  564     declare ctl(5) character initial ('0','1','','','','');                        printline
  565     declare skips (5) fixed initial (2,99,0,0,0,0);                                printline
  566     if line_count > PAGE_MAX then                                                  printline
  567        do;                                                                         printline
  568           page_count = page_count + 1;                                             printline
  569           output(1) = title || page_count;                                         printline
  570           output = subtitle;                                                       printline
  571           output = ' ';                                                            printline
  572           line_count = 0;                                                          printline
  573        end;                                                                        printline
  574     if ind < 0 | ind > 5 then                                                      printline
  575        do;                                                                         printline
  576           output = line;                                                           printline
  577           line_count = line_count + 1;                                             printline
  578        end;                                                                        printline
  579     else                                                                           printline
  580        do;                                                                         printline
  581           output(1) = ctl(ind) || line;                                            printline
  582           line_count = line_count + skips(ind);                                    printline
  583        end;                                                                        printline
  584  end printline;                                                                    printline
 
symbol table dump
 
symbol          type       loc   segment defined ref count
ctl             character   754   string    564       1
ind             fixed      9122     data    561       4
line            character   753   string    561       2
skips           fixed      9124     data    565       1
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 13
 line    source statement                                                               procedure and compiler information
 
  585     error:                                                                        *
  586        procedure (msg, severity);                                                 *
  587     /* print the error message with a pointer pointing to the current token        error
  588        being scanned.  if source listing is disabled, also print the current       error
  589        source image.                                                               error
  590     */                                                                             error
  591        declare msg character, severity fixed;                                      error
  592        declare i fixed;                                                            error
  593        error_count = error_count + 1;                                              error
  594        if control(byte('L')) = 0 then                                              error
  595           do;                                                                      error
  596              i = 5 - length(card_count);                                           error
  597              call printline (substr (x70, 0, i) || card_count || x4 || buffer,-1); error
  598           end;                                                                     error
  599        call printline (substr(pointer,length(pointer)-7-                           error
  600              (line_length+cp-text_limit-lb-1)),-1);                                error
  601                                                                                    error
  602        output(-1) = card_count || x4 || buffer;                                    error
  603        output(-1) = x7 || msg;                                                     error
  604                                                                                    error
  605        if previous_error > 0 then                                                  error
  606           msg = msg || '. last previous error was on line ' || previous_error;     error
  607        call printline ('*** error. ' || msg,-1);                                   error
  608        previous_error = card_count;                                                error
  609        if severity > 0 then                                                        error
  610           if severe_errors > 25 then                                               error
  611              do;                                                                   error
  612                  call printline ('*** too many severe errors, compilation aborted ***',0); error
  613                  compiling = FALSE;                                                error
  614               end;                                                                 error
  615             else severe_errors = severe_errors + 1;                                error
  616     end error;                                                                     error
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9132     data    592       2
msg             character   761   string    586       4
severity        fixed      9131     data    586       1
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 14
 line    source statement                                                               procedure and compiler information
 
  617     /*                the scanner procedures              */                      *
  618     build_bcd:                                                                    *
  619        procedure (c);                                                             *
  620        declare c bit(9);                                                           build_bcd
  621        if length(bcd) > 0 then bcd = bcd || x1;                                    build_bcd
  622        else bcd = substr(x1 || x1, 1);                                             build_bcd
  623        corebyte(freepoint-1) = c;                                                  build_bcd c5 = 134217727
  624     end build_bcd;                                                                 build_bcd
 
symbol table dump
 
symbol          type       loc   segment defined ref count
c               bit (9)    9157     data    619       1
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 15
 line    source statement                                                               procedure and compiler information
 
  625     get_card:                                                                     *
  626        procedure;                                                                 *
  627        /* does all card reading and listing                                 */     get_card
  628        declare i fixed, tempo character, temp2 character;                          get_card
  629        if lb ~= 0 then                                                             get_card
  630           do;                                                                      get_card
  631              if cp >= 255 then                                                     get_card
  632                 do;                                                                get_card
  633                    text = substr(text, lb);                                        get_card
  634                    cp = cp - lb;                                                   get_card
  635                    call error ('identifier too long', 0);                          get_card
  636                 end;                                                               get_card
  637                 if lb > 255 - cp then i = 255 - cp;                                get_card
  638                 else i = lb;                                                       get_card
  639                 lb = lb - i;                                                       get_card
  640                 text = text || substr(balance, 0, i);                              get_card
  641                 balance = substr(balance, i);                                      get_card
  642                 text_limit = length(text) - 1;                                     get_card
  643                 return;                                                            get_card
  644           end;                                                                     get_card
  645        expansion_count = 0;    /* checked in scanner  */                           get_card
  646        if reading then   /* reading is FALSE initially, to read library */         get_card
  647           do;                                                                      get_card
  648              buffer = input;                                                       get_card
  649              if length(buffer) = 0 then                                            get_card
  650                 do;                                                                get_card
  651                    call error ('eof missing', 0);                                  get_card
  652                    buffer = ' /* '' /* */ eof; end; eof; end; eof';                get_card
  653                 end;                                                               get_card
  654              else card_count = card_count + 1;                                     get_card
  655           end;                                                                     get_card
  656        else                                                                        get_card
  657           do;                                                                      get_card
  658              buffer = input(LIBFILE);                                              get_card
  659              if length(buffer) = 0 then                                            get_card
  660                 do;                                                                get_card
  661                    reading = TRUE;                                                 get_card
  662                    buffer = input;                                                 get_card
  663                    card_count = card_count + 1;                                    get_card
  664                    statement_count = 0;                                            get_card
  665                    control(byte('L')) = TRUE & ~ control(byte('K'));               get_card
  666                 end;                                                               get_card
  667           end;                                                                     get_card
  668        line_length = length (buffer);                                              get_card
  669        if cp + length(buffer) > 255 then                                           get_card
  670           do;                                                                      get_card
  671              i = 255 - cp;                                                         get_card
  672              text = text || substr(buffer, 0, i);                                  get_card
  673              balance = substr(buffer, i);                                          get_card
  674              lb = length(balance);                                                 get_card
  675           end;                                                                     get_card
  676        else text = text || buffer;                                                 get_card
  677        text_limit = length(text) - 1;                                              get_card
  678        if control(byte('M')) then call printline(buffer,-1);                       get_card
  679        else if control(byte('L')) then                                             get_card
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 16
 line    source statement                                                               procedure and compiler information
 
  680           do;                                                                      get_card
  681              tempo = card_count;                                                   get_card
  682              i = 5 - length (tempo);                                               get_card
  683              tempo = substr(x70, 0, i) || tempo || x2 || buffer;                   get_card
  684              i = 0;                                                                get_card
  685              do while i <= length(tempo);                                          get_card
  686                 if byte(tempo,i) = 9 then /* expand tab char */                    get_card
  687                    do;                                                             get_card
  688                    tempo = substr(tempo,0,i) || substr(x70,0,9-(i mod 8))          get_card
  689                            || substr(tempo,i+1);                                   get_card
  690                    i = i + 9-(i mod 8);                                            get_card
  691                    end;                                                            get_card
  692                 else                                                               get_card
  693                    i = i + 1;                                                      get_card
  694                 end;                                                               get_card
  695              i = 88 - length(tempo);                                               get_card
  696              if i >= 70 then                                                       get_card
  697                 do;                                                                get_card
  698                    i = i - 70;                                                     get_card
  699                    tempo = tempo || x70;                                           get_card
  700                 end;                                                               get_card
  701              if i > 0 then tempo = tempo || substr(x70, 0, i);                     get_card
  702              temp2 = current_procedure || info;                                    get_card
  703              if control(byte('F')) then                                            get_card
  704                     temp2 = x2 || pp || x1 || dp || x1 || dsp || temp2;            get_card
  705              if length (temp2) > 44 then temp2 = substr (temp2,0,44);              get_card
  706              call printline (tempo || temp2,-1);                                   get_card c6 = 5905580032
  707           end;                                                                     get_card
  708        info = '';           /* clear information buffer */                         get_card
  709     end get_card;                                                                  get_card
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9159     data    628      27
temp2           character   766   string    628       7
tempo           character   765   string    628      15
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 17
 line    source statement                                                               procedure and compiler information
 
  710     char:                                                                         *
  711        procedure;                                                                 *
  712        cp = cp + 1;                                                                char
  713        if cp <= text_limit then return;                                            char
  714        cp = 0;                                                                     char
  715        text = '';                                                                  char
  716        call get_card;                                                              char
  717     end char;                                                                      char
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 18
 line    source statement                                                               procedure and compiler information
 
  718     deblank:                                                                      *
  719        procedure;                                                                 *
  720        call char;                                                                  deblank
  721        do while byte (text, cp) = byte (' ');                                      deblank
  722           call char;                                                               deblank
  723        end;                                                                        deblank
  724     end deblank;                                                                   deblank
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 19
 line    source statement                                                               procedure and compiler information
 
  725     bchar:                                                                        *
  726        procedure;                                                                 *
  727        do FOREVER;                                                                 bchar
  728           call deblank;                                                            bchar
  729           ch = byte(text, cp);                                                     bchar
  730           if ch ~= byte ('(') then return;                                         bchar
  731           /*  (base width)  */                                                     bchar
  732            call deblank;                                                           bchar
  733           jbase = byte (text, cp) - byte ('0');  /* width */                       bchar
  734           if jbase < 1 | jbase > 4 then                                            bchar
  735              do;                                                                   bchar
  736                 call error ('illegal bit string width: ' || substr(text,cp,1),0);  bchar
  737                 jbase = 4;  /* default width for error */                          bchar c7 = 134217728
  738              end;                                                                  bchar
  739           base = shl(1, jbase);                                                    bchar
  740           call deblank;                                                            bchar
  741          if byte(text,cp)~=byte(')')then call error('missing ) in bit string',0);  bchar
  742        end;                                                                        bchar
  743     end bchar;                                                                     bchar
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 20
 line    source statement                                                               procedure and compiler information
 
  744                                                                                   *
  745     lowup:       /* convert s to upper case */                                    *
  746       procedure (s) character;                                                    *
  747       declare (s,t) character;                                                     lowup
  748       t = '';                                                                      lowup
  749       do i = 0 to length(s)-1;                                                     lowup
  750          if byte(s,i) > 96 then                                                    lowup
  751             t = t || substr(alphabet,byte(s,i)-97,1);                              lowup
  752          else                                                                      lowup
  753             t = t || substr(s,i,1);                                                lowup
  754          end;                                                                      lowup
  755       return t;                                                                    lowup
  756       end lowup;                                                                   lowup
 
symbol table dump
 
symbol          type       loc   segment defined ref count
s               character   772   string    746       4
t               character   773   string    747       6
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 21
 line    source statement                                                               procedure and compiler information
 
  757                                                                                   *
  758     scan:                                                                         *
  759        procedure;     /* get the next token from the text  */                     *
  760        declare s1 fixed, s2 fixed;                                                 scan
  761     declare lstrngm character initial ('string too long');                         scan
  762     declare lbitm character initial ('bit string too long');                       scan
  763      count_scan = count_scan + 1;                                                  scan
  764        failsoft = TRUE;                                                            scan
  765        bcd = '';  number_value = 0;                                                scan
  766     rescan:                                                                        scan
  767        if cp > text_limit then                                                     scan
  768           do;                                                                      scan
  769              text = '';                                                            scan
  770              call get_card;                                                        scan
  771           end;                                                                     scan
  772        else                                                                        scan
  773           do;                                                                      scan
  774              text_limit = text_limit - cp;                                         scan
  775              text = substr(text, cp);                                              scan
  776           end;                                                                     scan
  777        cp = 0;                                                                     scan
  778     /*  branch on next character in text                  */                       scan
  779        do case chartype(byte(text));                                               scan
  780           /*  case 0  */                                                           scan case 0.
  781           /* illegal characters fall here  */                                      scan
  782           call error ('illegal character: ' || substr (text, 0, 1) ||              scan
  783              '  (' || byte(text) || ')', 0);                                       scan
  784           /*  case 1  */                                                           scan case 1.
  785           /*  blank  */                                                            scan
  786           do cp = 1 to text_limit;                                                 scan
  787              if byte (text, cp) ~= byte (' ') then goto rescan;                    scan
  788           end;                                                                     scan
  789           /*  case 2  */                                                           scan case 2.
  790           do FOREVER;   /* string quote ('):  character string       */            scan
  791              token = string;                                                       scan
  792              do cp = cp + 1 to text_limit;                                         scan
  793                 if byte (text, cp) = byte ('''') then                              scan
  794                    do;                                                             scan
  795                       if length(bcd) + cp > 257 then                               scan
  796                          do;                                                       scan
  797                             call error (lstrngm, 0);                               scan
  798                             return;                                                scan
  799                          end;                                                      scan
  800                       if cp > 1 then                                               scan
  801                       bcd = bcd || substr(text, 1, cp-1);                          scan
  802                       call char;                                                   scan
  803                        if byte (text, cp) = byte ('''') then                       scan
  804                           if length(bcd) = 255 then                                scan
  805                             do;                                                    scan
  806                               call error (lstrngm, 0);                             scan
  807                               return;                                              scan
  808                             end;                                                   scan
  809                          else                                                      scan
  810                             do;                                                    scan
  811                                bcd = bcd || substr(text, cp, 1);                   scan
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 22
 line    source statement                                                               procedure and compiler information
 
  812                                go to rescan;                                       scan
  813                             end;                                                   scan
  814                       return;                                                      scan
  815                    end;                                                            scan
  816              end;                                                                  scan
  817              /*  we have run off a card  */                                        scan
  818              if length(bcd) + cp > 257 then                                        scan
  819                 do;                                                                scan
  820                   call error (lstrngm, 0);                                         scan
  821                   return;                                                          scan
  822                 end;                                                               scan
  823              if cp > 1 then bcd = bcd || substr(text, 1, cp-1);                    scan
  824              text = x1;                                                            scan
  825              cp = 0;                                                               scan
  826              call get_card;                                                        scan
  827           end;                                                                     scan
  828           /*  case 3  */                                                           scan case 3.
  829           do;      /*  bit quote("):  bit string  */                               scan
  830              jbase = 4;  base = 16;  /* default width */                           scan
  831              token = number;                                                       scan
  832              s1 = 0;                                                               scan
  833              call bchar;                                                           scan
  834              do while ch ~= byte ('"');                                            scan
  835                 s1 = s1 + jbase;                                                   scan
  836                 if ch >= byte ('0') & ch <= byte ('9') then s2 = ch - byte ('0');  scan
  837                 else s2 = ch + 10 - byte ('a');                                    scan
  838                 if s2 >= base | s2 < 0 then                                        scan
  839                    call error ('illegal character in bit string: '                 scan
  840                    || substr(text, cp, 1), 0);                                     scan
  841                 if s1 > 36 then token = string;                                    scan
  842                 if token = string then                                             scan
  843                    do while s1 - jbase >= 9;                                       scan
  844                       if length(bcd) >= 255 then                                   scan
  845                          do;                                                       scan
  846                             call error ( lbitm, 0);                                scan
  847                             return;                                                scan
  848                          end;                                                      scan
  849                       s1 = s1 - 9;                                                 scan
  850                       call build_bcd (shr(number_value, s1-jbase));                scan
  851                    end;                                                            scan
  852                 number_value = shl(number_value, jbase) + s2;                      scan
  853                 call bchar;                                                        scan
  854              end;     /* of do while ch...  */                                     scan
  855              cp = cp + 1;                                                          scan
  856              if token = string then                                                scan
  857                 if length(bcd) >= 255 then call error (lbitm,0);                   scan
  858                 else call build_bcd (shl(number_value, 9 - s1));                   scan
  859               return;                                                              scan
  860           end;                                                                     scan
  861           /*  case 4  */                                                           scan case 4.
  862           do FOREVER;   /*  a letter:  identifiers and reserved words  */          scan
  863              do cp = cp + 1 to text_limit;                                         scan
  864                 if not_letter_or_digit(byte(text, cp)) then                        scan
  865                    do;  /* end of identifier  */                                   scan
  866                       bcd = lowup(substr(text, 0, cp));                            scan
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 23
 line    source statement                                                               procedure and compiler information
 
  867                       if cp > 1 then if cp <= reserved_limit then                  scan
  868                          /* check for reserved words */                            scan
  869                          do i = 1 to TERMINAL#;                                    scan
  870                             if bcd = vocab(i) then                                 scan c8 = 42
  871                                do;                                                 scan
  872                                   token = i;                                       scan
  873                                   return;                                          scan
  874                                end;                                                scan
  875                          end;                                                      scan
  876                       do i = macro_index(cp-1) to macro_index(cp) - 1;             scan
  877                          if bcd = macro_name(i) then                               scan
  878                             do;                                                    scan
  879                              macro_count(i) = macro_count(i) + 1;                  scan
  880                                bcd = macro_text(i);                                scan
  881                                if expansion_count < EXPANSION_LIMIT then           scan
  882                                   expansion_count = expansion_count + 1;           scan
  883                                else call printline ('** warning, too many expansions for scan
  884   the macro: ' || bcd,-1);                                                         scan
  885                                text = substr(text, cp);                            scan
  886                                text_limit = text_limit - cp;                       scan
  887                                if length(bcd) + text_limit > 255 then              scan
  888                                   do;                                              scan
  889                                      if lb + text_limit > 255 then                 scan
  890                                         call error('macro expansion too long',0);  scan
  891                                      else                                          scan
  892                                         do;                                        scan
  893                                            balance = text || balance;              scan
  894                                            lb = length(balance);                   scan
  895                                            text = bcd;                             scan
  896                                         end;                                       scan
  897                                   end;                                             scan
  898                                else text = bcd || text;                            scan
  899                                bcd = '';                                           scan
  900                                text_limit = length(text) - 1;                      scan
  901                                cp = 0;                                             scan
  902                                go to rescan;                                       scan
  903                             end;                                                   scan
  904                       end;                                                         scan
  905                       /*  reserved words exit higher:  therefore <identifier> */   scan
  906                       token = ident;                                               scan
  907                       return;                                                      scan
  908                    end;                                                            scan
  909              end;                                                                  scan
  910              /*  end of card  */                                                   scan
  911              call get_card;                                                        scan
  912              cp = cp - 1;                                                          scan
  913           end;                                                                     scan
  914           /*  case 5  */                                                           scan case 5.
  915            do FOREVER;   /*  digit:  a number  */                                  scan
  916              token = number;                                                       scan
  917              do cp = cp to text_limit;                                             scan
  918                 s1 = byte(text, cp);                                               scan
  919                 if s1 < byte ('0') | s1 > byte ('9') then return;                  scan
  920                 number_value = 10 * number_value + s1 - byte ('0');                scan
  921              end;                                                                  scan
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 24
 line    source statement                                                               procedure and compiler information
 
  922              call get_card;                                                        scan
  923           end;                                                                     scan
  924           /*  case 6  */                                                           scan case 6.
  925           do;      /*  a /:  may be divide or start of comment  */                 scan
  926              call char;                                                            scan
  927              if byte (text, cp) ~= byte ('*') then                                 scan
  928                 do;                                                                scan
  929                    token = divide;                                                 scan
  930                    return;                                                         scan
  931                 end;                                                               scan
  932              /* we have a comment  */                                              scan
  933              s1, s2 = byte (' ');                                                  scan
  934              do while s1 ~= byte ('*') | s2 ~= byte ('/');                         scan
  935                 if s1 = byte ('$') then /* a control char */                       scan
  936                      control(s2) = ~control(s2) & 1;                               scan
  937                 s1 = s2;                                                           scan
  938                 call char;                                                         scan
  939                 s2 = byte(text, cp);                                               scan
  940              end;                                                                  scan
  941           end;                                                                     scan
  942           /*  case 7  */                                                           scan case 7.
  943           do;      /*  SPECIAL characters  */                                      scan
  944              token = tx(byte(text));                                               scan
  945              cp = 1;                                                               scan
  946              return;                                                               scan
  947           end;                                                                     scan
  948           /*  case 8  */                                                           scan case 8.
  949           do;   /* a |:  may be  |  or  ||  */                                     scan
  950              call char;                                                            scan
  951              if byte(text, cp) = byte('|') then                                    scan
  952                 do;                                                                scan
  953                    call char;                                                      scan
  954                    token = concatenate;                                            scan
  955                 end;                                                               scan
  956              else token = orsymbol;                                                scan
  957              return;                                                               scan
  958           end;                                                                     scan
  959        end;     /* of case on chartype  */                                         scan case 9.
  960        cp = cp + 1;  /* advance scanner and resume search for token  */            scan
  961        go to rescan;                                                               scan
  962     end scan;                                                                      scan
 
symbol table dump
 
symbol          type       loc   segment defined ref count
lbitm           character   775   string    762       2
lstrngm         character   774   string    761       3
rescan          label      1098  program    766       4
s1              fixed      9193     data    760      17
s2              fixed      9194     data    760      11
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 25
 line    source statement                                                               procedure and compiler information
 
  963     /*                                                                            *
  964              c o d e   e m i s s i o n   p r o c e d u r e s                      *
  965   */                                                                              *
  966  flush_data_buffer:                                                               *
  967     procedure;                                                                    *
  968        /* clean out the data buffer and stick all current contents                 flush_data_buffer
  969           into the rel file */                                                     flush_data_buffer
  970        declare i fixed, j fixed;                                                   flush_data_buffer
  971        if (dptr+dctr) > 1 then                                                     flush_data_buffer
  972           do;                                                                      flush_data_buffer
  973              j = (dptr/19)*18 + dctr -1;                                           flush_data_buffer
  974              file(RELFILE) = CODE_TYPE + j;                                        flush_data_buffer
  975              i = dptr+dctr-1;                                                      flush_data_buffer c9 = 262144
  976              do j = 0 to i;                                                        flush_data_buffer
  977                 file(RELFILE) = data_buffer(j);                                    flush_data_buffer
  978                 end;                                                               flush_data_buffer
  979           end;                                                                     flush_data_buffer
  980        dptr = 0;                                                                   flush_data_buffer
  981        dctr = 1;                                                                   flush_data_buffer
  982     end flush_data_buffer;                                                         flush_data_buffer
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9243     data    970       2
j               fixed      9244     data    970       4
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 26
 line    source statement                                                               procedure and compiler information
 
  983  flush_code_buffer:                                                               *
  984     procedure;                                                                    *
  985        /* clean out the code buffer and stick all current contents                 flush_code_buffer
  986           into the rel file */                                                     flush_code_buffer
  987        declare i fixed, j fixed;                                                   flush_code_buffer
  988        if (rptr+rctr) > 1 then                                                     flush_code_buffer
  989           do;                                                                      flush_code_buffer
  990              i = (rptr/19)*18 + rctr -1;                                           flush_code_buffer
  991              j = rptr+rctr-1;                                                      flush_code_buffer
  992              file (RELFILE) = CODE_TYPE+i;                                         flush_code_buffer
  993              do i = 0 to j;                                                        flush_code_buffer
  994                 file(RELFILE) = code_buffer(i);                                    flush_code_buffer
  995                 end;                                                               flush_code_buffer
  996           end;                                                                     flush_code_buffer
  997        rptr = 0;                                                                   flush_code_buffer
  998                                                                                    flush_code_buffer
  999        rctr = 1;                                                                   flush_code_buffer
 1000     end flush_code_buffer;                                                         flush_code_buffer
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9247     data    987       4
j               fixed      9248     data    987       2
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 27
 line    source statement                                                               procedure and compiler information
 
 1001                                                                                   *
 1002  radix50:                                                                         *
 1003     procedure (symbol);                                                           *
 1004     /* procedure to return the radix-50 representation of a symbol.                radix50
 1005        only the first 6 characters are used. */                                    radix50
 1006     declare symbol character;                                                      radix50
 1007     declare (i,j,k,l) fixed;                                                       radix50
 1008                                                                                    radix50
 1009     j = 0;                                                                         radix50
 1010     if length(symbol) < 6 then symbol = symbol || x7;                              radix50
 1011     do l = 0 to 5;                                                                 radix50
 1012        i = byte(symbol,l);                                                         radix50 c10 = 5
 1013        if i = byte(' ') then k = 0;                                                radix50
 1014                                                                                    radix50
 1015           else if i = byte ('.') then k = "(3)45";                                 radix50
 1016                                                                                    radix50
 1017           else if i = byte ('$') then k = "(3)46";                                 radix50
 1018                                                                                    radix50
 1019           else if i = byte ('%') then k = "(3)47";                                 radix50
 1020           else if i >= byte ('0') & i <= byte ('9') then                           radix50
 1021                                                                                    radix50
 1022                      k = i-byte('0') + "(3)1";                                     radix50
 1023           else if i >= byte ('a') & i <= byte ('z') then                           radix50
 1024                      k = i - byte ('a') + "(3)13";                                 radix50
 1025           else return j;                                                           radix50
 1026        j = j * "(3)50" + k;                                                        radix50
 1027        end;                                                                        radix50
 1028     return j;                                                                      radix50
 1029     end radix50;                                                                   radix50
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9250     data   1007      11
j               fixed      9251     data   1007       5
k               fixed      9252     data   1007       7
l               fixed      9253     data   1007       2
symbol          character   782   string   1003       4
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 28
 line    source statement                                                               procedure and compiler information
 
 1030  output_codeword:                                                                 *
 1031     procedure;                                                                    *
 1032     /* spit out the instruction at codexxx(code_tail) */                           output_codeword
 1033                                                                                    output_codeword
 1034     if code_full(code_tail) then                                                   output_codeword
 1035                                                                                    output_codeword
 1036        do;                                                                         output_codeword
 1037           if control(byte('A')) then output (CODEFILE) = code (code_tail);         output_codeword
 1038                                                                                    output_codeword
 1039           if rctr+rptr = 1 then                                                    output_codeword
 1040              do;                                                                   output_codeword
 1041                 code_buffer(0) =shl(1,34);                                         output_codeword
 1042                 code_buffer(1) = code_pp(code_tail) + "(3)400000";                 output_codeword
 1043                 rctr = rctr +1;                                                    output_codeword
 1044              end;                                                                  output_codeword
 1045           code_buffer(rptr) = shl(code_rbits(code_tail),36-rctr*2)|code_buffer(rptr); output_codeword
 1046           code_buffer(rptr+rctr) = code_rel(code_tail);                            output_codeword
 1047           rctr = rctr +1;                                                          output_codeword
 1048           if rptr+rctr > BUFFERSIZE then call flush_code_buffer;                   output_codeword
 1049           if rctr > 18 then                                                        output_codeword
 1050              do;                                                                   output_codeword
 1051                 rptr = rptr +19;                                                   output_codeword
 1052                 rctr = 1;                                                          output_codeword
 1053                 code_buffer(rptr) = 0;                                             output_codeword
 1054              end;                                                                  output_codeword
 1055        end;                                                                        output_codeword
 1056     code_full(code_tail) = FALSE;                                                  output_codeword
 1057     code_tail = (code_tail+1) & 3;                                                 output_codeword
 1058     end output_codeword;                                                           output_codeword
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 29
 line    source statement                                                               procedure and compiler information
 
 1059  flush_labels:                                                                    *
 1060     procedure;                                                                    *
 1061        /* clean out label buffer by generating internal request                    flush_labels
 1062           type block and defining all labels now known */                          flush_labels
 1063        declare i fixed;                                                            flush_labels
 1064        if label_count = 0 then return;                                             flush_labels
 1065        do while code_tail ~= code_head;                                            flush_labels
 1066           call output_codeword;                                                    flush_labels
 1067           end;                                                                     flush_labels
 1068        call output_codeword;                                                       flush_labels
 1069        code_tail = code_head;      /* reset pointers, since buffers now empty */   flush_labels
 1070        stillcond, stillinzero = 0; /* make sure peephole works */                  flush_labels
 1071        call flush_code_buffer;                                                     flush_labels
 1072        file (RELFILE) = INTREQ_TYPE+label_count;                                   flush_labels
 1073        do i = 0 to label_count;                                                    flush_labels c11 = 2097152
 1074           file (RELFILE) = label_buffer(i);                                        flush_labels
 1075           end;                                                                     flush_labels
 1076        label_count = 0;                                                            flush_labels
 1077        label_buffer(0) = 0;                                                        flush_labels
 1078     end flush_labels;                                                              flush_labels
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9255     data   1063       2
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 30
 line    source statement                                                               procedure and compiler information
 
 1079  output_dataword:                                                                 *
 1080     procedure (w,loc);                                                            *
 1081        /* output a word to the low segment */                                      output_dataword
 1082        declare w  fixed, loc fixed;                                                output_dataword
 1083        if (dptr+dctr)>BUFFERSIZE | dloc ~= loc then call flush_data_buffer;        output_dataword
 1084        if dptr+dctr = 1 then                                                       output_dataword
 1085           do;                                                                      output_dataword
 1086              data_buffer(0) = "(3)200000000000";                                   output_dataword
 1087              data_buffer(1) = loc;                                                 output_dataword c12 = 17179869184
 1088              data_buffer(2) = w;                                                   output_dataword
 1089              dloc = loc + 1;                                                       output_dataword
 1090              dctr = dctr + 2;                                                      output_dataword
 1091              return;                                                               output_dataword
 1092           end;                                                                     output_dataword
 1093        data_buffer (dptr+dctr) = w;                                                output_dataword
 1094        dctr = dctr +1;                                                             output_dataword
 1095        dloc = dloc + 1;                                                            output_dataword
 1096        if dptr+dctr > BUFFERSIZE then call flush_data_buffer;                      output_dataword
 1097        if dctr > 18 then                                                           output_dataword
 1098          do;                                                                       output_dataword
 1099              dctr = 1;                                                             output_dataword
 1100              dptr = dptr + 19;                                                     output_dataword
 1101              data_buffer(dptr) = 0;                                                output_dataword
 1102           end;                                                                     output_dataword
 1103     end output_dataword;                                                           output_dataword
 
symbol table dump
 
symbol          type       loc   segment defined ref count
loc             fixed      9259     data   1080       3
w               fixed      9258     data   1080       2
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 31
 line    source statement                                                               procedure and compiler information
 
 1104  flush_datacard:procedure;                                                        *
 1105        if control(byte('A')) | control(byte('B')) then                             flush_datacard
 1106           do;                                                                      flush_datacard
 1107              datacard = datacard || '; d' || dp;                                   flush_datacard
 1108              if control(byte('A')) then output (DATAFILE) = datacard;              flush_datacard
 1109              if control(byte('B')) then call printline (datamsg || datacard,-1);   flush_datacard
 1110           end;                                                                     flush_datacard
 1111        call output_dataword (pword,dp);                                            flush_datacard
 1112        pword = 0;                                                                  flush_datacard
 1113        dpoffset = 0;                                                               flush_datacard
 1114        dp = dp + 1;                                                                flush_datacard
 1115  end flush_datacard;                                                               flush_datacard
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 32
 line    source statement                                                               procedure and compiler information
 
 1116  emitblock:                                                                       *
 1117     procedure (i);                                                                *
 1118        /* reserve a block of i words */                                            emitblock
 1119        declare i fixed;                                                            emitblock
 1120        if control(byte('A')) | control(byte('B')) then                             emitblock
 1121           do;                                                                      emitblock
 1122              datacard = '       repeat ' || i || ',<0>; d' || dp;                  emitblock
 1123              if control(byte('A')) then output (DATAFILE) = datacard;              emitblock
 1124              if control(byte('B')) then call printline (datamsg || datacard,-1);   emitblock
 1125           end;                                                                     emitblock
 1126        dp = dp + i;                                                                emitblock
 1127  end emitblock;                                                                    emitblock
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9262     data   1117       2
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 33
 line    source statement                                                               procedure and compiler information
 
 1128  emitdataword:                                                                    *
 1129     procedure (w);                                                                *
 1130        declare w fixed;                                                            emitdataword
 1131        /* send an 80 character card to the data file */                            emitdataword
 1132        if dpoffset > 0 then call flush_datacard;                                   emitdataword
 1133        if control(byte('A')) | control(byte('B')) then                             emitdataword
 1134           do;                                                                      emitdataword
 1135              datacard = x7 || w || '; d' || dp;                                    emitdataword
 1136              if control(byte('A')) then output (DATAFILE) = datacard;              emitdataword
 1137              if control(byte('B')) then call printline (datamsg || datacard,-1);   emitdataword
 1138           end;                                                                     emitdataword
 1139        call output_dataword(w,dp);                                                 emitdataword
 1140        dp = dp + 1;                                                                emitdataword
 1141  end emitdataword;                                                                 emitdataword
 
symbol table dump
 
symbol          type       loc   segment defined ref count
w               fixed      9269     data   1129       2
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 34
 line    source statement                                                               procedure and compiler information
 
 1142  emitbyte:                                                                        *
 1143     procedure (c);                                                                *
 1144        declare c fixed;                                                            emitbyte
 1145        /* send one 9-bit byte to the data area */                                  emitbyte
 1146        if control(byte('A')) | control(byte('B')) then                             emitbyte
 1147           if dpoffset = 0 then datacard = '       byte (9)'|| c;                   emitbyte
 1148           else datacard = datacard || ',' || c;                                    emitbyte
 1149        pword = pword + shl(c&"(3)777",9*(3-dpoffset));                             emitbyte
 1150        dpoffset = dpoffset + 1;                                                    emitbyte
 1151        if dpoffset = 4 then call flush_datacard;                                   emitbyte
 1152  end emitbyte;                                                                     emitbyte
 
symbol table dump
 
symbol          type       loc   segment defined ref count
c               fixed      9271     data   1143       3
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 35
 line    source statement                                                               procedure and compiler information
 
 1153  emitconstant:                                                                    *
 1154     procedure (c);                                                                *
 1155        declare c fixed;                                                            emitconstant
 1156        declare ctab (100) fixed, cadd (100) fixed, nc fixed, i fixed;              emitconstant
 1157        /* see if c has already been emited, and if not, emit it.  set up adr.  */  emitconstant
 1158        do i = 1 to nc;                  /* step thru the constants */              emitconstant
 1159           if ctab (i) = c then                                                     emitconstant
 1160              do;                                                                   emitconstant
 1161                 adr = cadd (i);                                                    emitconstant
 1162                 return;                                                            emitconstant
 1163              end;                                                                  emitconstant
 1164        end;                                                                        emitconstant
 1165        ctab (i) = c;                                                               emitconstant
 1166        call emitdataword (c);                                                      emitconstant
 1167        adr, cadd (i) = dp - 1;                                                     emitconstant
 1168        if i < 100 then nc = i;                                                     emitconstant
 1169        if control(byte('C')) then call printline ('* CONSTANT ' || nc || ' = ' || c,-1); emitconstant
 1170           else if control(byte('L')) then info=info|| ' c'|| nc ||' = ' || c;      emitconstant
 1171  end emitconstant;                                                                 emitconstant
 
symbol table dump
 
symbol          type       loc   segment defined ref count
c               fixed      9276     data   1154       5
cadd            fixed      9378     data   1156       2
ctab            fixed      9277     data   1156       2
i               fixed      9480     data   1156       7
nc              fixed      9479     data   1156       4
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 36
 line    source statement                                                               procedure and compiler information
 
 1172  emitcodeword:procedure (w,word,rbits);                                           *
 1173         declare w character;                                                       emitcodeword
 1174        declare word fixed;                                                         emitcodeword
 1175        declare rbits fixed;                                                        emitcodeword
 1176        /* send an 80 character code card to the buffer area */                     emitcodeword
 1177        code_head = (code_head+1) & 3;                                              emitcodeword
 1178        if code_head = code_tail then call output_codeword;                         emitcodeword
 1179        if control(byte('A')) | control(byte('E')) then                             emitcodeword
 1180              code(code_head) = label_gen || w;                                     emitcodeword
 1181        if control(byte('E')) then                                                  emitcodeword
 1182              call printline (codemsg || code(code_head),-1);                       emitcodeword
 1183        code_rel(code_head) = word;                                                 emitcodeword
 1184        code_pp(code_head) = pp;                                                    emitcodeword
 1185        code_rbits(code_head) = rbits;                                              emitcodeword
 1186        code_full(code_head) = TRUE;                                                emitcodeword
 1187        label_gen = '';                                                             emitcodeword
 1188        stillcond, stillinzero = 0;                                                 emitcodeword
 1189        pp = pp + 1;                                                                emitcodeword
 1190  end emitcodeword;                                                                 emitcodeword
 
symbol table dump
 
symbol          type       loc   segment defined ref count
rbits           fixed      9488     data   1172       1
w               character   793   string   1172       1
word            fixed      9487     data   1172       1
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 37
 line    source statement                                                               procedure and compiler information
 
 1191  outputlabel:                                                                     *
 1192     procedure (j);                                                                *
 1193     declare j fixed;                                                               outputlabel
 1194     label_count = label_count+1;                                                   outputlabel
 1195     label_buffer(0) = shl(3,36-label_count*2)|label_buffer(0);                     outputlabel
 1196     label_buffer(label_count) = j;                                                 outputlabel
 1197     if(label_count >= BUFFERSIZE) then call flush_labels;                          outputlabel
 1198     end outputlabel;                                                               outputlabel
 
symbol table dump
 
symbol          type       loc   segment defined ref count
j               fixed      9489     data   1192       1
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 38
 line    source statement                                                               procedure and compiler information
 
 1199  emitlabel:procedure(l,r);                                                        *
 1200        declare l fixed;                                                            emitlabel
 1201        declare r fixed;                                                            emitlabel
 1202        declare i fixed;                                                            emitlabel
 1203        declare j fixed;                                                            emitlabel
 1204        if r = 3 then                                                               emitlabel
 1205           do;                                                                      emitlabel
 1206              if descref(l) = 0 then return;                                        emitlabel
 1207              j = shl(descref(l),18) + dp;                                          emitlabel
 1208              call outputlabel(j);                                                  emitlabel
 1209              descref(l) = 0;                                                       emitlabel
 1210              return;                                                               emitlabel
 1211           end;                                                                     emitlabel
 1212        stillinzero = 0;    /* don't try optimizing over label */                   emitlabel
 1213        j = shl(r,18) + l;                                                          emitlabel
 1214        do i = 1 to for_count;                                                      emitlabel
 1215           if j = for_label(i) then                                                 emitlabel
 1216              do;                                                                   emitlabel
 1217                 j = shl(for_ref(i)+"(3)400000",18);                                emitlabel
 1218                 if r = 4 then j = j + pp + "(3)400000";                            emitlabel
 1219                          else j = j + dp;                                          emitlabel
 1220                 call outputlabel(j);                                               emitlabel
 1221                 j = i;                                                             emitlabel
 1222                 do while j < for_count;                                            emitlabel
 1223                    for_label(j) = for_label(j+1);                                  emitlabel
 1224                    for_ref(j) = for_ref(j+1);                                      emitlabel
 1225                    j = j + 1;                                                      emitlabel
 1226                 end;                                                               emitlabel
 1227                 for_label(for_count) = 0;                                          emitlabel
 1228                 for_ref(for_count) = 0;                                            emitlabel
 1229                 for_count = for_count -1;                                          emitlabel
 1230                 /* put a label on the next instruction generated */                emitlabel
 1231                 if r = 4 & (control(byte('A')) | control(byte('E'))) then          emitlabel
 1232                              label_gen = label_gen || '$' || l || ':';             emitlabel
 1233                 return;                                                            emitlabel
 1234              end;                                                                  emitlabel
 1235        end;                                                                        emitlabel
 1236        if r = 4 & (control(byte('A')) | control(byte('E'))) then                   emitlabel
 1237            label_gen = label_gen || '$' || l || ':';                               emitlabel
 1238        return;                                                                     emitlabel
 1239  end emitlabel;                                                                    emitlabel
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9492     data   1202       4
j               fixed      9493     data   1203      18
l               fixed      9490     data   1199       6
r               fixed      9491     data   1199       5
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 39
 line    source statement                                                               procedure and compiler information
 
 1240  refcheck:                                                                        *
 1241     procedure (i);                                                                *
 1242        /* check to see if this satisfies any forward references.                   refcheck
 1243           if so, set up label buffer.  if not, check if this                       refcheck
 1244           should be chained. */                                                    refcheck
 1245        declare i fixed;                                                            refcheck
 1246        declare j fixed;                                                            refcheck
 1247        if shr(i,18) = 3 then                                                       refcheck
 1248           do;                                                                      refcheck
 1249              i = i & "(3)777777";                                                  refcheck
 1250              j = descref(i);                                                       refcheck
 1251              descref(i) = pp + "(3)400000";                                        refcheck
 1252              return j;                                                             refcheck
 1253           end;                                                                     refcheck
 1254        j = 1;                                                                      refcheck
 1255        do while j <= for_count;                                                    refcheck
 1256           if for_label(j) = i then                                                 refcheck
 1257              do;                                                                   refcheck
 1258                 i = for_ref(j) + "(3)400000";                                      refcheck
 1259                 for_ref(j) = pp;                                                   refcheck
 1260                 return i;                                                          refcheck
 1261              end;                                                                  refcheck
 1262           j=j+1;                                                                   refcheck
 1263        end;                                                                        refcheck
 1264        for_count = for_count +1;                                                   refcheck
 1265        if for_count > FOR_MAX then call error ('too many forward references',3);   refcheck
 1266        for_ref(for_count) = pp;                                                    refcheck
 1267        for_label(for_count) = i;                                                   refcheck
 1268        return 0;                                                                   refcheck
 1269     end refcheck;                                                                  refcheck
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9496     data   1241       9
j               fixed      9497     data   1246       9
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 40
 line    source statement                                                               procedure and compiler information
 
 1270  emitinst:procedure (opcode,treg,indirect,operand,ireg,relocation);               *
 1271        declare opcode fixed,                                                       emitinst
 1272                treg fixed,                                                         emitinst
 1273                indirect fixed,                                                     emitinst
 1274                operand fixed,                                                      emitinst
 1275                ireg fixed,                                                         emitinst
 1276                relocation fixed;                                                   emitinst
 1277        declare rbits fixed,                                                        emitinst
 1278                word fixed;                                                         emitinst
 1279        /* emit a 80 character instruction image */                                 emitinst
 1280        declare reloc (5) character                                                 emitinst
 1281                initial ('', 'd+', 'p+', 's+', '$', '$');                           emitinst
 1282        declare i fixed,                                                            emitinst
 1283                j fixed,                                                            emitinst
 1284                card character,                                                     emitinst
 1285                indir (1) character initial ('', '@');                              emitinst
 1286        count_inst = count_inst + 1;                                                emitinst
 1287                                                                                    emitinst
 1288        word = shl(opcode,27) + shl(treg&"f",23) + shl(indirect&1,22)               emitinst
 1289               + shl(ireg&"f",18);                                                  emitinst
 1290        do case relocation;                                                         emitinst
 1291           /* case 0 : absolute address - no relocation */                          emitinst case 0.
 1292           do;                                                                      emitinst
 1293              word = word + (operand&"(3)777777");                                  emitinst
 1294              rbits = 0;                                                            emitinst
 1295           end;                                                                     emitinst
 1296                                                                                    emitinst case 1.
 1297           /* case 1 : relative to the beginning of data segment */                 emitinst
 1298           do;                                                                      emitinst
 1299              word = word + (operand&"(3)777777");                                  emitinst
 1300              rbits = 1;                                                            emitinst
 1301           end;                                                                     emitinst
 1302                                                                                    emitinst case 2.
 1303           /* case 2 : relative to beginning of code segment */                     emitinst
 1304           do;                                                                      emitinst
 1305              word = word + (operand&"(3)777777") + "(3)400000";                    emitinst
 1306              rbits = 1;                                                            emitinst
 1307           end;                                                                     emitinst
 1308                                                                                    emitinst case 3.
 1309           /* case 3 : relative to beginning of strings */                          emitinst
 1310           do;                                                                      emitinst
 1311              i = shl(relocation,18) + (operand&"(3)777777");                       emitinst
 1312              j = refcheck(i);                                                      emitinst
 1313              word = word + j;                                                      emitinst
 1314              if j = 0 then rbits = 0;                                              emitinst
 1315                       else rbits = 1;                                              emitinst
 1316           end;                                                                     emitinst
 1317                                                                                    emitinst case 4.
 1318           /* case 4 : forward label reference in code area */                      emitinst
 1319           do;                                                                      emitinst
 1320              j = refcheck("(3)4000000" + (operand&"(3)777777"));                   emitinst
 1321              word = word + j;                                                      emitinst c13 = 1048576
 1322              if j = 0 then rbits = 0;                                              emitinst
 1323                       else rbits = 1;                                              emitinst
 1324           end;                                                                     emitinst
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 41
 line    source statement                                                               procedure and compiler information
 
 1325                                                                                    emitinst case 5.
 1326           /* case 5 : forward label reference in data area */                      emitinst
 1327           do;                                                                      emitinst
 1328              j = refcheck("(3)5000000" + (operand&"(3)777777"));                   emitinst
 1329              word = word + j;                                                      emitinst c14 = 1310720
 1330              if j = 0 then rbits = 0;                                              emitinst
 1331                       else rbits = 1;                                              emitinst
 1332           end;                                                                     emitinst
 1333        end;  /* end of do case relocation */                                       emitinst case 6.
 1334                                                                                    emitinst
 1335        if control(byte('A')) | control(byte('E')) then                             emitinst
 1336           do;                                                                      emitinst
 1337              i = shr(opcode,5);                                                    emitinst
 1338              card = x7 || substr(opname(i),(opcode-i*32)*6,6) || x1 ||treg || ','  emitinst
 1339                     || indir(indirect) || reloc(relocation) || operand;            emitinst c15 = 805306368
 1340              if ireg > 0 then card = card || '(' || ireg || ')';                   emitinst
 1341              card = card || '; p' || pp;                                           emitinst
 1342           end;                                                                     emitinst
 1343        instruct(opcode) = instruct(opcode) + 1;                                    emitinst
 1344        call emitcodeword (card,word,rbits);                                        emitinst
 1345  end emitinst;                                                                     emitinst
 
symbol table dump
 
symbol          type       loc   segment defined ref count
card            character   805   string   1284       6
i               fixed      9515     data   1282       5
indir           character   806   string   1285       1
indirect        fixed      9507     data   1270       2
ireg            fixed      9509     data   1270       3
j               fixed      9516     data   1283       9
opcode          fixed      9505     data   1270       5
operand         fixed      9508     data   1270       7
rbits           fixed      9511     data   1277      10
reloc           character   799   string   1280       1
relocation      fixed      9510     data   1270       3
treg            fixed      9506     data   1270       2
word            fixed      9512     data   1278      14
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 42
 line    source statement                                                               procedure and compiler information
 
 1346  emitdesc:procedure (l,a);                                                        *
 1347        declare l fixed,                                                            emitdesc
 1348                a fixed;                                                            emitdesc
 1349        /* send a length and string address to the descriptor area */               emitdesc
 1350        if dsp > DESCLIMIT then                                                     emitdesc
 1351           do;                                                                      emitdesc
 1352              call error ('too many strings',1);                                    emitdesc
 1353              dsp = 0;                                                              emitdesc
 1354           end;                                                                     emitdesc
 1355         if control(byte('B')) then                                                 emitdesc
 1356           call printline (x70 || 'desc =        ' || l || ',' || a || '; s' || dsp,-1); emitdesc
 1357        descl(dsp) = l;                                                             emitdesc
 1358        desca(dsp) = a;                                                             emitdesc
 1359        dsp = dsp + 1;                                                              emitdesc
 1360  end emitdesc;                                                                     emitdesc
 
symbol table dump
 
symbol          type       loc   segment defined ref count
a               fixed      9524     data   1346       2
l               fixed      9523     data   1346       2
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 43
 line    source statement                                                               procedure and compiler information
 
 1361  findlabel:procedure;                                                             *
 1362        label_sink = label_sink + 1;                                                findlabel
 1363        return (label_sink);                                                        findlabel
 1364  end findlabel;                                                                    findlabel
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 44
 line    source statement                                                               procedure and compiler information
 
 1365   /*                                                                              *
 1366             s y m b o l   t a b l e   p r o c e d u r e s                         *
 1367   */                                                                              *
 1368                                                                                   *
 1369  hasher:                                                                          *
 1370     procedure (id);          /* calculate hash index into hash table*/            *
 1371     declare id   character;                                                        hasher
 1372     declare l    fixed;                                                            hasher
 1373     l = length (id);                                                               hasher
 1374     return (byte (id) + byte (id, l-1) + shl (l,4)) & "ff";                        hasher
 1375     end hasher;                                                                    hasher
 
symbol table dump
 
symbol          type       loc   segment defined ref count
id              character   816   string   1370       3
l               fixed      9534     data   1372       3
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 45
 line    source statement                                                               procedure and compiler information
 
 1376                                                                                   *
 1377  enter:procedure (n, t, l, s);                                                    *
 1378        declare t fixed, l fixed, s fixed;                                          enter
 1379        declare n character;                                                        enter
 1380   /* enter the name n in the symbol table with type t at location l segment s */   enter
 1381        declare i fixed, k fixed;                                                   enter
 1382        idx = hasher (n);                                                           enter
 1383        i = hash (idx);                                                             enter
 1384        do while i >= procmark;                                                     enter
 1385           idcompares = idcompares + 1;                                             enter
 1386           if n = syt (i) then                                                      enter
 1387              do;                                                                   enter
 1388                 k = sytype (i);                                                    enter
 1389                 if t = LABELTYPE & (k = FORWARDTYPE | k = FORWARDCALL) then        enter
 1390                    do;                                                             enter
 1391                       if control (byte ('E')) then                                 enter
 1392                          call printline (x70 || 'fixed references to: ' || n,-1);  enter
 1393                       if k = FORWARDTYPE then                                      enter
 1394                          do;                                                       enter
 1395                             call emitlabel(sytloc(i),4);                           enter
 1396                             sytloc(i) = l;                                         enter
 1397                             sytseg(i) = s;                                         enter
 1398                          end;                                                      enter
 1399                       sytype (i) = t;                                              enter
 1400                    end;                                                            enter
 1401                 else if procmark + parct < i then                                  enter
 1402                    call error ('duplicate declaration for: ' || n, 0);             enter
 1403                 return i;                                                          enter
 1404              end;                                                                  enter
 1405           i = ptr (i);                                                             enter
 1406        end;                                                                        enter
 1407        ndecsy = ndecsy + 1;                                                        enter
 1408        if ndecsy > maxndecsy then                                                  enter
 1409           if ndecsy > SYTSIZE then                                                 enter
 1410              do;                                                                   enter
 1411                 call error ('symbol table overflow', 1);                           enter
 1412                 ndecsy = ndecsy - 1;                                               enter
 1413              end;                                                                  enter
 1414           else maxndecsy = ndecsy;                                                 enter
 1415        syt (ndecsy) = n;                                                           enter
 1416        sytype (ndecsy) = t;                                                        enter
 1417        sytloc (ndecsy) = l;                                                        enter
 1418        sytseg (ndecsy) = s;                                                        enter
 1419        sytco (ndecsy) = 0;                                                         enter
 1420        sytcard (ndecsy) = card_count;                                              enter
 1421        ptr (ndecsy) = hash (idx);                                                  enter
 1422        hash (idx) = ndecsy;                                                        enter
 1423        return (ndecsy);                                                            enter
 1424  end enter;                                                                        enter
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9538     data   1381      12
k               fixed      9539     data   1381       4
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 46
symbol          type       loc   segment defined ref count
 
l               fixed      9536     data   1377       2
n               character   817   string   1377       5
s               fixed      9537     data   1377       2
t               fixed      9535     data   1377       3
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 47
 line    source statement                                                               procedure and compiler information
 
 1425   id_lookup:                                                                      *
 1426     procedure (p);                                                                *
 1427        /* looks up the identifier at p in the analysis stack in the                id_lookup
 1428           symbol table and initializes fixl, cnt, type, and inx                    id_lookup
 1429           appropriately.  if the identifier is not found, fixl is                  id_lookup
 1430           set to -1                                                                id_lookup
 1431        */                                                                          id_lookup
 1432        declare p fixed, i fixed;                                                   id_lookup
 1433        char_temp = var (p);                                                        id_lookup
 1434        i = hash (hasher (char_temp));                                              id_lookup
 1435        do while i ~= -1;                                                           id_lookup
 1436           idcompares = idcompares + 1;                                             id_lookup c16 = -1
 1437           if syt(i) = char_temp then                                               id_lookup
 1438              do;                                                                   id_lookup
 1439                 fixl (p) = i;                                                      id_lookup
 1440                 cnt (p) = 0;        /* initialize subscript count */               id_lookup
 1441                 type (p) = VARIABLE;                                               id_lookup
 1442                 if sytype (i) = SPECIAL then                                       id_lookup
 1443                    fixv (p) = sytloc (i);    /* builtin function */                id_lookup
 1444                 else                                                               id_lookup
 1445                    fixv (p) = 0;                                                   id_lookup
 1446                 inx (p) = 0;       /* location of index */                         id_lookup
 1447                 reg(p) = 0;                                                        id_lookup
 1448                 sytco (i) = sytco (i) + 1;                                         id_lookup
 1449                 return;                                                            id_lookup
 1450              end;                                                                  id_lookup
 1451           i = ptr (i);                                                             id_lookup
 1452        end;                                                                        id_lookup
 1453        fixl (p) = -1;              /* identifier not found */                      id_lookup
 1454  end id_lookup;                                                                    id_lookup
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9559     data   1432      10
p               fixed      9558     data   1426       9
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 48
 line    source statement                                                               procedure and compiler information
 
 1455  undeclared_id:                                                                   *
 1456     procedure (p);                                                                *
 1457        /* issues an error message for undeclared identifiers and                   undeclared_id
 1458           enters them with default type in the symbol table                        undeclared_id
 1459       */                                                                           undeclared_id
 1460        declare p fixed;                                                            undeclared_id
 1461        call error ('undeclared identifier: ' || var (p), 0);                       undeclared_id
 1462        call emitdataword (0);                                                      undeclared_id
 1463        fixl (p) = enter (var (p), FIXEDTYPE, dp-1, 1);                             undeclared_id
 1464        cnt (p) = 0;                                                                undeclared_id
 1465        fixv (p) = 0;                                                               undeclared_id
 1466        inx (p) = 0;                                                                undeclared_id
 1467        sytco (ndecsy) = 1;            /* count first reference */                  undeclared_id
 1468        sytcard (ndecsy) = -1;         /* flag undeclared identifier */             undeclared_id
 1469        type (p) = VARIABLE;                                                        undeclared_id
 1470  end undeclared_id;                                                                undeclared_id
 
symbol table dump
 
symbol          type       loc   segment defined ref count
p               fixed      9561     data   1456       7
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 49
 line    source statement                                                               procedure and compiler information
 
 1471   /*                                                                              *
 1472          a r i t h e m e t i c   p r o c e d u r e s                              *
 1473   */                                                                              *
 1474  clearars:                                                                        *
 1475     procedure;                                                                    *
 1476        /* free all the temproary arithemetic registers */                          clearars
 1477        do i = 0 to 11;                                                             clearars
 1478           acc(i) = AVAIL;                                                          clearars c17 = 11
 1479        end;                                                                        clearars
 1480  end clearars;                                                                     clearars
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 50
 line    source statement                                                               procedure and compiler information
 
 1481  findar:                                                                          *
 1482     procedure;                                                                    *
 1483         declare i fixed;                                                           findar
 1484        /* get a temporary arithemetic register */                                  findar
 1485        if target_register > -1 then                                                findar
 1486           if acc (target_register) = AVAIL then                                    findar
 1487              do;                                                                   findar
 1488                 acc (target_register) = BUSY;                                      findar
 1489                 return target_register;                                            findar
 1490              end;                                                                  findar
 1491        do i = 1 to 11;                                                             findar
 1492           if acc(i) = AVAIL then                                                   findar
 1493              do;                                                                   findar
 1494                 acc(i) = BUSY;                                                     findar
 1495                 return (i);                                                        findar
 1496              end;                                                                  findar
 1497        end;                                                                        findar
 1498        call error ('used all accumulators', 0);                                    findar
 1499        return (0);                                                                 findar
 1500  end findar;                                                                       findar
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9569     data   1483       4
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 51
 line    source statement                                                               procedure and compiler information
 
 1501  movestacks:                                                                      *
 1502     procedure (f, t);                                                             *
 1503        declare f fixed, t fixed;                                                   movestacks
 1504        /* move all compiler stacks down from f to t */                             movestacks
 1505        type (t) = type (f);                                                        movestacks
 1506        reg (t) = reg (f);                                                          movestacks
 1507        cnt (t) = cnt (f);                                                          movestacks
 1508        var (t) = var (f);                                                          movestacks
 1509        fixl (t) = fixl (f);                                                        movestacks
 1510        fixv (t) = fixv (f);                                                        movestacks
 1511        inx (t) = inx (f);                                                          movestacks
 1512        ppsave (t) = ppsave (f);                                                    movestacks
 1513  end movestacks;                                                                   movestacks
 
symbol table dump
 
symbol          type       loc   segment defined ref count
f               fixed      9576     data   1502       8
t               fixed      9577     data   1502       8
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 52
 line    source statement                                                               procedure and compiler information
 
 1514  forceaddress:                                                                    *
 1515     procedure(sp);                                                                *
 1516        /* generates the address of <VARIABLE> in the analysis stack                forceaddress
 1517           at sp.                                                                   forceaddress
 1518        */                                                                          forceaddress
 1519        declare sp fixed, j fixed, r fixed;                                         forceaddress
 1520        r = findar;                                                                 forceaddress
 1521        j = fixl(sp);                                                               forceaddress
 1522        call emitinst (movei,r,0,sytloc(j),0,sytseg(j));                            forceaddress
 1523        reg(j) = r;                                                                 forceaddress
 1524  end forceaddress;                                                                 forceaddress
 
symbol table dump
 
symbol          type       loc   segment defined ref count
j               fixed      9579     data   1519       4
r               fixed      9580     data   1519       3
sp              fixed      9578     data   1515       1
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 53
 line    source statement                                                               procedure and compiler information
 
 1525  setinit:                                                                         *
 1526     procedure;                                                                    *
 1527        /* places initial values into data area */                                  setinit
 1528        declare tmiiil character initial ('too many items in initial list');        setinit
 1529        if itype = CHRTYPE then                                                     setinit
 1530           do;                                                                      setinit
 1531              if dsp < newdsp then                                                  setinit
 1532                 do;                                                                setinit
 1533                    if type (mpp1) ~= CHRTYPE then s = fixv (mpp1);                 setinit
 1534                    else s = var (mpp1);     /* the string */                       setinit
 1535                    i = length (s);                                                 setinit
 1536                    if i = 0 then                                                   setinit
 1537                       call emitdesc (0,0);                                         setinit
 1538                    else                                                            setinit
 1539                       do;                                                          setinit
 1540                          call emitdesc (i, dpoffset+shl(dp,2));                    setinit
 1541                          do j = 0 to i - 1;                                        setinit
 1542                             call emitbyte (byte (s, j));                           setinit
 1543                          end;                                                      setinit
 1544                        end;                                                        setinit
 1545                 end;                                                               setinit
 1546              else call error (tmiiil,0);                                           setinit
 1547           end;                                                                     setinit
 1548        else                                                                        setinit
 1549           if type (mpp1) ~= CONSTANT then                                          setinit
 1550              call error ('illegal CONSTANT in initial list',0);                    setinit
 1551           else                                                                     setinit
 1552              if itype = FIXEDTYPE then                                             setinit
 1553                 do;                                                                setinit
 1554                 if dp < newdp then call emitdataword (fixv(mpp1));                 setinit
 1555                 else call error (tmiiil,0);                                        setinit
 1556                 end;                                                               setinit
 1557              else   /* must be BYTETYPE */                                         setinit
 1558                 if dp < newdp | (dp = newdp & dpoffset < newdpoffset) then         setinit
 1559                    call emitbyte(fixv(mpp1));                                      setinit
 1560                 else call error (tmiiil,0);                                        setinit
 1561  end setinit;                                                                      setinit
 
symbol table dump
 
symbol          type       loc   segment defined ref count
tmiiil          character   823   string   1528       3
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 54
 line    source statement                                                               procedure and compiler information
 
 1562  save_acs:                                                                        *
 1563     procedure (n);                                                                *
 1564        /* generate code to save BUSY acs, up to ac-n */                            save_acs
 1565        declare n fixed;                                                            save_acs
 1566        declare i fixed;                                                            save_acs
 1567        do i = 1 to n;                                                              save_acs
 1568           if (acc(i) = BUSY) then call emitinst (push,15,0,i,0,0);                 save_acs
 1569        end;                                                                        save_acs
 1570  end save_acs;                                                                     save_acs
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9599     data   1566       3
n               fixed      9598     data   1563       1
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 55
 line    source statement                                                               procedure and compiler information
 
 1571  restore_acs:                                                                     *
 1572     procedure (n);                                                                *
 1573        /* generate code to restore BUSY acs, up to ac-n  */                        restore_acs
 1574        declare n fixed;                                                            restore_acs
 1575        declare i fixed, j fixed;                                                   restore_acs
 1576        do i = 1 to n;                                                              restore_acs
 1577           j = n - i + 1;                                                           restore_acs
 1578           if (acc(j) = BUSY) then call emitinst (pop,15,0,j,0,0);                  restore_acs
 1579        end;                                                                        restore_acs
 1580  end restore_acs;                                                                  restore_acs
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9602     data   1575       2
j               fixed      9603     data   1575       3
n               fixed      9601     data   1572       2
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 56
 line    source statement                                                               procedure and compiler information
 
 1581  proc_start:                                                                      *
 1582     procedure;                                                                    *
 1583        /* generates code for the head of a procedure */                            proc_start
 1584        ppsave(mp) = findlabel;           /* something to goto */                   proc_start
 1585        call emitinst (jrst,0,0,ppsave(mp),0,4); /* go around proc */               proc_start
 1586        if sytseg(fixl(mp)) = 4 then call emitlabel(sytloc(fixl(mp)),4);            proc_start
 1587        sytseg(fixl(mp)) = 2;                                                       proc_start
 1588        sytloc(fixl(mp)) = pp;            /* addr of proc */                        proc_start
 1589  end proc_start;                                                                   proc_start
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 57
 line    source statement                                                               procedure and compiler information
 
 1590  tdeclare:                                                                        *
 1591     procedure (dim);                                                              *
 1592     /* allocates storage for identifiers in declaration */                         tdeclare
 1593        declare dim fixed;                                                          tdeclare
 1594        declare i   fixed;                                                          tdeclare
 1595     allocate:                                                                      tdeclare
 1596        procedure (p, dim);                                                         tdeclare
 1597           /* allocates storage for the identifier at p in the analysis             allocate
 1598              stack with dimension dim                                              allocate
 1599           */                                                                       allocate
 1600           declare p fixed, dim fixed, j fixed, k fixed;                            allocate
 1601           dim = dim + 1;                    /* actual number of items */           allocate
 1602           do case type (p);                                                        allocate
 1603              ;    /*  case 0 -- dummy */                                           allocate case 0.
 1604              ;    /*  case 1 -- label type */                                      allocate case 1.
 1605              ;    /*  case 2 -- ACCUMULATOR */                                     allocate case 2.
 1606              ;    /*  case 3 -- VARIABLE */                                        allocate case 3.
 1607              ;    /*  case 4 -- CONSTANT */                                        allocate case 4.
 1608              ;    /*  case 5 -- condition */                                       allocate case 5.
 1609              do;   /* case 6 -- CHRTYPE */                                         allocate case 6.
 1610                 j = dsp; k = 3;                                                    allocate
 1611                 newdsp = dsp + dim;                                                allocate
 1612              end;                                                                  allocate
 1613              do;  /*  case 7 -- FIXEDTYPE */                                       allocate case 7.
 1614                 if dpoffset > 0 then                                               allocate
 1615                    do;                                                             allocate
 1616                       call flush_datacard;                                         allocate
 1617                       olddp = dp;                                                  allocate
 1618                       olddpoffset = 0;                                             allocate
 1619                    end;                                                            allocate
 1620                 j = dp; k = 1;                                                     allocate
 1621                 newdp = dp + dim; newdpoffset = 0;                                 allocate
 1622              end;                                                                  allocate
 1623              do;  /*  case 8 -- BYTETYPE */                                        allocate case 8.
 1624                 if dpoffset > 0 then                                               allocate
 1625                    if i = 1 then                                                   allocate
 1626                       do;                                                          allocate
 1627                          call flush_datacard;                                      allocate
 1628                          olddp = dp; olddpoffset = 0;                              allocate
 1629                       end;                                                         allocate
 1630                    else                                                            allocate
 1631                       do;                                                          allocate
 1632                          dp = dp + 1; dpoffset = 0;                                allocate
 1633                       end;                                                         allocate
 1634                 newdpoffset = dim mod 4;                                           allocate
 1635                 newdp = dp + dim/4;                                                allocate
 1636                 j = dp; k = 1;                                                     allocate
 1637              end;                                                                  allocate
 1638              do;  /*  case 9 -- FORWARDTYPE */                                     allocate case 9.
 1639                 j = findlabel; k = 4;                                              allocate
 1640                 newdp = dp; newdpoffset = dpoffset; /* copy old pointers  */       allocate
 1641              end;                                                                  allocate
 1642              ;    /*  case 10 -- DESCRIPT */                                       allocate case 10.
 1643              ;    /*  case 11 -- SPECIAL */                                        allocate case 11.
 1644              ;    /*  case 12 -- FORWARDCALL */                                    allocate case 12.
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 58
 line    source statement                                                               procedure and compiler information
 
 1645              ;    /*  case 13 -- PROCTYPE */                                       allocate case 13.
 1646              ;    /*  case 14 -- CHARPROCTYPE */                                   allocate case 14.
 1647           end; /* case on type (p) */                                              allocate case 15.
 1648           sytype (fixl(p)) = type (p);                                             allocate
 1649           sytloc (fixl (p)) = j;                                                   allocate
 1650           sytseg (fixl (p)) = k;                                                   allocate
 1651     end allocate;                                                                  allocate
 
symbol table dump
 
symbol          type       loc   segment defined ref count
dim             fixed      9608     data   1596       6
j               fixed      9609     data   1600       5
k               fixed      9610     data   1600       5
p               fixed      9607     data   1596       5
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 59
 line    source statement                                                               procedure and compiler information
 
 1652                                                                                    tdeclare
 1653        olddp = dp;                                                                 tdeclare
 1654        olddsp = dsp;                                                               tdeclare
 1655        olddpoffset = dpoffset;                                                     tdeclare
 1656        type(mp) = type(sp);                                                        tdeclare
 1657        casep = fixl(mp);                                                           tdeclare
 1658        do i = 1 to inx(mp);                                                        tdeclare
 1659           fixl(mp) = casestack(casep+i); /* symbol table pointer */                tdeclare
 1660           call allocate (mp,dim);                                                  tdeclare
 1661           dp = newdp;                                                              tdeclare
 1662           dsp = newdsp;                                                            tdeclare
 1663           dpoffset = newdpoffset;                                                  tdeclare
 1664           end;                                                                     tdeclare
 1665        dp = olddp;                                                                 tdeclare
 1666        dsp = olddsp;                                                               tdeclare
 1667        dpoffset = olddpoffset;                                                     tdeclare
 1668  end tdeclare;                                                                     tdeclare
 
symbol table dump
 
symbol          type       loc   segment defined ref count
allocate        procedure  3644  program   1595       1
  parameter  1  fixed      9607     data   1596       6
  parameter  2  fixed      9608     data   1596       7
dim             fixed      9605     data   1591       1
i               fixed      9606     data   1594       3
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 60
 line    source statement                                                               procedure and compiler information
 
 1669  check_string_overflow:                                                           *
 1670     procedure;                                                                    *
 1671        /* generate a check to see if compactify needs to be called */              check_string_overflow
 1672        call emitinst (pushj,15,0,string_check,0,2);                                check_string_overflow
 1673  end check_string_overflow;                                                        check_string_overflow
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 61
 line    source statement                                                               procedure and compiler information
 
 1674  callsub:procedure (sl,f,p);                                                      *
 1675        /* generates code to call a function or procedure at sl                     callsub
 1676           also does housekeeping for return values                                 callsub
 1677        */                                                                          callsub
 1678        declare sl fixed, f fixed, p fixed;                                         callsub
 1679        call save_acs (11);                                                         callsub
 1680        call emitinst (pushj,15,0,sl,0,sytseg(fixl(p)));                            callsub
 1681        call restore_acs (11);                                                      callsub
 1682        if f = 1 then                                                               callsub
 1683           do;  /* move returned value from register zero */                        callsub
 1684              i = findar;                                                           callsub
 1685              if i ~= 0 then call emitinst (move,i,0,0,0,0);                        callsub
 1686              type(p) = ACCUMULATOR;                                                callsub
 1687              reg(p) = i;                                                           callsub
 1688              acc(i) = BUSY;                                                        callsub
 1689              stillinzero = i;                                                      callsub
 1690           end;                                                                     callsub
 1691  end callsub;                                                                      callsub
 
symbol table dump
 
symbol          type       loc   segment defined ref count
f               fixed      9613     data   1674       1
p               fixed      9614     data   1674       3
sl              fixed      9612     data   1674       1
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 62
 line    source statement                                                               procedure and compiler information
 
 1692  backup:                                                                          *
 1693     procedure;                                                                    *
 1694           code_full(code_head) = FALSE;                                            backup
 1695           code_head = (code_head-1) & 3;                                           backup
 1696           instruct(move) = instruct(move) -1;                                      backup
 1697           pp = pp - 1;                                                             backup
 1698           stillinzero = 0;                                                         backup
 1699           if control(byte('E')) then                                               backup
 1700              call printline (backmsg,-1);                                          backup
 1701     end backup;                                                                    backup
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 63
 line    source statement                                                               procedure and compiler information
 
 1702  delete_move:                                                                     *
 1703     procedure (p,op,ac,ind,operand,index,reloc);                                  *
 1704     /*  check stillinzero flag to see if the datum about to                        delete_move
 1705          be moved is still in register zero.  if so, then delete                   delete_move
 1706          the last instruction generated (if a "move"),                             delete_move
 1707          and move it directly from 0 to the desried dest.                          delete_move
 1708          this is designed to eliminate most extra moves                            delete_move
 1709          of function results. */                                                   delete_move
 1710        declare p fixed;                                                            delete_move
 1711        declare op fixed, ac fixed, ind fixed, operand fixed,                       delete_move
 1712             index fixed, reloc fixed;                                              delete_move
 1713        if stillinzero ~= 0 then                                                    delete_move
 1714           do;                                                                      delete_move
 1715              if op = movem & stillinzero = ac then                                 delete_move
 1716                 do;                                                                delete_move
 1717                    call backup;                                                    delete_move
 1718                    acc(reg(p)) = AVAIL;                                            delete_move
 1719                    reg(p) = 0;                                                     delete_move
 1720                    ac = 0;                                                         delete_move
 1721                 end;                                                               delete_move
 1722              else if op = move  & stillinzero = operand                            delete_move
 1723                                 & (ind + index + reloc) = 0 then                   delete_move
 1724                 do;                                                                delete_move
 1725                    call backup;                                                    delete_move
 1726                    acc(reg(p)) = AVAIL;                                            delete_move
 1727                    reg(p) = 0;                                                     delete_move
 1728                    operand = 0;                                                    delete_move
 1729                 end;                                                               delete_move
 1730           end;                                                                     delete_move
 1731        call emitinst (op,ac,ind,operand,index,reloc);                              delete_move
 1732     end delete_move;                                                               delete_move
 
symbol table dump
 
symbol          type       loc   segment defined ref count
ac              fixed      9617     data   1703       3
ind             fixed      9618     data   1703       2
index           fixed      9620     data   1703       2
op              fixed      9616     data   1703       3
operand         fixed      9619     data   1703       3
p               fixed      9615     data   1703       4
reloc           fixed      9621     data   1703       2
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 64
 line    source statement                                                               procedure and compiler information
 
 1733  emit_inline:                                                                     *
 1734     procedure (flag);                                                             *
 1735     /* generate an arbitrary instruction specified by programmer */                emit_inline
 1736        declare flag bit(1);                                                        emit_inline
 1737        declare fl fixed;                                                           emit_inline
 1738        declare inst(5) fixed;                                                      emit_inline
 1739        declare binlm character initial ('improper argument to inline');            emit_inline
 1740        if cnt(mp) < 5 then                                                         emit_inline
 1741           do;                                                                      emit_inline
 1742              if type(mpp1) = CONSTANT then inst(cnt(mp)-1) = fixv(mpp1);           emit_inline
 1743              else call error (binlm,1);                                            emit_inline
 1744              if flag then call error (binlm,1);                                    emit_inline
 1745           end;                                                                     emit_inline
 1746        else if cnt(mp) = 5 then                                                    emit_inline
 1747           do;                                                                      emit_inline
 1748              if type(mpp1) = CONSTANT then                                         emit_inline
 1749                 do;                                                                emit_inline
 1750                    inst(4) = fixv(mpp1);                                           emit_inline
 1751                    inst(5) = 0;                                                    emit_inline
 1752                 end;                                                               emit_inline
 1753              else if type(mpp1) = VARIABLE then                                    emit_inline
 1754                 do;                                                                emit_inline
 1755                    fl = fixl(mpp1);                                                emit_inline
 1756                    inst(4) = sytloc(fl);                                           emit_inline
 1757                    inst(5) = sytseg(fl);                                           emit_inline
 1758                 end;                                                               emit_inline
 1759              else call error (binlm,1);                                            emit_inline
 1760              call emitinst (inst(0),inst(1),inst(2),inst(4),inst(3),inst(5));      emit_inline
 1761              reg(mp) = inst(1);                                                    emit_inline
 1762              type(mp) = ACCUMULATOR;                                               emit_inline
 1763           end;                                                                     emit_inline
 1764        else call error (binlm,1);  /* too many args to inline */                   emit_inline
 1765     end emit_inline;                                                               emit_inline
 
symbol table dump
 
symbol          type       loc   segment defined ref count
binlm           character   825   string   1739       4
fl              fixed      9623     data   1737       3
flag            bit (9)    9622     data   1734       1
inst            fixed      9624     data   1738      12
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 65
 line    source statement                                                               procedure and compiler information
 
 1766  library_call:   procedure (result, code, mp, sp);                                *
 1767     /*                                                                             library_call
 1768     generate the code for a call to the run-time routines.                         library_call
 1769     */                                                                             library_call
 1770     declare result fixed,   /* 0 = l.h.s. of = */                                  library_call
 1771             code fixed,     /* code for run-time routine*/                         library_call
 1772             mp   fixed,     /* stack pointer */                                    library_call
 1773             sp   fixed;     /* top of stack pointer */                             library_call
 1774     declare r    fixed;                                                            library_call
 1775                                                                                    library_call
 1776     if result = 0 then                                                             library_call
 1777        do;                                                                         library_call
 1778           if stillinzero = reg(sp) then                                            library_call
 1779              do;                                                                   library_call
 1780                 call backup;                                                       library_call
 1781                 acc(reg(sp)) = AVAIL;                                              library_call
 1782                 reg(sp) = 0;                                                       library_call
 1783              end;                                                                  library_call
 1784           r = reg(sp);                                                             library_call
 1785        end;                                                                        library_call
 1786     else                                                                           library_call
 1787        r = findar;                                                                 library_call
 1788     if cnt(mp) > 0 then call emitinst (code+1,r,0,0,reg(mp),0);                    library_call
 1789                    else call emitinst (code+1,r,0,0,0,0);                          library_call
 1790     if result ~= 0 then                                                            library_call
 1791        do;                                                                         library_call
 1792           reg(mp) = r;                                                             library_call
 1793           type(mp) = result;                                                       library_call
 1794        end;                                                                        library_call
 1795     end library_call;                                                              library_call
 
symbol table dump
 
symbol          type       loc   segment defined ref count
code            fixed      9638     data   1766       2
mp              fixed      9639     data   1766       4
r               fixed      9641     data   1774       5
result          fixed      9637     data   1766       3
sp              fixed      9640     data   1766       4
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 66
 line    source statement                                                               procedure and compiler information
 
 1796  monitor_call:   procedure (code, p, jobflg);                                     *
 1797     /*                                                                             monitor_call
 1798     routine to generate code for pdp-10 calli uuo.                                 monitor_call
 1799     */                                                                             monitor_call
 1800     declare code  fixed,    /* calli number */                                     monitor_call
 1801            jobflg fixed,  /* clear ac flag */                                      monitor_call
 1802             p     fixed;    /* stack pointer*/                                     monitor_call
 1803     declare r     fixed;    /* contains register to use */                         monitor_call
 1804                                                                                    monitor_call
 1805     r = findar;                                                                    monitor_call
 1806     if jobflg then call emitinst (movei,r,0,0,0,0);                                monitor_call
 1807     call emitinst (calli,r,0,code,0,0);                                            monitor_call
 1808     reg(p) = r;                                                                    monitor_call
 1809     type(p) = ACCUMULATOR;                                                         monitor_call
 1810  end monitor_call;                                                                 monitor_call
 
symbol table dump
 
symbol          type       loc   segment defined ref count
code            fixed      9642     data   1796       1
jobflg          fixed      9643     data   1796       1
p               fixed      9644     data   1796       2
r               fixed      9645     data   1803       4
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 67
 line    source statement                                                               procedure and compiler information
 
 1811  forceaccumulator:procedure (p);                                                  *
 1812        declare p fixed;                                                            forceaccumulator
 1813        /* force the operand at p into an ACCUMULATOR */                            forceaccumulator
 1814        declare sl fixed, tp fixed, sfp fixed, ss fixed;                            forceaccumulator
 1815        declare t1 character;                                                       forceaccumulator
 1816        declare r fixed;                                                            forceaccumulator
 1817        count_force = count_force + 1;                                              forceaccumulator
 1818        tp = type(p);                                                               forceaccumulator
 1819        if tp = VARIABLE then                                                       forceaccumulator
 1820            do;                                                                     forceaccumulator
 1821              sl = sytloc(fixl(p));                                                 forceaccumulator
 1822              ss = sytseg(fixl(p));                                                 forceaccumulator
 1823              sfp = sytype(fixl(p));                                                forceaccumulator
 1824              if sfp = PROCTYPE | sfp = FORWARDCALL | sfp = CHARPROCTYPE then       forceaccumulator
 1825                 do;                                                                forceaccumulator
 1826                    call callsub (sl,calltype,p);                                   forceaccumulator
 1827                    r = fixl(p)+cnt(p)+1;                                           forceaccumulator
 1828                    if length(syt(r)) = 0 then                                      forceaccumulator
 1829                       if r <= ndecsy then                                          forceaccumulator
 1830                          call printline ('** warning--not all parameters supplied.',-1); forceaccumulator
 1831                    if sfp = CHARPROCTYPE then type(p) = DESCRIPT;                  forceaccumulator
 1832                 end;                                                               forceaccumulator
 1833              else if sfp = SPECIAL then                                            forceaccumulator
 1834                 do;                                                                forceaccumulator
 1835                    if sl = 6 then                                                  forceaccumulator
 1836                       do;  /* builtin function input */                            forceaccumulator
 1837                          call check_string_overflow;                               forceaccumulator
 1838                          call emitinst (move,13,0,tsa,0,1);                        forceaccumulator
 1839                          call library_call (DESCRIPT,1,p,0);                       forceaccumulator
 1840                          call emitinst (movem,13,0,tsa,0,1);                       forceaccumulator
 1841                          call emitinst (movem,12,0,str,0,3);                       forceaccumulator
 1842                       end;                                                         forceaccumulator
 1843                    else if sl = 8 then                                             forceaccumulator
 1844                       do;  /* built-in function file */                            forceaccumulator
 1845                        if cnt(p) ~= 1 then call error (filemsg,0);                 forceaccumulator
 1846                           else call library_call (ACCUMULATOR,5,p,0);              forceaccumulator
 1847                       end;                                                         forceaccumulator
 1848                    else if sl = 12 then                                            forceaccumulator
 1849                       do;  /* exit */                                              forceaccumulator
 1850                          call emitinst (4,0,0,0,0,0);                              forceaccumulator
 1851                       end;                                                         forceaccumulator
 1852                    else if sl = 13 then call monitor_call (19,p,0);                forceaccumulator
 1853                    else if sl = 14 then call monitor_call (12,p,0);                forceaccumulator
 1854                    else if sl = 19 then call monitor_call (23,p,1);                forceaccumulator
 1855                    else call error ('illegal use of ' || syt(fixl(p)),0);          forceaccumulator
 1856                 end;                                                               forceaccumulator
 1857              else                                                                  forceaccumulator
 1858                 do;  /* fetch the VARIABLE (all else has failed) */                forceaccumulator
 1859                    if sfp ~= BYTETYPE then                                         forceaccumulator
 1860                       do;   /* we don't have to do crazy addressing */             forceaccumulator
 1861                          r = findar;     /* get reg for result */                  forceaccumulator
 1862                          call emitinst (move,r,0,sl,inx(p),ss);                    forceaccumulator
 1863                       end;                                                         forceaccumulator
 1864                    else                                                            forceaccumulator
 1865                       do;  /* byte addressing */                                   forceaccumulator
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 68
 line    source statement                                                               procedure and compiler information
 
 1866                          if inx(p) ~= 0 then                                       forceaccumulator
 1867                             do; /* good grief, subscripting of bytes */            forceaccumulator
 1868                                r = findar;                                         forceaccumulator
 1869                                call emitinst (move,12,0,inx(p),0,0);               forceaccumulator
 1870                                call emitinst (lsh,12,0,    -2,0,0);                forceaccumulator
 1871                                call emitinst (andi,inx(p),0,3,0,0);                forceaccumulator
 1872                                if (sl | ss) ~= 0 then call emitinst (addi,12,0,sl,0,ss); forceaccumulator
 1873                                call emitinst (ldb,r,0,byteptrs,inx(p),1);          forceaccumulator
 1874                             end;                                                   forceaccumulator
 1875                           else                                                     forceaccumulator
 1876                             do; /* non-subscripted byte */                         forceaccumulator
 1877                                r = findar;                                         forceaccumulator
 1878                                call emitinst (movei,12,0,sl,0,ss);                 forceaccumulator
 1879                                call emitinst (ldb,r,0,byteptrs,0,1);               forceaccumulator
 1880                             end;                                                   forceaccumulator
 1881                       end;                                                         forceaccumulator
 1882                    if sfp = CHRTYPE then type(p) = DESCRIPT;                       forceaccumulator
 1883                    else type(p) = ACCUMULATOR;                                     forceaccumulator
 1884                    reg(p) = r;                                                     forceaccumulator
 1885                    if inx(p) ~= 0 then acc(inx(p)) = AVAIL;                        forceaccumulator
 1886                 end;                                                               forceaccumulator
 1887           end;                                                                     forceaccumulator
 1888        else if tp = CONSTANT then                                                  forceaccumulator
 1889           do;  /* fetch a CONSTANT into an ACCUMULATOR */                          forceaccumulator
 1890              r = findar;                                                           forceaccumulator
 1891              if fixv(p) < "20000" & fixv(p) > - "20000" then                       forceaccumulator
 1892                 call emitinst (hrrei,r,0,fixv(p),0,0);                             forceaccumulator
 1893              else                                                                  forceaccumulator c18 = -131072
 1894                 do;  /* put down a CONSTANT and pick it up */                      forceaccumulator
 1895                    call emitconstant (fixv(p));                                    forceaccumulator
 1896                    call emitinst (move,r,0,adr,0,1);                               forceaccumulator
 1897                 end;                                                               forceaccumulator
 1898              reg(p) = r;                                                           forceaccumulator
 1899              type(p) = ACCUMULATOR;                                                forceaccumulator
 1900           end;                                                                     forceaccumulator
 1901        else if tp = CHRTYPE then                                                   forceaccumulator
 1902           do;  /* fetch a descriptor into an ACCUMULATOR */                        forceaccumulator
 1903              r = findar;                                                           forceaccumulator
 1904              type(p) = DESCRIPT;                                                   forceaccumulator
 1905              reg(p) = r;                                                           forceaccumulator
 1906              t1 = var(p);                                                          forceaccumulator
 1907              sl = length(t1);                                                      forceaccumulator
 1908              if sl = 0 then call emitinst (movei,r,0,0,0,0);                       forceaccumulator
 1909              else                                                                  forceaccumulator
 1910                 do;  /* generate descriptor and string, then pick it up */         forceaccumulator
 1911                    call emitinst (move,r,0,dsp,0,3);                               forceaccumulator
 1912                    call emitdesc (sl,shl(dp,2)+dpoffset);                          forceaccumulator
 1913                    do sl = 0 to sl-1;                                              forceaccumulator
 1914                       call emitbyte (byte(t1,sl));                                 forceaccumulator
 1915                    end;                                                            forceaccumulator
 1916                 end;                                                               forceaccumulator
 1917           end;                                                                     forceaccumulator
 1918        else if tp ~= ACCUMULATOR then if tp ~= DESCRIPT then                       forceaccumulator
 1919                 call error ('forceaccumulator failed ***',1);                      forceaccumulator
 1920  end forceaccumulator;                                                             forceaccumulator
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 69
 line    source statement                                                               procedure and compiler information
 
 
symbol table dump
 
symbol          type       loc   segment defined ref count
p               fixed      9646     data   1811      34
r               fixed      9651     data   1816      18
sfp             fixed      9649     data   1814       8
sl              fixed      9647     data   1814      18
ss              fixed      9650     data   1814       5
t1              character   826   string   1815       3
tp              fixed      9648     data   1814       6
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 70
 line    source statement                                                               procedure and compiler information
 
 1921  forcedescriptor:                                                                 *
 1922     procedure (p);                                                                *
 1923        /* get a descriptor for the operand p */                                    forcedescriptor
 1924        declare p fixed;                                                            forcedescriptor
 1925        call forceaccumulator (p);                                                  forcedescriptor
 1926        if type (p) ~= DESCRIPT then                                                forcedescriptor
 1927           do; /* use the number to decimal string conversion routine */            forcedescriptor
 1928              call delete_move (p,movem,reg(p),0,c,0,1);  /* save as c */           forcedescriptor
 1929              acc(reg(p)) = AVAIL;                                                  forcedescriptor
 1930              call save_acs (1);                                                    forcedescriptor
 1931              call emitinst (pushj,15,0,nmbrentry,0,2);                             forcedescriptor
 1932              call restore_acs (1);                                                 forcedescriptor
 1933              acc(reg(p)) = BUSY;                                                   forcedescriptor
 1934              if reg(p) ~= 0 then call emitinst (move,reg(p),0,0,0,0);              forcedescriptor
 1935              type (p) = DESCRIPT;             /* it is now a string */             forcedescriptor
 1936              stillinzero = reg(p);                                                 forcedescriptor
 1937           end;                                                                     forcedescriptor
 1938  end forcedescriptor;                                                              forcedescriptor
 
symbol table dump
 
symbol          type       loc   segment defined ref count
p               fixed      9675     data   1922      10
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 71
 line    source statement                                                               procedure and compiler information
 
 1939  genstore:procedure (mp, sp);                                                     *
 1940        declare mp fixed, sp fixed;                                                 genstore
 1941        /* generate type conversion (if necessary) & storage code --                genstore
 1942           also handles output on the left of the replacement operator              genstore
 1943        */                                                                          genstore
 1944        declare sl fixed, sfp fixed, ss fixed;                                      genstore
 1945        count_store = count_store + 1;                                              genstore
 1946        sl = sytloc(fixl(mp));                                                      genstore
 1947        ss = sytseg(fixl(mp));                                                      genstore
 1948        sfp = sytype(fixl(mp));                                                     genstore
 1949        if sfp = SPECIAL then                                                       genstore
 1950           do;                                                                      genstore
 1951              if sl = 7 then                                                        genstore
 1952                 do;  /* builtin function output */                                 genstore
 1953                    call forcedescriptor(sp);                                       genstore
 1954                    call library_call (0,2,mp,sp);                                  genstore
 1955                 end;                                                               genstore
 1956              else if sl = 8 then                                                   genstore
 1957                 do;   /* builtin function file */                                  genstore
 1958                    if cnt(mp) ~= 1 then                                            genstore
 1959                       call error (filemsg,0);                                      genstore
 1960                    call forceaccumulator (sp);                                     genstore
 1961                    call library_call (0,6,mp,sp);                                  genstore
 1962                 end;                                                               genstore
 1963              else if sl = 20 then                                                  genstore
 1964                 do;    /* built-in function  filename */                           genstore
 1965                    call forcedescriptor(sp);                                       genstore
 1966                    call library_call (0,7,mp,sp);                                  genstore
 1967                 end;                                                               genstore
 1968              else call error ('illegal use of ' || syt(fixl(mp)),0);               genstore
 1969           end;                                                                     genstore
 1970        else                                                                        genstore
 1971           do;                                                                      genstore
 1972              if sfp = CHRTYPE then                                                 genstore
 1973                 do;                                                                genstore
 1974                    call forcedescriptor(sp);                                       genstore
 1975                    call delete_move (sp,movem,reg(sp),0,sl,inx(mp),ss);            genstore
 1976                 end;                                                               genstore
 1977              else if type(sp) = DESCRIPT | type(sp) = CHRTYPE then                 genstore
 1978                   call error ('assignment requires illegal type conversion.',0);   genstore
 1979              else                                                                  genstore
 1980                 do;     /* FIXEDTYPE or BYTETYPE */                                genstore
 1981                    if sfp = FIXEDTYPE then                                         genstore
 1982                       do;                                                          genstore
 1983                       if type(sp) = CONSTANT & fixv(sp) = 0 then                   genstore
 1984                          call emitinst(setzm,0,0,sl,inx(mp),ss);                   genstore
 1985                          else                                                      genstore
 1986                             do;                                                    genstore
 1987                                call forceaccumulator(sp);                          genstore
 1988                                call delete_move (sp,movem,reg(sp),0,sl,inx(mp),ss); genstore
 1989                             end;                                                   genstore
 1990                       end;                                                         genstore
 1991                    else                                                            genstore
 1992                       do;      /* must be BYTETYPE */                              genstore
 1993                          call forceaccumulator(sp);                                genstore
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 72
 line    source statement                                                               procedure and compiler information
 
 1994                          if inx(mp) ~= 0 then                                      genstore
 1995                             do;  /* good grief, subscripting */                    genstore
 1996                                 call emitinst (move,12,0,inx(mp),0,0);             genstore
 1997                                 call emitinst (lsh,12,0,    -2,0,0);               genstore
 1998                                 call emitinst (andi,inx(mp),0,3,0,0);              genstore
 1999                                 if (sl | ss) ~= 0 then call emitinst (addi,12,0,sl,0,ss); genstore
 2000                                 call emitinst (dpb,reg(sp),0,byteptrs,inx(mp),1);  genstore
 2001                             end;                                                   genstore
 2002                          else                                                      genstore
 2003                             do;                                                    genstore
 2004                                 call emitinst (movei,12,0,sl,0,ss);                genstore
 2005                                 call emitinst (dpb,reg(sp),0,byteptrs,0,1);        genstore
 2006                             end;                                                   genstore
 2007                       end;                                                         genstore
 2008                 end;                                                               genstore
 2009           end;                                                                     genstore
 2010        acc(inx(mp)) = AVAIL;                                                       genstore
 2011        call movestacks (sp,mp);                                                    genstore
 2012  end genstore;                                                                     genstore
 
symbol table dump
 
symbol          type       loc   segment defined ref count
mp              fixed      9676     data   1939      17
sfp             fixed      9679     data   1944       4
sl              fixed      9678     data   1944      10
sp              fixed      9677     data   1939      20
ss              fixed      9680     data   1944       7
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 73
 line    source statement                                                               procedure and compiler information
 
 2013  shouldcommute:procedure;                                                         *
 2014        if type(sp) = CONSTANT then return (FALSE);                                 shouldcommute
 2015        if type(mp) = CONSTANT then return (TRUE);                                  shouldcommute
 2016        if type(sp) = VARIABLE & sytype(fixl(sp)) = FIXEDTYPE then return (FALSE);  shouldcommute
 2017        if type(mp) = VARIABLE & sytype(fixl(mp)) = FIXEDTYPE then return (TRUE);   shouldcommute
 2018        return FALSE;                                                               shouldcommute
 2019  end shouldcommute;                                                                shouldcommute
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 74
 line    source statement                                                               procedure and compiler information
 
 2020  arithemit:procedure(op,commutative);                                             *
 2021     declare op fixed, commutative fixed, tp fixed;                                 arithemit
 2022     declare awasd character initial ('arithmetic with a string descriptor');       arithemit
 2023     /* emit an instruction for an infix operator -- connect mp & sp */             arithemit
 2024     count_arith = count_arith + 1;                                                 arithemit
 2025     tp = 0;                                                                        arithemit
 2026     if commutative then                                                            arithemit
 2027        if shouldcommute then                                                       arithemit
 2028           do;                                                                      arithemit
 2029              tp = mp; mp = sp; sp = tp;                                            arithemit
 2030              if op >= cam & op <= cmprhi then op = compareswap(op-cam)+cam;        arithemit
 2031           end;                                                                     arithemit
 2032     call forceaccumulator(mp);  /* get the left one into an ACCUMULATOR */         arithemit
 2033     if type(mp) = DESCRIPT then call error (awasd,0);                              arithemit
 2034     else if type(sp) = VARIABLE & sytype(fixl(sp)) = FIXEDTYPE then                arithemit
 2035        do;  /* operate from storage */                                             arithemit
 2036           call emitinst (op,reg(mp),0,sytloc(fixl(sp)),inx(sp),sytseg(fixl(sp)));  arithemit
 2037           acc(inx(sp)) = AVAIL;                                                    arithemit
 2038                                                                                    arithemit
 2039        end;                                                                        arithemit
 2040     else if type(sp) = CONSTANT then                                               arithemit
 2041        do;                                                                         arithemit
 2042           if fixv(sp) < "40000" & fixv(sp) >= 0 then /* use immediate */           arithemit
 2043              do;                                                                   arithemit
 2044                 if op >= cam & op <= cmprhi then op=op-9; /* sob code order */     arithemit
 2045                    call emitinst(op+1,reg(mp),0,fixv(sp),0,0);                     arithemit
 2046              end;                                                                  arithemit
 2047           else                                                                     arithemit
 2048              do;                                                                   arithemit
 2049                 call emitconstant (fixv(sp));                                      arithemit
 2050                 call emitinst (op,reg(mp),0,adr,0,1);                              arithemit
 2051              end;                                                                  arithemit
 2052        end;                                                                        arithemit
 2053     else                                                                           arithemit
 2054         do;                                                                        arithemit
 2055           call forceaccumulator(sp);                                               arithemit
 2056           if type(sp) ~= ACCUMULATOR then call error (awasd,0);                    arithemit
 2057           else call emitinst (op,reg(mp),0,reg(sp),0,0);                           arithemit
 2058           acc(reg(sp)) = AVAIL;                                                    arithemit
 2059        end;                                                                        arithemit
 2060     if tp ~= 0 then                                                                arithemit
 2061        do;                                                                         arithemit
 2062           sp = mp; mp = tp;                                                        arithemit
 2063           call movestacks (sp,mp);                                                 arithemit
 2064        end;                                                                        arithemit
 2065  end arithemit;                                                                    arithemit
 
symbol table dump
 
symbol          type       loc   segment defined ref count
awasd           character   832   string   2022       2
commutative     fixed      9697     data   2020       1
op              fixed      9696     data   2020      12
tp              fixed      9698     data   2021       5
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 75
 line    source statement                                                               procedure and compiler information
 
 2066  boolbranch:procedure (sp,mp);                                                    *
 2067     declare sp fixed, mp fixed, r fixed;                                           boolbranch
 2068     /* generate a conditional branch for do while or an if statement               boolbranch
 2069        place the address of this branch in fixl(mp)                                boolbranch
 2070     */                                                                             boolbranch
 2071     if stillcond ~= 0 then                                                         boolbranch
 2072        do;  /* we have not generated code since setting the condition */           boolbranch
 2073           /* remove the movei =1 and movei =0 around the cam? */                   boolbranch
 2074           code_head = (code_head-2) &3; /* back up ptr */                          boolbranch
 2075           r = (code_head + 1) & 3;                                                 boolbranch
 2076           code(code_head) = code(r);                                               boolbranch
 2077           code_rel(code_head) = code_rel(r);                                       boolbranch
 2078           code_pp(code_head) = code_pp(r) -1;                                      boolbranch
 2079           code_rbits(code_head) = code_rbits(r);                                   boolbranch
 2080           code_full(r) = FALSE;                                                    boolbranch
 2081           code_full(r+1&3) = FALSE;                                                boolbranch
 2082           pp = pp - 2;                                                             boolbranch
 2083           code(code_head) = code(code_head) || ' p' || pp-1;                       boolbranch
 2084           if control(byte('E')) then                                               boolbranch
 2085              do;                                                                   boolbranch
 2086                 call printline (backmsg,-1);                                       boolbranch
 2087                 call printline (codemsg || code(code_head),-1);                    boolbranch
 2088              end;                                                                  boolbranch
 2089           instruct(movei) = instruct(movei) - 2;                                   boolbranch
 2090           acc(reg(sp)) = AVAIL;          /* free condition register */             boolbranch
 2091           r = 4;                         /* jump always */                         boolbranch
 2092        end;                                                                        boolbranch
 2093     else                                                                           boolbranch
 2094        do;                                                                         boolbranch
 2095           call forceaccumulator(sp);                                               boolbranch
 2096           call emitinst (andi,reg(sp),0,1,0,0);  /* test only low order bit */     boolbranch
 2097           acc(reg(sp)) = AVAIL;          /* free up VARIABLE register */           boolbranch
 2098           r = 2;                         /* jump if register zero */               boolbranch
 2099        end;                                                                        boolbranch
 2100     fixl(mp) = findlabel;                /* get a new label */                     boolbranch
 2101     call emitinst (jump+r,reg(sp),0,fixl(mp),0,4);                                 boolbranch
 2102  end boolbranch;                                                                   boolbranch
 
symbol table dump
 
symbol          type       loc   segment defined ref count
mp              fixed      9709     data   2066       2
r               fixed      9710     data   2067      10
sp              fixed      9708     data   2066       5
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 76
 line    source statement                                                               procedure and compiler information
 
 2103  setlimit:                                                                        *
 2104     procedure;                                                                    *
 2105        /* sets do loop limit for <iteration control> */                            setlimit
 2106        if type (mpp1) = CONSTANT then                                              setlimit
 2107           call emitconstant (fixv(mpp1));                                          setlimit
 2108        else                                                                        setlimit
 2109           do;                                                                      setlimit
 2110              call forceaccumulator (mpp1);  /* get loop limit */                   setlimit
 2111              call emitdataword (0);                                                setlimit
 2112              adr = dp - 1;                                                         setlimit
 2113              call emitinst(movem,reg(mpp1),0,adr,0,1); /* save it */               setlimit
 2114              acc(reg(mpp1)) = AVAIL;                                               setlimit
 2115           end;                                                                     setlimit
 2116        fixv (mp) = adr;                                                            setlimit
 2117   end setlimit;                                                                    setlimit
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 77
 line    source statement                                                               procedure and compiler information
 
 2118  stuff_parameter:                                                                 *
 2119     procedure;                                                                    *
 2120        /* generate code to send an actual parameter to a procedure */              stuff_parameter
 2121        declare (i,j) fixed;                                                        stuff_parameter
 2122        i = fixl (mp) + cnt (mp);  j = sytloc (i);                                  stuff_parameter
 2123        if length (syt(i)) = 0 then                                                 stuff_parameter
 2124           do;                                                                      stuff_parameter
 2125              sytco (i) = sytco (i) + 1;  /* count the reference                */  stuff_parameter
 2126                 do;                                                                stuff_parameter
 2127                    if sytype(i) = BYTETYPE then                                    stuff_parameter
 2128                      do;                                                           stuff_parameter
 2129                         call forceaccumulator(mpp1);                               stuff_parameter
 2130                         call emitinst (movei,12,0,j,0,sytseg(i));                  stuff_parameter
 2131                         call emitinst (dpb,reg(mpp1),0,byteptrs,0,1);              stuff_parameter
 2132                      end;                                                          stuff_parameter
 2133                    else                                                            stuff_parameter
 2134                      do;                                                           stuff_parameter
 2135                         if type(mpp1) = CONSTANT & fixv(mpp1) = 0 then             stuff_parameter
 2136                            do;                                                     stuff_parameter
 2137                               call emitinst (setzm,0,0,j,0,sytseg(i));             stuff_parameter
 2138                               return;                                              stuff_parameter
 2139                            end;                                                    stuff_parameter
 2140                         call forceaccumulator (mpp1);                              stuff_parameter
 2141                         call delete_move (mpp1,movem,reg(mpp1),0,j,0,sytseg(i));   stuff_parameter
 2142                      end;                                                          stuff_parameter
 2143                    acc(reg(mpp1)) = AVAIL;                                         stuff_parameter
 2144                 end;                                                               stuff_parameter
 2145           end;                                                                     stuff_parameter
 2146        else                                                                        stuff_parameter
 2147           call error ('too many actual parameters', 1);                            stuff_parameter
 2148  end stuff_parameter;                                                              stuff_parameter
 
symbol table dump
 
symbol          type       loc   segment defined ref count
i               fixed      9712     data   2121       9
j               fixed      9713     data   2121       4
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 78
 line    source statement                                                               procedure and compiler information
 
 2149  divide_code:procedure(t);                                                        *
 2150     declare t fixed, i fixed;                                                      divide_code
 2151     /* emit code to perform a divide (t=1) or mod (t=0) */                         divide_code
 2152     /* find a free register pair for the dividend */                               divide_code
 2153     if type(mp) = ACCUMULATOR then                                                 divide_code
 2154        do;   /* we may be able to use the register to the right */                 divide_code
 2155           i = reg(mp);                                                             divide_code
 2156           if acc(i+1) = AVAIL then goto fits;                                      divide_code
 2157        end;                                                                        divide_code
 2158     do i = t to 11;                                                                divide_code
 2159        if acc(i) = AVAIL then if acc(i+1) = AVAIL then goto fit;                   divide_code
 2160     end;                                                                           divide_code
 2161     call error ('no free registers for division or mod.',0);                       divide_code
 2162     return;                                                                        divide_code
 2163  fit:                                                                              divide_code
 2164     target_register = i;                                                           divide_code
 2165     call forceaccumulator(mp);                                                     divide_code
 2166     target_register = -1;                                                          divide_code
 2167     if reg(mp) ~= i then                                                           divide_code
 2168        do;                                                                         divide_code
 2169           call emitinst (move,i,0,reg(mp),0,0);                                    divide_code
 2170           acc(reg(mp)) = AVAIL;                                                    divide_code
 2171           reg(mp) = i;                                                             divide_code
 2172        end;                                                                        divide_code
 2173        acc(i) = BUSY;                                                              divide_code
 2174   fits:                                                                            divide_code
 2175     acc(i+1) = BUSY;                                                               divide_code
 2176     call arithemit (idiv,0);                                                       divide_code
 2177     if t = 0 then                                                                  divide_code
 2178        do;  /* mod, switch register to point to remainder */                       divide_code
 2179           acc(i) = AVAIL;                /* free quotient */                       divide_code
 2180           reg(mp) = i+1;                 /* point to remainder */                  divide_code
 2181        end;                                                                        divide_code
 2182     else acc(i+1) = AVAIL;               /* free remainder */                      divide_code
 2183     if reg(mp) =12 then                                                            divide_code
 2184        do;  /* transfer the mod remainder from a scratch register */               divide_code
 2185           i = findar;                                                              divide_code
 2186           call emitinst (move,i,0,reg(mp),0,0);                                    divide_code
 2187           acc(reg(mp)) = AVAIL;                                                    divide_code
 2188           reg(mp) = i;                                                             divide_code
 2189        end;                                                                        divide_code
 2190  end divide_code;                                                                  divide_code
 
symbol table dump
 
symbol          type       loc   segment defined ref count
fit             label      5558  program   2159       1
fits            label      5589  program   2156       1
i               fixed      9722     data   2150      17
t               fixed      9721     data   2149       2
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 79
 line    source statement                                                               procedure and compiler information
 
 2191  shift_code:                                                                      *
 2192     procedure (op);                                                               *
 2193        declare op fixed;                                                           shift_code
 2194        /* generate code for the builtin functions shl and shr */                   shift_code
 2195        /* op: left = 0, right = 1 */                                               shift_code
 2196        sp = mpp1;                                                                  shift_code
 2197        if cnt (mp) ~= 2 then                                                       shift_code
 2198           call error ('shift requires two arguments', 0);                          shift_code
 2199        else                                                                        shift_code
 2200           if type (mpp1) = CONSTANT then                                           shift_code
 2201              do;                                                                   shift_code
 2202                 if op = 1 then fixv(mpp1) = -fixv(mpp1);                           shift_code
 2203                 call emitinst(lsh,reg(mp),0,fixv(mpp1),0,0);                       shift_code
 2204              end;                                                                  shift_code
 2205        else                                                                        shift_code
 2206           do;                                                                      shift_code
 2207              /* do shift with VARIABLE */                                          shift_code
 2208              call forceaccumulator(mpp1);                                          shift_code
 2209              if op = 1 then                                                        shift_code
 2210                    call emitinst (movn,reg(mpp1),0,reg(mpp1),0,0);                 shift_code
 2211              call emitinst (lsh,reg(mp),0,0,reg(mpp1),0);                          shift_code
 2212              acc(reg(mpp1)) = AVAIL;                                               shift_code
 2213           end;                                                                     shift_code
 2214        type(mp) = ACCUMULATOR;                                                     shift_code
 2215  end shift_code;                                                                   shift_code
 
symbol table dump
 
symbol          type       loc   segment defined ref count
op              fixed      9733     data   2192       2
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 80
 line    source statement                                                               procedure and compiler information
 
 2216  stringcompare:                                                                   *
 2217     procedure;                                                                    *
 2218        /* generates code to compare the strings at sp and mp.                      stringcompare
 2219           comparisons are done first on length, and second on a                    stringcompare
 2220           character by character comparison using the pdp-10 collating             stringcompare
 2221           sequence.                                                                stringcompare
 2222        */                                                                          stringcompare
 2223        call forcedescriptor (sp);                                                  stringcompare
 2224        call delete_move (sp,movem,reg(sp),0,b,0,3);                                stringcompare
 2225        acc(reg(sp)) = AVAIL;                                                       stringcompare
 2226        call forcedescriptor (mp);                                                  stringcompare
 2227        call delete_move (mp,movem,reg(mp),0,a,0,3);                                stringcompare
 2228        call save_acs (5);                                                          stringcompare
 2229        call emitinst (pushj,15,0,strcomp,0,2); /* call string compare */           stringcompare
 2230        call restore_acs (5);                                                       stringcompare
 2231        call emitinst (movei,reg(mp),0,1,0,0);                                      stringcompare
 2232         call emitinst (skip+inx(mpp1),0,0,0,0,0);                                  stringcompare
 2233        call emitinst (movei,reg(mp),0,0,0,0);                                      stringcompare
 2234        type(mp) = ACCUMULATOR;                                                     stringcompare
 2235        stillcond = inx(mpp1);                                                      stringcompare
 2236  end stringcompare;                                                                stringcompare
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 81
 line    source statement                                                               procedure and compiler information
 
 2237  symboldump:                                                                      *
 2238     procedure;                                                                    *
 2239        /* list the symbols in the procedure that has just been                     symboldump
 2240           compiled if toggle s is enabled and l is enabled.                        symboldump
 2241        */                                                                          symboldump
 2242        declare subtitle_save character;                                            symboldump
 2243        declare heading character initial ('type       loc   segment defined ref count'); symboldump
 2244        declare seg(4) character initial ('absolute','    data',' program',         symboldump
 2245                 '  string','   label');                                            symboldump
 2246        declare exchanges fixed, i fixed, lmax fixed,                               symboldump
 2247           j fixed, k fixed, l fixed, m fixed, sytsort (SYTSIZE) fixed;             symboldump
 2248        declare blanks character,                                                   symboldump
 2249                tag    character;                                                   symboldump
 2250                                                                                    symboldump
 2251     string_gt:                                                                     symboldump
 2252        procedure (a,b);                                                            symboldump
 2253           /* do an honest string comparison:                                       string_gt
 2254              xpl can be trusted only if strings are of the same length.            string_gt
 2255              if lengths differ, let xpl see only the shorter, and the              string_gt
 2256              matching part of the longer, and arrange comparisons so               string_gt
 2257              that result is right.   */                                            string_gt
 2258           declare a character,                                                     string_gt
 2259                   b character;                                                     string_gt
 2260           declare la fixed,  lb fixed;                                             string_gt
 2261                                                                                    string_gt
 2262           la = length (a);                                                         string_gt
 2263           lb = length (b);                                                         string_gt
 2264           if la = lb then return (a > b);                                          string_gt
 2265           else if la > lb then return (substr (a,0,lb) >= b);                      string_gt
 2266                else return (a > substr(b,0,la));                                   string_gt
 2267        end string_gt;                                                              string_gt
 
symbol table dump
 
symbol          type       loc   segment defined ref count
a               character   846   string   2252       4
b               character   847   string   2252       4
la              fixed     10190     data   2260       4
lb              fixed     10191     data   2260       4
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 82
 line    source statement                                                               procedure and compiler information
 
 2268                                                                                    symboldump
 2269        if control(byte('L'))  = 0 then return; /* don't dump if not listing */     symboldump
 2270        if procmark <= ndecsy then                                                  symboldump
 2271           do;                                                                      symboldump
 2272              call printline ('symbol table dump',0);                               symboldump
 2273              lmax = 15;                                                            symboldump
 2274              do i = procmark to ndecsy;  /* pad all names to the same length */    symboldump
 2275                 if length (syt (i)) > lmax then                                    symboldump
 2276                    lmax = length (syt (i));                                        symboldump
 2277                 sytsort (i) = i;                                                   symboldump
 2278              end;                                                                  symboldump
 2279              if lmax > 70 then lmax = 70;                                          symboldump
 2280              blanks = substr (x70,0,lmax);                                         symboldump
 2281              exchanges = TRUE;                                                     symboldump
 2282              k = ndecsy - procmark;                                                symboldump
 2283              do while exchanges;                                                   symboldump
 2284                 exchanges = FALSE;                                                 symboldump
 2285                 do j = 0 to k - 1;                                                 symboldump
 2286                    i = ndecsy - j;                                                 symboldump
 2287                    l = i - 1;                                                      symboldump
 2288                    if string_gt(syt (sytsort(l)),syt(sytsort(i))) then             symboldump
 2289                       do;                                                          symboldump
 2290                          m = sytsort (i);                                          symboldump
 2291                          sytsort (i) = sytsort (l);                                symboldump
 2292                          sytsort (l) = m;                                          symboldump
 2293                          exchanges = TRUE;                                         symboldump
 2294                          k = j;          /* record the last swap */                symboldump
 2295                       end;                                                         symboldump
 2296                  end;                                                              symboldump
 2297              end;                                                                  symboldump
 2298              i = procmark;                                                         symboldump
 2299              do while length (syt (sytsort (i))) = 0;                              symboldump
 2300                 i = i + 1;               /* ignore null names */                   symboldump
 2301              end;                                                                  symboldump
 2302              subtitle_save = subtitle;                                             symboldump
 2303              subtitle = 'symbol' || substr(blanks,0,lmax-5) || heading;            symboldump
 2304              call printline (subtitle,0);                                          symboldump
 2305              do i = i to ndecsy;                                                   symboldump
 2306                 k = sytsort (i);                                                   symboldump
 2307                 tag = syt(k) || substr(x70,0,lmax-length(syt(k)));                 symboldump
 2308                 call i_format (sytloc(k),5);                                       symboldump
 2309                 tag = tag || x1 || typename(sytype(k)) || x1 || i_string;          symboldump
 2310                 call i_format (sytcard(k),5);                                      symboldump
 2311                 tag = tag || x1 || seg(sytseg(k)) || x2 || i_string;               symboldump
 2312                 call i_format (sytco(k),5);                                        symboldump
 2313                 if sytco(k) = 0 then i_string = i_string || ' *';                  symboldump
 2314                 call printline (tag || x3 || i_string,-1);                         symboldump
 2315                                                                                    symboldump
 2316                 k = k + 1;                                                         symboldump
 2317                 do while (length (syt (k)) = 0) & (k <= ndecsy);                   symboldump
 2318                    j = k - sytsort (i);                                            symboldump
 2319                    tag = '  parameter  ' || j || substr(blanks,13) ||              symboldump
 2320                          typename(sytype(k));                                      symboldump c19 = 1744830451
 2321                    call i_format (sytloc(k),5);                                    symboldump
 2322                    tag = tag || x1 || i_string;                                    symboldump
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 83
 line    source statement                                                               procedure and compiler information
 
 2323                    call i_format (sytcard(k),5);                                   symboldump
 2324                    tag = tag || x1 || seg(sytseg(k)) || x2 || i_string;            symboldump
 2325                    call i_format (sytco(k),5);                                     symboldump
 2326                    call printline (tag || x3 || i_string,-1);                      symboldump
 2327                    k = k + 1;                                                      symboldump
 2328                 end;                                                               symboldump
 2329              end;                                                                  symboldump
 2330              subtitle = subtitle_save;                                             symboldump
 2331           end;                                                                     symboldump
 2332           EJECT_PAGE;                                                              symboldump
 2333  end symboldump;                                                                   symboldump
 
symbol table dump
 
symbol          type       loc   segment defined ref count
blanks          character   844   string   2248       3
exchanges       fixed      9762     data   2246       4
heading         character   838   string   2243       1
i               fixed      9763     data   2246      18
j               fixed      9765     data   2247       5
k               fixed      9766     data   2247      24
l               fixed      9767     data   2247       4
lmax            fixed      9764     data   2246       8
m               fixed      9768     data   2247       2
seg             character   839   string   2244       2
string_gt       procedure  5803  program   2251       1
  parameter  1  character   846   string   2252       5
  parameter  2  character   847   string   2252       5
subtitle_save   character   837   string   2242       2
sytsort         fixed      9769     data   2247      10
tag             character   845   string   2249      12
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 84
 line    source statement                                                               procedure and compiler information
 
 2334  dumpit:                                                                          *
 2335     procedure;                                                                    *
 2336        declare char360 character;                                                  dumpit
 2337        declare t1 character, t2 character, l fixed, ll fixed;                      dumpit
 2338        /* put out statistics kept within the compiler */                           dumpit
 2339       if top_macro >= 0 then                                                       dumpit
 2340            do; /* dump macro dictionary */                                         dumpit
 2341               call printline ( 'macro definitions:',0);                            dumpit
 2342               call printline (x1,-1);                                              dumpit
 2343               l = length (macro_name(top_macro));                                  dumpit
 2344               if l > 70 then l = 70;                                               dumpit
 2345               subtitle = 'name' || substr (x70,0,l-2) ||                           dumpit
 2346                          'at line ref count literal value';                        dumpit
 2347               call printline (subtitle,-1);                                        dumpit
 2348               do i = 0 to top_macro;                                               dumpit
 2349                  k = length (macro_name(i));                                       dumpit
 2350                  if k < l then                                                     dumpit
 2351                     do;                                                            dumpit
 2352                         char360 = substr (x70,0,l-k);                              dumpit
 2353                         macro_name (i) = macro_name (i) || char360;                dumpit
 2354                     end;                                                           dumpit
 2355                  else                                                              dumpit
 2356                     macro_name(i) = substr(macro_name(i),0,l);                     dumpit
 2357                  t1 = macro_declare(i);                                            dumpit
 2358                  t2 = macro_count(i);                                              dumpit
 2359                  ll = length (t1);                                                 dumpit
 2360                  if ll < 8 then t1 = substr(x70,0,8-ll) || t1;                     dumpit
 2361                  ll = length (t2);                                                 dumpit
 2362                  if ll < 9 then t2 = substr(x70,0,9-ll) || t2;                     dumpit
 2363                  call printline (macro_name(i) || t1 || t2 || x4 || macro_text(i),-1); dumpit
 2364               end;                                                                 dumpit
 2365            end;                                                                    dumpit
 2366        subtitle = '';                                                              dumpit
 2367        call printline (x1,-1);                                                     dumpit
 2368        call printline ('id compares       = ' || idcompares,-1);                   dumpit
 2369        call printline ('symbol table size = ' || maxndecsy,-1);                    dumpit
 2370        call printline ('macro definitions = ' || top_macro + 1,-1);                dumpit
 2371        call printline ('scan              = ' || count_scan,-1);                   dumpit
 2372        call printline ('emitinst          = ' || count_inst,-1);                   dumpit
 2373        call printline ('force ACCUMULATOR = ' || count_force,-1);                  dumpit
 2374        call printline ('arithemit         = ' || count_arith,-1);                  dumpit
 2375        call printline ('generate store    = ' || count_store,-1);                  dumpit
 2376        call printline ('free string area  = ' || freelimit - freebase,-1);         dumpit
 2377        call printline ('compactifications = ' || count_compact,-1);                dumpit
 2378        subtitle = 'instruction frequencies';                                       dumpit
 2379        EJECT_PAGE;                                                                 dumpit
 2380        do i = 0 to 15;                                                             dumpit
 2381           j = i * 32;                                                              dumpit c20 = 15
 2382           do k = 0 to 31;                                                          dumpit
 2383              if instruct(j+k) > 0 then                                             dumpit c21 = 31
 2384                  call printline (substr(opname(i),k*6,6) || x4 || instruct(j+k),-1); dumpit
 2385           end;                                                                     dumpit
 2386        end;                                                                        dumpit
 2387  end dumpit;                                                                       dumpit
 
symbol table dump
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 85
symbol          type       loc   segment defined ref count
 
 
symbol          type       loc   segment defined ref count
char360         character   852   string   2336       2
l               fixed     10207     data   2337       7
ll              fixed     10208     data   2337       6
t1              character   853   string   2337       5
t2              character   854   string   2337       5
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 86
 line    source statement                                                               procedure and compiler information
 
 2388     initialize:                                                                   *
 2389        procedure;                                                                 *
 2390        declare ch character;                                                       initialize
 2391        declare time1 fixed, hours fixed, minutes fixed, secs fixed;                initialize
 2392        declare date1 fixed, day fixed, year fixed, l fixed;                        initialize
 2393        declare month character;                                                    initialize
 2394        declare months (11)character initial ('-jan-',                              initialize
 2395              '-feb-','-mar-','-apr-','-may-','-jun-','-jul-','-aug-',              initialize
 2396              '-sep-','-oct-','-nov-','-dec-');                                     initialize
 2397        output(-2) = 'filename to be compiled: ';                                   initialize
 2398        char_temp = input(-1);                                                      initialize
 2399        source = '';                                                                initialize
 2400        control(byte('A')) = FALSE;                                                 initialize
 2401        control(byte('D')) = TRUE;                                                  initialize
 2402        control(byte('S')) = TRUE;                                                  initialize
 2403        do i = 0 to length(char_temp)-1;                                            initialize
 2404           ch =  substr(char_temp,i,1);                                             initialize
 2405           if byte(ch) = byte('/') then                                             initialize
 2406              do;                                                                   initialize
 2407                 ch = substr(char_temp,i+1,1);                                      initialize
 2408                 control(byte(ch)) = ~ control(byte(ch));                           initialize
 2409                 i = i + 1;                                                         initialize
 2410              end;                                                                  initialize
 2411           else                                                                     initialize
 2412              source = source || ch;                                                initialize
 2413           end;                                                                     initialize
 2414                                                                                    initialize
 2415        j = 0;                                                                      initialize
 2416        do i = 0 to length(source)-1;                                               initialize
 2417           ch = substr(source,i,1);                                                 initialize
 2418           if (byte(ch) = byte('.')) & (j = 0) then                                 initialize
 2419              j = i;                                                                initialize
 2420           end;                                                                     initialize
 2421                                                                                    initialize
 2422        if j = 0 then                                                               initialize
 2423           j = length(source);                                                      initialize
 2424        if j = length(source) then                                                  initialize
 2425           filename(0) = 'sysin:' || source || '.xpl';                              initialize
 2426        else                                                                        initialize
 2427           filename(0) = 'sysin:' || source;                                        initialize
 2428                                                                                    initialize
 2429        source = substr(source,0,j);                                                initialize
 2430        filename (1) = 'sysout:' || source || '.lst';                               initialize
 2431        if control(byte('A')) then                                                  initialize
 2432           do;                                                                      initialize
 2433              filename (DATAFILE) = source || '.mac';                               initialize
 2434              filename(CODEFILE) = source || '.tmp';                                initialize
 2435           end;                                                                     initialize
 2436        filename(RELFILE) = source || '.rel';                                       initialize
 2437        time1 = (time+500)/ 1000;                                                   initialize
 2438        hours = time1 /3600;                                                        initialize
 2439        minutes = (time1 mod 3600) / 60;                                            initialize
 2440        secs = time1 mod 60;                                                        initialize
 2441        date1 = date;                                                               initialize
 2442        day = date1 mod 31 + 1;                                                     initialize
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 87
 line    source statement                                                               procedure and compiler information
 
 2443        date1 = date1 / 31;                                                         initialize
 2444        month = months(date1 mod 12);                                               initialize
 2445        year = date1 / 12 + 1964;                                                   initialize
 2446        title = '1' || source || '.xpl  compiled ' || day || month ||               initialize
 2447               year || '  at ' ||hours || ':' || minutes || ':' || secs             initialize
 2448               || ' by VERSION ' || VERSION;                                        initialize
 2449        l = length (title);                                                         initialize
 2450        title = title || substr(x70,0,90-l) || 'page ';                             initialize
 2451        subtitle = ' line    source statement' || substr(x70,7)                     initialize
 2452              || 'procedure and compiler information';                              initialize c22 = 939524089
 2453        page_count = 0;                                                             initialize
 2454        line_count = 99;                                                            initialize
 2455        do i = 1 to TERMINAL#;                                                      initialize
 2456           s = vocab(i);                                                            initialize
 2457           if s = '<number>' then number = i;  else                                 initialize
 2458           if s = '<identifier>' then ident = i;  else                              initialize
 2459           if s = '<string>' then string = i;  else                                 initialize
 2460           if s = '/' then divide = i;  else                                        initialize
 2461           if s = 'eof' then eofile = i;  else                                      initialize
 2462           if s = 'declare' then stopit(i) = TRUE;  else                            initialize
 2463           if s = 'procedure' then stopit(i) = TRUE;  else                          initialize
 2464           if s = 'end' then stopit(i) = TRUE;  else                                initialize
 2465           if s = 'do' then stopit(i) = TRUE;  else                                 initialize
 2466           if s = ';' then stopit(i) = TRUE;  else                                  initialize
 2467           if s = '|' then orsymbol = i; else                                       initialize
 2468           if s = '||' then concatenate = i;                                        initialize
 2469        end;                                                                        initialize
 2470        if ident = TERMINAL# then reserved_limit = length(vocab(TERMINAL#-1));      initialize
 2471        else reserved_limit = length(vocab(TERMINAL#));                             initialize
 2472        stopit(eofile) = TRUE;                                                      initialize
 2473     do i = TERMINAL# to  VOCAB#;                                                   initialize
 2474        s = vocab(i);                                                               initialize c23 = 91
 2475        if s = '<label definition>' then labelset = i;                              initialize
 2476     end;                                                                           initialize
 2477        chartype (byte(' ')) = 1;                                                   initialize
 2478        chartype (byte('    ')) = 1;    /* make a tab character a blank */          initialize
 2479        chartype (byte('''')) = 2;                                                  initialize
 2480        chartype (byte('"')) = 3;                                                   initialize
 2481        do i = 0 to 255;                                                            initialize
 2482           not_letter_or_digit(i) = TRUE;                                           initialize c24 = 255
 2483        end;                                                                        initialize
 2484        do i = 0 to 29;                                                             initialize
 2485           j = byte('abcdefghijklmnopqrstuvwxyz_$@#', i);                           initialize c25 = 29
 2486           not_letter_or_digit(j) = FALSE;                                          initialize
 2487           if i < 27 then                                                           initialize
 2488              do;                                                                   initialize
 2489              not_letter_or_digit(j+32) = FALSE; /* include lower case */           initialize
 2490              chartype(j+32) = 4;                                                   initialize
 2491              end;                                                                  initialize
 2492           chartype(j) = 4;                                                         initialize
 2493        end;                                                                        initialize
 2494        do i = 0 to 9;                                                              initialize
 2495           j = byte('0123456789', i);                                               initialize c26 = 9
 2496           not_letter_or_digit(j) = FALSE;                                          initialize
 2497           chartype(j) = 5;                                                         initialize
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 88
 line    source statement                                                               procedure and compiler information
 
 2498         end;                                                                       initialize
 2499        i = 1;                                                                      initialize
 2500        do while (length(vocab(i))= 1);                                             initialize
 2501           j = byte(vocab(i));                                                      initialize
 2502           tx(j) = i;                                                               initialize
 2503           chartype(j) = 7;                                                         initialize
 2504           i = i + 1;                                                               initialize
 2505        end;                                                                        initialize
 2506        chartype(byte('|')) = 8;                                                    initialize
 2507        chartype (byte('/')) = 6;                                                   initialize
 2508        pp = 0;            /* program origin */                                     initialize
 2509        dp = 0;            /* data origin */                                        initialize
 2510        dpoffset = 0;                                                               initialize
 2511        dsp = 0;           /* descriptor origin */                                  initialize
 2512        returned_type = FIXEDTYPE;     /* initial default type */                   initialize
 2513        top_macro = -1;                                                             initialize
 2514        target_register = -1;                                                       initialize
 2515                                                                                    initialize
 2516        codemsg = x70 || codemsg;                                                   initialize
 2517        datamsg = x70 || datamsg;                                                   initialize
 2518        backmsg = x70 || backmsg;                                                   initialize
 2519                                                                                    initialize
 2520  /*    initialize the symbol table and its hash table */                           initialize
 2521        procmark = 25; ndecsy = 27; parct = 0;                                      initialize
 2522        do i = 0 to SYTSIZE;                                                        initialize
 2523           ptr (i) = -1;                                                            initialize c27 = 420
 2524        end;                                                                        initialize
 2525        do i = 0 to "ff";                                                           initialize
 2526           hash (i) = -1;                                                           initialize
 2527        end;                                                                        initialize
 2528        do i = 0 to ndecsy;                                                         initialize
 2529           idx = hasher (syt(i));                                                   initialize
 2530           ptr (i) = hash (idx);                                                    initialize
 2531           hash (idx) = i;                                                          initialize
 2532        end;                                                                        initialize
 2533        rptr, dptr, dloc,for_count, label_count = 0;                                initialize
 2534        rctr, dctr = 1;                                                             initialize
 2535                                                                                    initialize
 2536        file(RELFILE) = NAME_TYPE + 2;                                              initialize
 2537        file(RELFILE) = 0;                                                          initialize c28 = 1572864
 2538        file(RELFILE) = radix50(source);                                            initialize
 2539        file(RELFILE) = "(3)17000000" + 0;                                          initialize
 2540        file(RELFILE) = HISEG_TYPE + 1;                                             initialize c29 = 3932160
 2541        file(RELFILE) = "(3)200000000000" ;                                         initialize c30 = 786432
 2542        file(RELFILE) = "(3)400000400000";                                          initialize
 2543                                                                                    initialize c31 = -34359607296
 2544        code_head, code_tail = 0;                                                   initialize
 2545        code_full(0) = FALSE;                                                       initialize
 2546        if control(byte('A')) then                                                  initialize
 2547           do;                                                                      initialize
 2548              label_gen = 'p:';                /* org the code segment */           initialize
 2549              output (DATAFILE) = '       title ' || source ;                       initialize
 2550              output (DATAFILE) = '       twoseg 400000;';                          initialize
 2551              output (DATAFILE) = '       reloc 0;';                                initialize
 2552              output (DATAFILE) = '       radix 10;';                               initialize
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 89
 line    source statement                                                               procedure and compiler information
 
 2553              output (CODEFILE) = '       reloc |o400000;';                         initialize
 2554              output (DATAFILE) = '       opdef   .init. [1b8];';                   initialize
 2555              output (DATAFILE) = '       opdef   .inpt. [2b8];';                   initialize
 2556              output (DATAFILE) = '       opdef   .outp. [3b8];';                   initialize
 2557              output (DATAFILE) = '       opdef   .exit. [4b8];';                   initialize
 2558              output (DATAFILE) = '       opdef   .fili. [6b8];';                   initialize
 2559              output (DATAFILE) = '       opdef   .filo. [7b8];';                   initialize
 2560              output (DATAFILE) = '       opdef   .name. [8b8];';                   initialize
 2561              output (DATAFILE) = 'd:';                                             initialize
 2562           end;                                                                     initialize
 2563        byteptrs = dp;                                                              initialize
 2564        call emitdataword ("(3)331114000000"); /*   point 9,0(12),8 */              initialize
 2565        call emitdataword ("(3)221114000000"); /*   point 9,0(12),17 */             initialize c32 = 29145169920
 2566        call emitdataword ("(3)111114000000"); /*   point 9,0(12),26 */             initialize c33 = 19481493504
 2567        call emitdataword ("(3)001114000000"); /*   point 9,0(12),35 */             initialize c34 = 9817817088
 2568        psbits = dp;                                                                initialize c35 = 154140672
 2569        call emitdataword ("(3)331100000000"); /*   point 9,0,8  */                 initialize
 2570        call emitdataword ("(3)221100000000"); /*   point 9,0,17 */                 initialize c36 = 29142024192
 2571        call emitdataword ("(3)111100000000"); /*   point 9,0,26 */                 initialize c37 = 19478347776
 2572        call emitdataword ("(3)001100000000"); /*   point 9,0,35 */                 initialize c38 = 9814671360
 2573        call emitconstant (1);            /* enter a 1 */                           initialize c39 = 150994944
 2574        trueloc = adr;                    /* save its address */                    initialize
 2575        call emitconstant (0);            /* enter a 0 */                           initialize
 2576        falseloc = adr;                   /* save its address */                    initialize
 2577        tsa = dp; sytloc(2) = dp;         /* freepoint */                           initialize
 2578        call emitdataword (0);                                                      initialize
 2579        ndesc, sytloc(4) = findlabel;     /* ndescript */                           initialize
 2580        corebyteloc = 1;                  /* syt location of corebyte */            initialize
 2581        string_recover = 25;              /* syt location of compactify */          initialize
 2582        sytloc(25) = findlabel;           /* label for compactify */                initialize
 2583        limitword = dp; sytloc(26) = dp;  /* freelimit */                           initialize
 2584        call emitdataword (0);                                                      initialize
 2585        str = dsp;                        /* place to save last string generated */ initialize
 2586        call emitdesc (0,0);                                                        initialize
 2587        library_save = dp;                /* place to save r11 on lib calls */      initialize
 2588        call emitdataword (0);                                                      initialize
 2589        library = dp;                     /* address of library goes here */        initialize
 2590        if control(byte('A')) then                                                  initialize
 2591           do;                                                                      initialize
 2592              output (DATAFILE) = '       xpllib;';                                 initialize
 2593              output (DATAFILE) = '       extern xpllib;';                          initialize
 2594           end;                                                                     initialize
 2595        dp = dp + 1;                                                                initialize
 2596        call emitconstant ("fffff");      /* mask for addresses only  */            initialize
 2597        addrmask = adr;                   /* save it                  */            initialize
 2598        call emitconstant(-134217728);  /* dv length field */                       initialize
 2599        lengthmask = adr;                                                           initialize
 2600                                                                                    initialize
 2601  /* check-string-overflow  see if compactify needs to be called */                 initialize
 2602                                                                                    initialize
 2603        call emitblock (15);                                                        initialize
 2604        i = dp - 15;                                                                initialize
 2605        string_check = pp;                                                          initialize
 2606        call emitinst (move,0,0,tsa,0,1); /* pick up top of strings */              initialize
 2607        call emitinst (camge,0,0,limitword,0,1); /* compare with limit word */      initialize
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 90
 line    source statement                                                               procedure and compiler information
 
 2608        call emitinst (popj,15,0,0,0,0);                                            initialize
 2609        call emitinst (movei,0,0,i,0,1);                                            initialize
 2610        call emitinst (hrli,0,0,1,0,0);                                             initialize
 2611        call emitinst (blt,0,0,i+14,0,1);                                           initialize
 2612        call emitinst (pushj,15,0,sytloc(string_recover),0,sytseg(string_recover)); initialize
 2613        call emitinst (movei,0,0,1,0,0);                                            initialize
 2614        call emitinst (hrli,0,0,i,0,1);                                             initialize
 2615        call emitinst (blt,0,0,14,0,0);                                             initialize
 2616        call emitinst (popj,15,0,0,0,0);                                            initialize
 2617        sytco (string_recover) = sytco (string_recover) + 1;                        initialize
 2618                                                                                    initialize
 2619   /* string comparison */                                                          initialize
 2620                                                                                    initialize
 2621        a = dsp;                                                                    initialize
 2622        call emitdesc (0,0);                                                        initialize
 2623        b = dsp;                                                                    initialize
 2624        call emitdesc (0,0);                                                        initialize
 2625        strcomp = pp;                                                               initialize
 2626        call emitinst (move,0,0,a,0,3);   /* fetch left descriptor */               initialize
 2627        call emitinst (lsh,0,0,    -27,0,0);                                        initialize
 2628        call emitinst (move,1,0,b,0,3);    /* fetch right descriptor */             initialize
 2629        call emitinst (lsh,1,0,    -27,0,0);                                        initialize
 2630        call emitinst (sub,0,0,1,0,0);    /* subtract the lengths */                initialize
 2631        call emitinst (jumpe,0,0,pp+2,0,2);                                         initialize
 2632        call emitinst (popj,15,0,0,0,0);   /* return w/ -, 0, or + if length ~= */  initialize
 2633        call emitinst (movei,2,0,0,0,0);  /* clear a length register */             initialize
 2634        call emitinst (move,3,0,a,0,3);                                             initialize
 2635        call emitinst (subi,3,0,1,0,0);                                             initialize
 2636        call emitinst (lshc,2,0,  9,0,0); /* isolate the length */                  initialize
 2637        call emitinst (lshc,3,0,-11,0,0); /* isolate byte index in r4 */            initialize
 2638        call emitinst (lsh,4,0,    -34,0,0);                                        initialize
 2639        call emitinst (hll,3,0,psbits,4,1); /* build byte ptr in r3 */              initialize
 2640        call emitinst (move,4,0,b,0,3);                                             initialize
 2641        call emitinst (subi,4,0,1,0,0);                                             initialize
 2642        call emitinst (lshc,4,0,    -2,0,0);                                        initialize
 2643        call emitinst (lsh,5,0,    -34,0,0);                                        initialize
 2644        call emitinst (hll,4,0,psbits,5,1); /* build byte ptr in r4 */              initialize
 2645                                                                                    initialize
 2646        /* one character goes into r0 while the other goes into r1.  length is      initialize
 2647           controlled in r2 and the byte ptrs are in r3 & r4 for speed.             initialize
 2648        */                                                                          initialize
 2649        call emitinst (ildb,0,0,3,0,0);   /* fetch 1st byte */                      initialize
 2650        call emitinst (ildb,1,0,4,0,0);   /* fetch 2nd byte */                      initialize
 2651        call emitinst (camn,0,0,1,0,0);   /* skip if ~= */                          initialize
 2652        call emitinst (sojg,2,0,pp-3,0,2);/* loop for all bytes */                  initialize
 2653        call emitinst (sub,0,0,1,0,0);    /* sub diff bytes or last two equal */    initialize
 2654        call emitinst (popj,15,0,0,0,0);                                            initialize
 2655                                                                                    initialize
 2656   /* move character subroutine */                                                  initialize
 2657                                                                                    initialize
 2658        mover = pp;                                                                 initialize
 2659        /* uses registers 1, 2, 11, 12, & 13 */                                     initialize
 2660        call emitinst (subi,12,0,1,0,0);  /* decr addr of source */                 initialize
 2661        call emitinst (movei,11,0,0,0,0); /* clear length reg */                    initialize
 2662        call emitinst (lshc,11,0,  9,0,0);/* isolate length */                      initialize
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 91
 line    source statement                                                               procedure and compiler information
 
 2663        call emitinst (lshc,12,0,-11,0,0);/* isolate byte index */                  initialize
 2664        call emitinst (lsh,13,0,    -34,0,0);                                       initialize
 2665        call emitinst (hll,12,0,psbits,13,1); /* make from byteptr */               initialize
 2666        call emitinst (move,13,0,11,0,0); /* copy length */                         initialize
 2667        call emitinst (add,13,0,1,0,0);   /* create new tsa */                      initialize
 2668        call emitinst (subi,1,0,1,0,0);   /* decr to addr */                        initialize
 2669        call emitinst (lshc,1,0,    -2,0,0); /* isolate byte index */               initialize
 2670        call emitinst (lsh,2,0,    -34,0,0);                                        initialize
 2671        call emitinst (hll,1,0,psbits,2,1);  /* to byteptr */                       initialize
 2672                                                                                    initialize
 2673        /* character goes into r2, length is in r11, and the new tsa is in r13.     initialize
 2674           byteptrs are in r1 & r12 for speed.                                      initialize
 2675        */                                                                          initialize
 2676        call emitinst (ildb,2,0,12,0,0);  /* fetch a byte */                        initialize
 2677        call emitinst (idpb,2,0,1,0,0);   /* store a byte */                        initialize
 2678        call emitinst (sojg,11,0,pp-2,0,2);  /* loop for all bytes */               initialize
 2679        call emitinst (move,1,0,13,0,0);  /* return with new tsa */                 initialize
 2680        call emitinst (popj,15,0,0,0,0);                                            initialize
 2681                                                                                    initialize
 2682   /* catenation subroutine */                                                      initialize
 2683                                                                                    initialize
 2684        catentry = pp;                                                              initialize
 2685        call check_string_overflow;       /* squeeze core if necessary */           initialize
 2686        call emitinst (move,0,0,b,0,3);   /* see if length (b) = 0 */               initialize
 2687        call emitinst (and,0,0,lengthmask,0,1);                                     initialize
 2688        call emitinst (jumpn,0,0,pp+3,0,2);                                         initialize
 2689        call emitinst (move,0,0,a,0,3);   /* yes, return with a */                  initialize
 2690        call emitinst (popj,15,0,0,0,0);                                            initialize
 2691        call emitinst (move,1,0,a,0,3);   /* see if length(a) = 0 */                initialize
 2692        call emitinst (and,1,0,lengthmask,0,1);                                     initialize
 2693        call emitinst (jumpn,1,0,pp+3,0,2);                                         initialize
 2694        call emitinst (move,0,0,b,0,3);   /* yes, return with b */                  initialize
 2695        call emitinst (popj,15,0,0,0,0);                                            initialize
 2696                                                                                    initialize
 2697        /*  we have to construct a new string.  check to see if string 'a'          initialize
 2698          is adjacent to the first available byte.  if it is, we need               initialize
 2699          only actually move string 'b' and dummy up a new descriptor.  */          initialize
 2700                                                                                    initialize
 2701        call emitinst (rot,1,0,9,0,0);     /* put l(a) in low end */                initialize
 2702        call emitinst (add,1,0,a,0,3);     /* add a desc. */                        initialize
 2703        call emitinst (and,1,0,addrmask,0,1); /* keep only byte address */          initialize
 2704        call emitinst (add,0,0,a,0,3);     /* add l(b) to desc. a */                initialize
 2705        call emitinst (move,12,0,b,0,3);     /* ge desc. b */                       initialize
 2706        call emitinst (and,12,0,addrmask,0,1);/* keep byte address */               initialize
 2707        call emitinst (camn,12,0,1,0,0);    /* is this same as end(a)+1? */         initialize
 2708        call emitinst (jrst,0,0,pp+11,0,2);  /*yes. then done */                    initialize
 2709        call emitinst (caml,1,0,tsa,0,1);  /* is 'a' last string ? */               initialize
 2710        call emitinst (jrst,0,0,pp+6,0,2); /* yes. jump to just move b */           initialize
 2711        call emitinst (and,0,0,lengthmask,0,1); /* no. make new desc. */            initialize
 2712        call emitinst (ior,0,0,tsa,0,1);  /* new dope vector */                     initialize
 2713        call emitinst (move,1,0,tsa,0,1); /* target of move */                      initialize
 2714        call emitinst (move,12,0,a,0,3);  /* source of move & length */             initialize
 2715        call emitinst (pushj,15,0,mover,0,2);   /* call move subroutine */          initialize
 2716        call emitinst (move,12,0,b,0,3);  /* source of move */                      initialize
 2717        call emitinst (pushj,15,0,mover,0,2);   /* call move subroutine*/           initialize
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 92
 line    source statement                                                               procedure and compiler information
 
 2718        call emitinst (movem,1,0,tsa,0,1);/* save new tsa */                        initialize
 2719        call emitinst (movem,0,0,str,0,3);  /* save last string descriptor */       initialize
 2720        call emitinst (popj,15,0,0,0,0);                                            initialize
 2721                                                                                    initialize
 2722   /* number to string conversion */                                                initialize
 2723                                                                                    initialize
 2724        nmbrentry = pp;                                                             initialize
 2725        /* uses registers 0,1,12,13 */                                              initialize
 2726                                                                                    initialize
 2727        call emitblock (1);                                                         initialize
 2728        c = dp - 1;                                                                 initialize
 2729        call check_string_overflow;                                                 initialize
 2730        call emitinst (move,12,0,tsa,0,1);   /* get loc'n first free byte*/         initialize
 2731        call emitinst (subi,12,0,1,0,0);    /* adjust for idbp */                   initialize
 2732        call emitinst (movei,13,0,0,0,0);    /* clear 13 for shift */               initialize
 2733        call emitinst (lshc,12,0,-2,0,0);    /* word address to 12 */               initialize
 2734        call emitinst (rot,13,0,2,0,0);      /* displ. to 13 */                     initialize
 2735        call emitinst (hll,12,0,psbits,13,1);/* make byte pointer in 12 */          initialize
 2736        call emitinst (move,0,0,c,0,1);      /* load number to be converted */      initialize
 2737        call emitinst (movei,13,0,0,0,0);    /* clear count of bytes */             initialize
 2738        call emitinst (jumpge,0,0,pp+5,0,2); /* jump around sign if >= 0 */         initialize
 2739        call emitinst (movei,1,0,byte('-'),0,0);/* put - into reg. */               initialize
 2740        call emitinst (idpb,1,0,12,0,0);     /* put byte away */                    initialize
 2741        call emitinst (movei,13,0,1,0,0);    /* set byte count to 1 */              initialize
 2742        call emitinst (movm,0,0,0,0,0);      /* make number positive */             initialize
 2743        call emitinst (pushj,15,0,pp+8,0,2); /* generate byte string */             initialize
 2744        call emitinst (rot,13,0,-9,0,0);     /* put byte count in length */         initialize
 2745        call emitinst (move,0,0,tsa,0,1);    /* pick starting address of string */  initialize
 2746        call emitinst (add,0,0,13,0,0);      /* add length to make desc. */         initialize
 2747        call emitinst (rot,13,0,9,0,0);      /* put count back */                   initialize
 2748        call emitinst (addm,13,0,tsa,0,1);   /* adjust tsa for next time */         initialize
 2749        call emitinst (movem,0,0,str,0,3);   /* save new descriptor */              initialize
 2750        call emitinst (popj,15,0,0,0,0);     /* return */                           initialize
 2751                                                                                    initialize
 2752        /* subroutine to convert number to char string by repetitive                initialize
 2753           division.  puts out digits from high-to-low order. */                    initialize
 2754                                                                                    initialize
 2755        call emitinst (idivi,0,0,10,0,0);    /* quotient to 0, remainder to 1 */    initialize
 2756        call emitinst (hrlm,1,0,0,15,0);     /* save remainder on stack */          initialize
 2757        call emitinst (jumpe,0,0,pp+2,0,2);  /* if quotient = 0, all digits */      initialize
 2758        call emitinst (pushj,15,0,pp-3,0,2); /* loop back for next digit */         initialize
 2759        call emitinst (hlrz,1,0,0,15,0);     /* retrieve digit from stack */        initialize
 2760        call emitinst (addi,1,0,byte('0'),0,0); /* convert to ascii character */    initialize
 2761        call emitinst (idpb,1,0,12,0,0);     /* stuff byte out */                   initialize
 2762        call emitinst (addi,13,0,1,0,0);     /* increment byte counter */           initialize
 2763        call emitinst (popj,15,0,0,0,0);     /* return (for more or to caller */    initialize
 2764                                                                                    initialize
 2765     /* the compiled program will begin execution here.  make the first jump        initialize
 2766        point here, initialize the library, and fall into compile code.             initialize
 2767     */                                                                             initialize
 2768                                                                                    initialize
 2769        startloc = pp;                      /* start location */                    initialize
 2770        call emitlabel (0,4);               /* org program here */                  initialize
 2771        /* initialize library routine, freebase, freelimit, & freepoint */          initialize
 2772        call emitinst (jump,0,0,0,0,0);   /* patch nop */                           initialize
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 93
 line    source statement                                                               procedure and compiler information
 
 2773        call emitinst (1,0,0,0,0,0);      /* init lib code */                       initialize
 2774        call emitinst (movem,12,0,tsa,0,1); /* save as freepoint */                 initialize
 2775        call emitinst (movem,12,0,dp,0,1); /* save as freebase */                   initialize
 2776        sytloc (27) = dp;                                                           initialize
 2777        call emitdataword (0);                                                      initialize
 2778        call emitinst (subi,13,0,256,0,0);                                          initialize
 2779        call emitinst (movem,13,0,limitword,0,1); /* save as freelimit */           initialize
 2780        /* routine to relocate string descriptors */                                initialize
 2781        call emitinst (movei,12,0,0,0,1); /* get address of data segment */         initialize
 2782        call emitinst (lsh,12,0,  2,0,0);    /* multiply by 4 for byte address*/    initialize
 2783        call emitinst (move,13,0,ndesc,0,5);   /* get # descriptors as index */     initialize
 2784        call emitinst (skipe,0,0,0,13,3); /* don't change null desc.s */            initialize
 2785        call emitinst (addm,12,0,0,13,3); /* add reloc to a descriptor */           initialize
 2786        call emitinst (sojg,13,0,pp-2,0,2);    /* loop thru all descriptors */      initialize
 2787        cp = 0;  text = '';  text_limit = -1;                                       initialize
 2788        compiling = TRUE;                                                           initialize
 2789        reading = control(byte('X'));                                               initialize
 2790        if reading then                                                             initialize
 2791            control(byte('L')) = ~ (control(byte('K')) | control(byte('M'))) & 1;   initialize
 2792        filename(LIBFILE) = 'lib:xpl.lib';                                          initialize
 2793        current_procedure = '*';                                                    initialize
 2794        procedure_depth = 0;                                                        initialize
 2795        call scan;                                                                  initialize
 2796        no_look_ahead_done = FALSE;                                                 initialize
 2797     end initialize;                                                                initialize
 
symbol table dump
 
symbol          type       loc   segment defined ref count
ch              character   869   string   2390       8
date1           fixed     10286     data   2392       6
day             fixed     10287     data   2392       2
hours           fixed     10283     data   2391       2
l               fixed     10289     data   2392       2
minutes         fixed     10284     data   2391       2
month           character   870   string   2393       2
months          character   871   string   2394       1
secs            fixed     10285     data   2391       2
time1           fixed     10282     data   2391       4
year            fixed     10288     data   2392       2
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 94
 line    source statement                                                               procedure and compiler information
 
 2798  stack_dump:                                                                      *
 2799     procedure;                                                                    *
 2800        declare line character;                                                     stack_dump
 2801        if ~ control(byte('R')) then return;  /* 'r' is barf switch */              stack_dump
 2802        line = 'partial parse to this point is: ';                                  stack_dump
 2803        do i = 0 to sp;                                                             stack_dump
 2804           if length(line) > 105 then                                               stack_dump
 2805              do;                                                                   stack_dump
 2806                 call printline (line,-1);                                          stack_dump
 2807                 line = x4;                                                         stack_dump
 2808              end;                                                                  stack_dump
 2809           line = line || x1 || vocab(state_name(state_stack(i)));                  stack_dump
 2810        end;                                                                        stack_dump
 2811        call printline (line,-1);                                                   stack_dump
 2812     end stack_dump;                                                                stack_dump
 
symbol table dump
 
symbol          type       loc   segment defined ref count
line            character   935   string   2800       7
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 95
 line    source statement                                                               procedure and compiler information
 
 2813                                                                                   *
 2814    /*                  the synthesis algorithm for xpl                      */    *
 2815                                                                                   *
 2816                                                                                   *
 2817  synthesize:                                                                      *
 2818  procedure(production_number);                                                    *
 2819     declare production_number fixed;                                               synthesize
 2820     declare toomsg character initial ('too many arguments for ');                  synthesize
 2821                                                                                    synthesize
 2822     stack_case:                                                                    synthesize
 2823        procedure (datum);                                                          synthesize
 2824           declare datum fixed;                                                     stack_case
 2825           declare dclrm character                                                  stack_case
 2826                 initial ('too many cases or factored declarations');               stack_case
 2827           if casep >= CASELIMIT then call error (dclrm,1);                         stack_case
 2828                                 else casep = casep + 1;                            stack_case
 2829           casestack(casep) = datum;                                                stack_case
 2830     end stack_case;                                                                stack_case
 
symbol table dump
 
symbol          type       loc   segment defined ref count
datum           fixed     10499     data   2823       1
dclrm           character   938   string   2826       1
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 96
 line    source statement                                                               procedure and compiler information
 
 2831                                                                                    synthesize
 2832        do case (production_number);                                                synthesize
 2833     /*  one statement for each production of the grammar*/                         synthesize case 0.
 2834     ;      /*  case 0 is a dummy, because we number productions from 1  */         synthesize
 2835                                                                                    synthesize case 1.
 2836  /*      1   <program> ::= <statement list> eof                       */           synthesize
 2837  do;  /* end of compiling */                                                       synthesize
 2838     compiling = FALSE;                                                             synthesize
 2839     if mp ~= 0  then                                                               synthesize
 2840        do;                                                                         synthesize
 2841           call error ('input did not parse to <program>.', 1);                     synthesize
 2842           call stack_dump;                                                         synthesize
 2843        end;                                                                        synthesize
 2844     do i = procmark to ndecsy;                                                     synthesize
 2845        if sytype (i) = FORWARDTYPE | sytype (i) = FORWARDCALL then                 synthesize
 2846           if sytco (i) > 0 then                                                    synthesize
 2847               call error ('undefined label or procedure: ' || syt(i),1);           synthesize
 2848     end;                                                                           synthesize
 2849        if dpoffset > 0 then call flush_datacard;                                   synthesize
 2850  end;                                                                              synthesize
 2851                                                                                    synthesize case 2.
 2852  /*      2   <statement list> ::= <statement>                         */           synthesize
 2853     ;                                                                              synthesize
 2854  /*      3                      | <statement list> <statement>        */           synthesize case 3.
 2855     ;                                                                              synthesize
 2856  /*      4   <statement> ::= <basic statement>                        */           synthesize case 4.
 2857     do;                                                                            synthesize
 2858        statement_count = statement_count + 1;                                      synthesize
 2859        call clearars;                                                              synthesize
 2860     end;                                                                           synthesize
 2861                                                                                    synthesize case 5.
 2862  /*      5                 | <if statement>                           */           synthesize
 2863     call clearars;                                                                 synthesize
 2864  /*      6   <basic statement> ::= <assignment> ;                     */           synthesize case 6.
 2865     ;                                                                              synthesize
 2866  /*      7                       | <group> ;                          */           synthesize case 7.
 2867     ;                                                                              synthesize
 2868  /*      8                       | <procedure definition> ;           */           synthesize case 8.
 2869      ;                                                                             synthesize
 2870  /*      9                       | <return statement> ;               */           synthesize case 9.
 2871     ;                                                                              synthesize
 2872  /*     10                       | <call statement> ;                 */           synthesize case 10.
 2873     ;                                                                              synthesize
 2874  /*     11                       | <go to statement> ;                */           synthesize case 11.
 2875     ;                                                                              synthesize
 2876  /*     12                       | <declaration statement> ;          */           synthesize case 12.
 2877     ;                                                                              synthesize
 2878  /*     13                       | ;                                  */           synthesize case 13.
 2879     ;                                                                              synthesize
 2880  /*     14                       | <label definition>                 */           synthesize case 14.
 2881  /*     14                         <basic statement>                  */           synthesize
 2882     ;                                                                              synthesize
 2883  /*     15   <if statement> ::= <if clause> <statement>               */           synthesize case 15.
 2884     call emitlabel(fixl(mp),4);            /* fix escape branch */                 synthesize
 2885  /*     16                    | <if clause> <TRUE part> <statement>   */           synthesize case 16.
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 97
 line    source statement                                                               procedure and compiler information
 
 2886     call emitlabel (fixl(mpp1),4);         /* fix escape branch */                 synthesize
 2887  /*     17                    | <label definition> <if statement>     */           synthesize case 17.
 2888     ;                                                                              synthesize
 2889  /*     18   <if clause> ::= if <expression> then                     */           synthesize case 18.
 2890        call boolbranch(mpp1,mp);  /* branch on FALSE over TRUE part */             synthesize
 2891                                                                                    synthesize case 19.
 2892  /*     19   <TRUE part> ::= <basic statement> else                   */           synthesize
 2893     do; /* save the program pointer and emit the conditional branch */             synthesize
 2894        fixl(mp) = findlabel;                                                       synthesize
 2895        call emitinst(jrst ,0,0,fixl(mp),0,4);                                      synthesize
 2896        call emitlabel (fixl(mp-1),4);      /* complete hop around TRUE */          synthesize
 2897        call clearars;                                                              synthesize
 2898     end;                                                                           synthesize
 2899                                                                                    synthesize case 20.
 2900  /*     20   <group> ::= <group head> <ending>                        */           synthesize
 2901          /* branch back to loop and fix escape branch */                           synthesize
 2902        if inx (mp) = 1 | inx (mp) = 2 then                                         synthesize
 2903           do;  /* step or while loop fixup */                                      synthesize
 2904              call emitinst (jrst ,0,0,ppsave(mp),0,2);                             synthesize
 2905              call emitlabel(fixl(mp),4);                                           synthesize
 2906           end;                                                                     synthesize
 2907         else if inx (mp) = 3 then                                                  synthesize
 2908           do;  /* case group */                                                    synthesize
 2909              call emitlabel(fixl(mp),4);   /* fix branch into jump list */         synthesize
 2910              do i = ppsave (mp) to casep - 1;                                      synthesize
 2911                 call emitinst (jrst ,0,0,casestack(i),0,2); /* jump list */        synthesize
 2912                 end;                                                               synthesize
 2913              casep = ppsave (mp) - 1;                                              synthesize
 2914              call emitlabel(fixv(mp),4);   /* fix escape branch */                 synthesize
 2915           end;                                                                     synthesize
 2916                                                                                    synthesize
 2917  /*     21   <group head> ::= do ;                                    */           synthesize
 2918     inx (mp) = 0;                       /* zero denotes ordinary group */          synthesize
 2919                                                                                    synthesize case 21. case 22.
 2920  /*     22                  | do <step definition> ;                  */           synthesize
 2921     do;                                                                            synthesize
 2922        call movestacks (mpp1, mp);                                                 synthesize
 2923        inx (mp) = 1;                    /* one denotes step */                     synthesize
 2924        call clearars;                                                              synthesize
 2925     end;                                                                           synthesize
 2926                                                                                    synthesize case 23.
 2927  /*     23                  | do <while clause> ;                     */           synthesize
 2928     do;                                                                            synthesize
 2929        call movestacks (mpp1,mp);                                                  synthesize
 2930        inx (mp) = 2;                    /* two denotes while */                    synthesize
 2931        call clearars;                                                              synthesize
 2932     end;                                                                           synthesize
 2933                                                                                    synthesize case 24.
 2934  /*     24                  | do <case selector> ;                    */           synthesize
 2935     do;                                                                            synthesize
 2936        call movestacks (mpp1, mp);                                                 synthesize
 2937        inx (mp) = 3;                    /* three denotes case */                   synthesize
 2938        call clearars;                                                              synthesize
 2939        info = info || ' case 0.';                                                  synthesize
 2940     end;                                                                           synthesize
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 98
 line    source statement                                                               procedure and compiler information
 
 2941                                                                                    synthesize case 25.
 2942  /*     25                  | <group head> <statement>                */           synthesize
 2943     if inx (mp) = 3 then                                                           synthesize
 2944        do; /* case group, must record statement addresses */                       synthesize
 2945           call emitinst (jrst ,0,0,fixv(mp),0,4);                                  synthesize
 2946           call stack_case (pp);                                                    synthesize
 2947           info = info || ' case ' || casep - ppsave(mp) || '.';                    synthesize
 2948        end;                                                                        synthesize
 2949                                                                                    synthesize
 2950  /*     26   <step definition> ::= <VARIABLE> <replace>               */           synthesize
 2951  /*     26                         <expression> <iteration control>   */           synthesize
 2952     do; /* emit code for stepping do loops */                                      synthesize
 2953        call forceaccumulator (mp+2);     /* get initial value */                   synthesize case 26.
 2954        stepk = findlabel;                                                          synthesize
 2955        call emitinst (jrst ,0,0,stepk,0,4);/* branch around incr code */           synthesize
 2956        ppsave(mp) = pp;                  /* save address for later fix */          synthesize
 2957        if cnt (mp) > 0 then call error ('do index may not be subscripted',0);      synthesize
 2958                                                                                    synthesize
 2959                         /*  increment induction VARIABLE */                        synthesize
 2960        if sytype(fixl(mp)) = FIXEDTYPE & fixl(sp) = trueloc then                   synthesize
 2961           do;           /* use aos if incrementing by 1 */                         synthesize
 2962              reg(mp) = reg(mp+2);                                                  synthesize
 2963              call emitinst (aosa,reg(mp),0,sytloc(fixl(mp)),0,1);                  synthesize
 2964              type(mp) = ACCUMULATOR;                                               synthesize
 2965           end;                                                                     synthesize
 2966        else                                                                        synthesize
 2967           do;           /* can't use aos inst. */                                  synthesize
 2968              acc(reg(mp+2)) = AVAIL;     /* make sure same register is used */     synthesize
 2969              target_register = reg(mp+2);                                          synthesize
 2970              call forceaccumulator (mp); /* fetch the index     */                 synthesize
 2971              target_register = -1;                                                 synthesize
 2972              call emitinst(add,reg(mp),0,fixl(mp+3),0,1);                          synthesize
 2973           end;                                                                     synthesize
 2974                         /* update induction VARIABLE and test for end */           synthesize
 2975        call emitlabel(stepk,4);                                                    synthesize
 2976        call genstore (mp,mp);                                                      synthesize
 2977        call emitinst (camle,reg(mp),0,fixv(sp),0,1);                               synthesize
 2978        fixl (mp) = findlabel;                                                      synthesize
 2979        call emitinst (jrst ,0,0,fixl(mp),0,4);                                     synthesize
 2980        acc(reg(mp)) = AVAIL;                                                       synthesize
 2981     end;                                                                           synthesize
 2982                                                                                    synthesize case 27.
 2983  /*     27   <iteration control> ::= to <expression>                  */           synthesize
 2984     do;                                                                            synthesize
 2985        fixl(mp) = trueloc;   /* point at the CONSTANT one for step */              synthesize
 2986        call setlimit;                                                              synthesize
 2987     end;                                                                           synthesize
 2988                                                                                    synthesize case 28.
 2989  /*     28                         | to <expression> by               */           synthesize
 2990  /*     28                           <expression>                     */           synthesize
 2991     do;                                                                            synthesize
 2992        if type (sp) = CONSTANT then call emitconstant (fixv(sp));                  synthesize
 2993        else                                                                        synthesize
 2994           do;                                                                      synthesize
 2995              call forceaccumulator (sp);                                           synthesize
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 99
 line    source statement                                                               procedure and compiler information
 
 2996              call emitdataword (0);                                                synthesize
 2997              adr = dp - 1;                                                         synthesize
 2998              call emitinst (movem,reg(sp),0,adr,0,1);                              synthesize
 2999              acc(reg(sp)) = AVAIL;                                                 synthesize
 3000           end;                                                                     synthesize
 3001        fixl (mp) =adr;                                                             synthesize
 3002        call setlimit;                                                              synthesize
 3003     end;                                                                           synthesize
 3004                                                                                    synthesize case 29.
 3005  /*     29   <while clause> ::= while <expression>                    */           synthesize
 3006     call boolbranch (sp,mp);                                                       synthesize
 3007                                                                                    synthesize case 30.
 3008  /*     30   <case selector> ::= case <expression>                    */           synthesize
 3009     /* the following use is made of the parallel stacks below <case selector>      synthesize
 3010           ppsave     previous maximum case stack pointer                           synthesize
 3011           fixl       address of indexed goto into list                             synthesize
 3012           fixv       address of escape goto for cases                              synthesize
 3013     */                                                                             synthesize
 3014     do;                                                                            synthesize
 3015        call forceaccumulator (sp);       /* get the index in to ar */              synthesize
 3016        acc(reg(sp)) = AVAIL;                                                       synthesize
 3017        fixl(mp) = findlabel;                                                       synthesize
 3018        call emitinst (jrst ,0,1,fixl(mp),reg(sp),4);/* indirect indexed branch */  synthesize
 3019        fixv(mp) = findlabel;             /* address of escape branch */            synthesize
 3020        call stack_case (pp);                                                       synthesize
 3021        ppsave (mp) = casep;                                                        synthesize
 3022     end;                                                                           synthesize
 3023                                                                                    synthesize case 31.
 3024  /*     31   <procedure definition> ::= <procedure head>              */           synthesize
 3025  /*     31                              <statement list> <ending>     */           synthesize
 3026     /* the following use is made of the parallel stacks below                      synthesize
 3027        <procedure head>                                                            synthesize
 3028        ppsave           address of previous proc return                            synthesize
 3029        fixl             address of previous proc ACCUMULATOR area                  synthesize
 3030        fixv             pointer to symbol table for this block                     synthesize
 3031        cnt              count of the parameters of previous proc                   synthesize
 3032     */                                                                             synthesize
 3033     do;   /* procedure is defined, restore symbol table */                         synthesize
 3034        if length (var(sp)) > 0 then                                                synthesize
 3035           if substr (current_procedure,1) ~= var(sp) then                          synthesize
 3036              call error ('procedure' || current_procedure || ' closed by end '     synthesize
 3037                          || var(sp), 0);                                           synthesize
 3038                                                                                    synthesize
 3039        if control(byte('S')) then call symboldump;                                 synthesize
 3040        do i = procmark to ndecsy;                                                  synthesize
 3041           if sytype (i) = FORWARDTYPE | sytype (i) = FORWARDCALL then              synthesize
 3042              if sytco (i) > 0 then                                                 synthesize
 3043                                                                                    synthesize
 3044                 call error ('undefined label or procedure: ' || syt (i), 1);       synthesize
 3045        end;                                                                        synthesize
 3046        do i = 0 to (ndecsy + 1) - (procmark + parct);                              synthesize
 3047           j = ndecsy - i;                                                          synthesize
 3048           if (j >= (procmark + parct)) & (length(syt(j)) > 0) then                 synthesize
 3049              do;                                                                   synthesize
 3050                 hash (hasher(syt(j))) = ptr (j);                                   synthesize
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 100
 line    source statement                                                               procedure and compiler information
 
 3051                 ptr (j) = -1;                                                      synthesize
 3052              end;                                                                  synthesize
 3053        end;                                                                        synthesize
 3054        do i = procmark + parct to ndecsy;                                          synthesize
 3055            syt (i) = x1;                                                           synthesize
 3056        end;                                                                        synthesize
 3057        ndecsy = procmark + parct - 1;                                              synthesize
 3058        /* parameter addresses must be saved but names discarded */                 synthesize
 3059                                                                                    synthesize
 3060        if parct > 0 then                                                           synthesize
 3061           do j = 0 to ndecsy - procmark;                                           synthesize
 3062              i = ndecsy - j;                                                       synthesize
 3063                                                                                    synthesize
 3064              if sytype (i) = 0 then                                                synthesize
 3065                 do;                                                                synthesize
 3066                    call error ('undeclared parameter: ' || syt (i), 0);            synthesize
 3067                    sytype (i) = FIXEDTYPE;                                         synthesize
 3068                    call emitdataword (0);                                          synthesize
 3069                    sytloc(i) = dp -1;                                              synthesize
 3070                 end;                                                               synthesize
 3071              hash (hasher(syt(i))) = ptr (i);                                      synthesize
 3072              ptr (i) = -1;                                                         synthesize
 3073              syt (i) = '';                                                         synthesize
 3074           end;                                                                     synthesize
 3075        procmark = fixv (mp);                                                       synthesize
 3076        parct = cnt (mp);                                                           synthesize
 3077        current_procedure = var (mp);                                               synthesize
 3078        procedure_depth = procedure_depth - 1;                                      synthesize
 3079        /* emit a gratuitous return */                                              synthesize
 3080        call emitinst (popj,15,0,0,0,0);                                            synthesize
 3081        /* complete jump around the procedure definition */                         synthesize
 3082        call emitlabel(ppsave(mp),4);                                               synthesize
 3083        returned_type = type(mp);                                                   synthesize
 3084     end;                                                                           synthesize
 3085                                                                                    synthesize case 32.
 3086  /*     32   <procedure head> ::= <procedure name> ;                  */           synthesize
 3087     do;      /* must point at first parameter even if non existant */              synthesize
 3088        /* save old parameter count */                                              synthesize
 3089        cnt (mp) = parct;                                                           synthesize
 3090        parct = 0;                                                                  synthesize
 3091        /* save old procedure mark in symbol table */                               synthesize
 3092        fixv(mp) = procmark;                                                        synthesize
 3093        procmark = ndecsy + 1;                                                      synthesize
 3094        type(mp) = returned_type;                                                   synthesize
 3095        returned_type = 0;                                                          synthesize
 3096        call proc_start;                                                            synthesize
 3097     end;                                                                           synthesize
 3098                                                                                    synthesize case 33.
 3099  /*     33                      | <procedure name> <type> ;           */           synthesize
 3100     do;                                                                            synthesize
 3101        cnt (mp) = parct;           /* save old parameter count */                  synthesize
 3102        parct = 0;                                                                  synthesize
 3103        fixv(mp) = procmark;        /* save old procedure mark in symbol table */   synthesize
 3104        procmark = ndecsy + 1;                                                      synthesize
 3105        type(mp) = returned_type;                                                   synthesize
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 101
 line    source statement                                                               procedure and compiler information
 
 3106        returned_type = type(sp-1);                                                 synthesize
 3107        if returned_type = CHRTYPE then sytype(fixl(mp)) = CHARPROCTYPE;            synthesize
 3108        call proc_start;                                                            synthesize
 3109     end;                                                                           synthesize
 3110                                                                                    synthesize case 34.
 3111  /*     34                      | <procedure name> <parameter list>   */           synthesize
 3112  /*     34                        ;                                   */           synthesize
 3113     do;                                                                            synthesize
 3114        cnt(mp) = cnt(mpp1);  /* save parameter count */                            synthesize
 3115        fixv(mp) = fixv (mpp1);                                                     synthesize
 3116        type(mp) = returned_type;                                                   synthesize
 3117        returned_type = 0;                                                          synthesize
 3118        call proc_start;                                                            synthesize
 3119     end;                                                                           synthesize
 3120                                                                                    synthesize case 35.
 3121  /*     35                      | <procedure name> <parameter list>   */           synthesize
 3122  /*     35                        <type> ;                            */           synthesize
 3123     do;                                                                            synthesize
 3124        cnt(mp) = cnt(mpp1);  /* save parameter count */                            synthesize
 3125        fixv(mp) = fixv (mpp1);                                                     synthesize
 3126        type(mp) = returned_type;                                                   synthesize
 3127        returned_type = type(sp-1);                                                 synthesize
 3128        if returned_type = CHRTYPE then sytype(fixl(mp)) = CHARPROCTYPE;            synthesize
 3129        call proc_start;                                                            synthesize
 3130     end;                                                                           synthesize
 3131                                                                                    synthesize case 36.
 3132  /*     36   <procedure name> ::= <label definition> procedure        */           synthesize
 3133     do;                                                                            synthesize
 3134        sytype (fixl (mp)) = PROCTYPE;                                              synthesize
 3135        s = current_procedure;                                                      synthesize
 3136        current_procedure = x1 || var (mp);                                         synthesize
 3137        var (mp) = s;                                                               synthesize
 3138        procedure_depth = procedure_depth + 1;                                      synthesize
 3139        output(-1) = substr(x70,0,procedure_depth) || current_procedure;            synthesize
 3140     end;                                                                           synthesize
 3141                                                                                    synthesize case 37.
 3142                                                                                    synthesize
 3143  /*     37   <parameter list> ::= <parameter head> <identifier> )     */           synthesize
 3144     do;                                                                            synthesize
 3145        parct = parct + 1;   /* bump the parameter count */                         synthesize
 3146        call enter (var(mpp1), 0, 0, 0);                                            synthesize
 3147     end;                                                                           synthesize
 3148                                                                                    synthesize case 38.
 3149  /*     38   <parameter head> ::= (                                   */           synthesize
 3150     do;  /* point at the first parameter for symbol table */                       synthesize
 3151        fixv(mp) = procmark;                                                        synthesize
 3152        procmark = ndecsy + 1;                                                      synthesize
 3153        cnt (mp) = parct;        /* save old parameter count */                     synthesize
 3154        parct = 0;                                                                  synthesize
 3155     end;                                                                           synthesize
 3156                                                                                    synthesize case 39.
 3157  /*     39                      | <parameter head> <identifier> ,     */           synthesize
 3158     do;                                                                            synthesize
 3159         parct = parct + 1;          /* bump the parameter count */                 synthesize
 3160        call enter (var(mpp1), 0, 0, 0);                                            synthesize
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 102
 line    source statement                                                               procedure and compiler information
 
 3161     end;                                                                           synthesize
 3162                                                                                    synthesize case 40.
 3163  /*     40   <ending> ::= end                                         */           synthesize
 3164     ;                                                                              synthesize
 3165  /*     41              | end <identifier>                            */           synthesize case 41.
 3166     var (mp) = var (sp);                                                           synthesize
 3167                                                                                    synthesize case 42.
 3168  /*     42              | <label definition> <ending>                 */           synthesize
 3169     ;                                                                              synthesize
 3170  /*     43   <label definition> ::= <identifier> :                    */           synthesize case 43.
 3171     fixl(mp) = enter (var(mp), LABELTYPE, pp, 2);                                  synthesize
 3172                                                                                    synthesize case 44.
 3173  /*     44   <return statement> ::= return                            */           synthesize
 3174     do;                                                                            synthesize
 3175        call emitinst (popj,15,0,0,0,0);                                            synthesize
 3176     end;                                                                           synthesize
 3177                                                                                    synthesize case 45.
 3178  /*     45                        | return <expression>               */           synthesize
 3179     do;  /* emit a return and pass a value */                                      synthesize
 3180        target_register = 0;                                                        synthesize
 3181        if returned_type = CHRTYPE then                                             synthesize
 3182           call forcedescriptor(sp);                                                synthesize
 3183        else                                                                        synthesize
 3184           call forceaccumulator (sp);                                              synthesize
 3185        target_register = -1;                                                       synthesize
 3186        if reg(sp) ~= 0 then call emitinst(move,0,0,reg(sp),0,0);                   synthesize
 3187        call emitinst (popj,15,0,0,0,0);                                            synthesize
 3188     end;                                                                           synthesize
 3189                                                                                    synthesize case 46.
 3190  /*     46   <call statement> ::= call <VARIABLE>                     */           synthesize
 3191     do;                                                                            synthesize
 3192        i = sytype(fixl(sp));                                                       synthesize
 3193        if i=PROCTYPE | i=FORWARDCALL | i = CHARPROCTYPE                            synthesize
 3194                      | (i=SPECIAL & sytloc(fixl(sp))=12)                           synthesize
 3195                      | (i=SPECIAL & sytloc(fixl(sp))=9)  then                      synthesize
 3196           do;                                                                      synthesize
 3197              calltype = 0;               /* no return value */                     synthesize
 3198              call forceaccumulator(sp);                                            synthesize
 3199              calltype = 1;                                                         synthesize
 3200           end;                                                                     synthesize
 3201        else call error ('undefined procedure: ' || syt(fixl(sp)),0);               synthesize
 3202     end;                                                                           synthesize
 3203                                                                                    synthesize case 47.
 3204  /*     47   <go to statement> ::= <go to> <identifier>               */           synthesize
 3205     do;                                                                            synthesize
 3206        call id_lookup(sp);                                                         synthesize
 3207        j = fixl (sp);                                                              synthesize
 3208        if j < 0 then                                                               synthesize
 3209           do;  /* first ocurrance of the label */                                  synthesize
 3210              i = findlabel;                                                        synthesize
 3211              call emitinst (jrst ,0,0,i,0,4);                                      synthesize
 3212              j = enter (var(sp),FORWARDTYPE,i,4);                                  synthesize
 3213              sytco (j) = 1;                                                        synthesize
 3214           end;                                                                     synthesize
 3215        else if sytype(j) = LABELTYPE | sytype(j) = FORWARDTYPE then                synthesize
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 103
 line    source statement                                                               procedure and compiler information
 
 3216            call emitinst (jrst ,0,0,sytloc(j),0,sytseg(j));                        synthesize
 3217        else                                                                        synthesize
 3218          call error ('target of goto is not a label', 0);                          synthesize
 3219     end;                                                                           synthesize
 3220                                                                                    synthesize case 48.
 3221  /*     48   <go to> ::= go to                                        */           synthesize
 3222     ;                                                                              synthesize
 3223  /*     49             | goto                                         */           synthesize case 49.
 3224     ;                                                                              synthesize
 3225  /*     50   <declaration statement> ::= declare                      */           synthesize case 50.
 3226  /*     50                               <declaration element>        */           synthesize
 3227     ;                                                                              synthesize
 3228  /*     51                             | <declaration statement> ,    */           synthesize case 51.
 3229  /*     51                               <declaration element>        */           synthesize
 3230     ;                                                                              synthesize
 3231  /*     52   <declaration element> ::= <type declaration>             */           synthesize case 52.
 3232        if type (mp) = CHRTYPE then                                                 synthesize
 3233           do while (dsp < newdsp);                                                 synthesize
 3234              call emitdesc (0,0);                                                  synthesize
 3235           end;                                                                     synthesize
 3236        else                                                                        synthesize
 3237           do;                                                                      synthesize
 3238              if dp < newdp then                                                    synthesize
 3239                 do;                                                                synthesize
 3240                    if dpoffset > 0 then call flush_datacard;                       synthesize
 3241                    if dp < newdp then call emitblock (newdp-dp);                   synthesize
 3242                 end;                                                               synthesize
 3243              do while (dpoffset < newdpoffset);                                    synthesize
 3244                 call emitbyte(0);                                                  synthesize
 3245              end;                                                                  synthesize
 3246           end;                                                                     synthesize
 3247                                                                                    synthesize case 53.
 3248  /*     53                           | <identifier> literally         */           synthesize
 3249  /*     53                             <string>                       */           synthesize
 3250     if top_macro >= MACRO_LIMIT then                                               synthesize
 3251        call error ('macro table overflow', 1);                                     synthesize
 3252     else do;                                                                       synthesize
 3253        top_macro = top_macro + 1;                                                  synthesize
 3254        i = length(var(mp));                                                        synthesize
 3255        j = macro_index(i);                                                         synthesize
 3256        do l = 1 to top_macro - j;                                                  synthesize
 3257           k = top_macro - l;                                                       synthesize
 3258           macro_name(k+1) = macro_name(k);                                         synthesize
 3259           macro_text(k+1) = macro_text(k);                                         synthesize
 3260           macro_count(k+1) = macro_count(k);                                       synthesize
 3261           macro_declare(k+1) = macro_declare(k);                                   synthesize
 3262        end;                                                                        synthesize
 3263        macro_name(j) = var(mp);                                                    synthesize
 3264        macro_text(j) = var(sp);                                                    synthesize
 3265        macro_count(j) = 0;                                                         synthesize
 3266        macro_declare(j) = card_count;                                              synthesize
 3267        do j = i to 255;                                                            synthesize
 3268           macro_index(j) = macro_index(j) + 1;                                     synthesize
 3269        end;                                                                        synthesize
 3270     end;                                                                           synthesize
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 104
 line    source statement                                                               procedure and compiler information
 
 3271                                                                                    synthesize case 54.
 3272  /*     54   <type declaration> ::= <identifier specification>        */           synthesize
 3273  /*     54                          <type>                            */           synthesize
 3274     call tdeclare (0);                                                             synthesize
 3275                                                                                    synthesize case 55.
 3276  /*     55                        | <bound head> <number> ) <type>    */           synthesize
 3277     call tdeclare (fixv(mpp1));                                                    synthesize
 3278                                                                                    synthesize case 56.
 3279  /*     56                        | <type declaration>                */           synthesize
 3280  /*     56                          <initial list>                    */           synthesize
 3281     ;                                                                              synthesize
 3282  /*     57   <type> ::= fixed                                         */           synthesize case 57.
 3283     type (mp) = FIXEDTYPE;                                                         synthesize
 3284  /*     58            | character                                     */           synthesize case 58.
 3285     type (mp) = CHRTYPE;                                                           synthesize
 3286  /*     59            | label                                         */           synthesize case 59.
 3287     type (mp) = FORWARDTYPE;                                                       synthesize
 3288                                                                                    synthesize case 60.
 3289  /*     60            | <bit head> <number> )                         */           synthesize
 3290     if fixv(mpp1) <= 9 then type (mp) = BYTETYPE; else                             synthesize
 3291        if fixv (mpp1) <= 36 then type (mp) = FIXEDTYPE; else                       synthesize
 3292           type (mp) = CHRTYPE;                                                     synthesize
 3293                                                                                    synthesize case 61.
 3294  /*     61   <bit head> ::= bit (                                     */           synthesize
 3295     ;                                                                              synthesize
 3296  /*     62   <bound head> ::= <identifier specification> (            */           synthesize case 62.
 3297     ;                                                                              synthesize
 3298  /*     63   <identifier specification> ::= <identifier>              */           synthesize case 63.
 3299     do;                                                                            synthesize
 3300        inx(mp) = 1;                                                                synthesize
 3301        fixl(mp) = casep;                                                           synthesize
 3302        call stack_case (enter(var(mp),0,0,0));                                     synthesize
 3303     end;                                                                           synthesize
 3304  /*     64                                | <identifier list>         */           synthesize case 64.
 3305  /*     64                                  <identifier> )            */           synthesize
 3306     do;                                                                            synthesize
 3307        inx(mp) = inx(mp) + 1;                                                      synthesize
 3308        call stack_case (enter(var(mpp1),0,0,0));                                   synthesize
 3309     end;                                                                           synthesize
 3310  /*     65   <identifier list> ::= (                                  */           synthesize case 65.
 3311     do;                                                                            synthesize
 3312        inx(mp) = 0;                                                                synthesize
 3313        fixl(mp) = casep;                                                           synthesize
 3314     end;                                                                           synthesize
 3315  /*     66                       | <identifier list> <identifier> ,   */           synthesize case 66.
 3316     do;                                                                            synthesize
 3317        inx(mp) = inx(mp) + 1;                                                      synthesize
 3318        call stack_case (enter(var(mpp1),0,0,0));                                   synthesize
 3319     end;                                                                           synthesize
 3320                                                                                    synthesize case 67.
 3321  /*     67   <initial list> ::= <initial head> <CONSTANT> )           */           synthesize
 3322     call setinit;                                                                  synthesize
 3323                                                                                    synthesize case 68.
 3324  /*     68   <initial head> ::= initial (                             */           synthesize
 3325     if inx(mp-1) = 1 then                                                          synthesize
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 105
 line    source statement                                                               procedure and compiler information
 
 3326        itype = type (mp-1);  /* copy information from <type declaration> */        synthesize
 3327     else                                                                           synthesize
 3328        do;                                                                         synthesize
 3329           call error ('initial may not be used with identifier list',0);           synthesize
 3330           itype = 0;                                                               synthesize
 3331        end;                                                                        synthesize
 3332                                                                                    synthesize case 69.
 3333  /*     69                    | <initial head> <CONSTANT> ,           */           synthesize
 3334     call setinit;                                                                  synthesize
 3335  /*     70   <assignment> ::= <VARIABLE> <replace> <expression>       */           synthesize case 70.
 3336     call genstore(mp,sp);                                                          synthesize
 3337  /*     71                  | <left part> <assignment>                */           synthesize case 71.
 3338     call genstore(mp,sp);                                                          synthesize
 3339  /*     72   <replace> ::= =                                          */           synthesize case 72.
 3340     ;                                                                              synthesize
 3341  /*     73   <left part> ::= <VARIABLE> ,                             */           synthesize case 73.
 3342     ;                                                                              synthesize
 3343  /*     74   <expression> ::= <logical factor>                        */           synthesize case 74.
 3344     ;                                                                              synthesize
 3345  /*     75                  | <expression> | <logical factor>         */           synthesize case 75.
 3346     call arithemit (ior,1);                                                        synthesize
 3347  /*     76   <logical factor> ::= <logical secondary>                 */           synthesize case 76.
 3348     ;                                                                              synthesize
 3349  /*     77                      | <logical factor> &                  */           synthesize case 77.
 3350  /*     77                        <logical secondary>                 */           synthesize
 3351     call arithemit (and,1);                                                        synthesize
 3352  /*     78   <logical secondary> ::= <logical primary>                */           synthesize case 78.
 3353     ;                                                                              synthesize
 3354  /*     79                         | ~ <logical primary>              */           synthesize case 79.
 3355     do;                                                                            synthesize
 3356        call movestacks (sp, mp);                                                   synthesize
 3357         /* get 1's complement */                                                   synthesize
 3358        call forceaccumulator(mp);                                                  synthesize
 3359        call emitinst (setca,reg(mp),0,0,0,0);                                      synthesize
 3360     end;                                                                           synthesize
 3361                                                                                    synthesize case 80.
 3362  /*     80   <logical primary> ::= <string expression>                */           synthesize
 3363     ;                                                                              synthesize
 3364  /*     81                       | <string expression> <relation>     */           synthesize case 81.
 3365  /*     81                         <string expression>                */           synthesize
 3366        /* relations are encoded as to their cam? instriction code */               synthesize
 3367        /*                                                                          synthesize
 3368           <     1                                                                  synthesize
 3369           >     7                                                                  synthesize
 3370           ~=    6                                                                  synthesize
 3371           =     2                                                                  synthesize
 3372           <=    3                                                                  synthesize
 3373           ~>    3                                                                  synthesize
 3374           >=    5                                                                  synthesize
 3375           ~<    5                                                                  synthesize
 3376        */                                                                          synthesize
 3377     do;                                                                            synthesize
 3378        i = type (mp);                                                              synthesize
 3379        j = type (sp);                                                              synthesize
 3380        if i = DESCRIPT | i = CHRTYPE then call stringcompare; else                 synthesize
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 106
 line    source statement                                                               procedure and compiler information
 
 3381        if i = VARIABLE & sytype(fixl(mp)) = CHRTYPE then call stringcompare; else  synthesize
 3382        if j = DESCRIPT | j = CHRTYPE then call stringcompare; else                 synthesize
 3383        if j = VARIABLE & sytype(fixl(sp)) = CHRTYPE then call stringcompare; else  synthesize
 3384           do;                                                                      synthesize
 3385              if i = VARIABLE & sytype(fixl(mp)) = BYTETYPE then                    synthesize
 3386                     call forceaccumulator(mp);                                     synthesize
 3387              if j = VARIABLE & sytype(fixl(sp)) = BYTETYPE then                    synthesize
 3388                     call forceaccumulator(sp);                                     synthesize
 3389              if shouldcommute then call forceaccumulator(sp);                      synthesize
 3390              else call forceaccumulator(mp);                                       synthesize
 3391              i = findar;                                                           synthesize
 3392              call emitinst(movei,i,0,1,0,0);                                       synthesize
 3393              call arithemit (cam+inx(mpp1),1);                                     synthesize
 3394              call emitinst (movei,i,0,0,0,0);                                      synthesize
 3395              stillcond = inx(mpp1);                                                synthesize
 3396              acc(reg(mp))=AVAIL;                                                   synthesize
 3397              reg(mp) = i;                                                          synthesize
 3398              type(mp) = ACCUMULATOR;                                               synthesize
 3399           end;                                                                     synthesize
 3400     end;                                                                           synthesize
 3401                                                                                    synthesize case 82.
 3402  /*     82   <relation> ::= =                                         */           synthesize
 3403     inx(mp) = 2;                                                                   synthesize
 3404  /*     83                | <                                         */           synthesize case 83.
 3405     inx(mp) = 1;                                                                   synthesize
 3406  /*     84                | >                                         */           synthesize case 84.
 3407     inx(mp) = 7;                                                                   synthesize
 3408  /*     85                | ~ =                                       */           synthesize case 85.
 3409     inx(mp) = 6;                                                                   synthesize
 3410  /*     86                | ~ <                                       */           synthesize case 86.
 3411     inx (mp) = 5;                                                                  synthesize
 3412  /*     87                | ~ >                                       */           synthesize case 87.
 3413     inx(mp) = 3;                                                                   synthesize
 3414  /*     88                | < =                                       */           synthesize case 88.
 3415     inx(mp) = 3;                                                                   synthesize
 3416  /*     89                | > =                                       */           synthesize case 89.
 3417     inx (mp) = 5;                                                                  synthesize
 3418  /*     90   <string expression> ::= <arithmetic expression>          */           synthesize case 90.
 3419     ;                                                                              synthesize
 3420                                                                                    synthesize case 91.
 3421  /*     91                         | <string expression> ||           */           synthesize
 3422  /*     91                           <arithmetic expression>          */           synthesize
 3423      do; /* catenate two strings */                                                synthesize
 3424        call forcedescriptor (mp);                                                  synthesize
 3425        call delete_move (mp,movem,reg(mp),0,a,0,3);                                synthesize
 3426        acc(reg(mp)) = AVAIL;                                                       synthesize
 3427        call forcedescriptor (sp);                                                  synthesize
 3428        call delete_move (sp,movem,reg(sp),0,b,0,3);                                synthesize
 3429        acc(reg(sp)) = AVAIL;                                                       synthesize
 3430        call save_acs (2);                                                          synthesize
 3431        if acc(11) ~= AVAIL then call emitinst (push,15,0,11,0,0);                  synthesize
 3432        call emitinst (pushj,15,0,catentry,0,2);                                    synthesize
 3433        if acc(11) ~= AVAIL then call emitinst (pop,15,0,11,0,0);                   synthesize
 3434        call restore_acs (2);                                                       synthesize
 3435        i = findar;                                                                 synthesize
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 107
 line    source statement                                                               procedure and compiler information
 
 3436        call emitinst (move,i,0,0,0,0);                                             synthesize
 3437        stillinzero = i;                                                            synthesize
 3438        reg(mp) = i;                                                                synthesize
 3439     end;                                                                           synthesize
 3440                                                                                    synthesize case 92.
 3441  /*     92   <arithmetic expression> ::= <term>                       */           synthesize
 3442     ;                                                                              synthesize
 3443  /*     93                             | <arithmetic expression> +    */           synthesize case 93.
 3444  /*     93                               <term>                       */           synthesize
 3445     call arithemit (add,1);                                                        synthesize
 3446  /*     94                             | <arithmetic expression> -    */           synthesize case 94.
 3447  /*     94                               <term>                       */           synthesize
 3448     call arithemit (sub,0);                                                        synthesize
 3449  /*     95                             | + <term>                     */           synthesize case 95.
 3450     call movestacks (mpp1, mp);                                                    synthesize
 3451                                                                                    synthesize case 96.
 3452  /*     96                             | - <term>                     */           synthesize
 3453     do;                                                                            synthesize
 3454        call movestacks (mpp1, mp);                                                 synthesize
 3455        if type (mp) = CONSTANT then fixv (mp) = - fixv (mp);                       synthesize
 3456        else                                                                        synthesize
 3457           do;                                                                      synthesize
 3458              call forceaccumulator (mp);                                           synthesize
 3459              call emitinst (movn,reg(mp),0,reg(mp),0,0);                           synthesize
 3460           end;                                                                     synthesize
 3461     end;                                                                           synthesize
 3462                                                                                    synthesize case 97.
 3463  /*     97   <term> ::= <primary>                                     */           synthesize
 3464     ;                                                                              synthesize
 3465  /*     98            | <term> * <primary>                            */           synthesize case 98.
 3466     call arithemit (imul,1);                                                       synthesize
 3467  /*     99            | <term> / <primary>                            */           synthesize case 99.
 3468     call divide_code(1);                                                           synthesize
 3469  /*    100            | <term> mod <primary>                          */           synthesize case 100.
 3470     call divide_code(0);                                                           synthesize
 3471  /*    101   <primary> ::= <CONSTANT>                                 */           synthesize case 101.
 3472     ;                                                                              synthesize
 3473  /*    102               | <VARIABLE>                                 */           synthesize case 102.
 3474     ;                                                                              synthesize
 3475  /*    103               | ( <expression> )                           */           synthesize case 103.
 3476     call movestacks (mpp1, mp);                                                    synthesize
 3477                                                                                    synthesize case 104.
 3478  /*    104   <VARIABLE> ::= <identifier>                              */           synthesize
 3479     /* the following use is made of the parallel stacks below <VARIABLE>           synthesize
 3480            cnt      the number of subscripts                                       synthesize
 3481            fixl     the symbol table pointer                                       synthesize
 3482            fixv     builtin code if SPECIAL                                        synthesize
 3483            type     VARIABLE                                                       synthesize
 3484            inx      zero or ACCUMULATOR of subscript                               synthesize
 3485        after the VARIABLE is forced into an ACCUMULATOR                            synthesize
 3486            type     ACCUMULATOR or DESCRIPT                                        synthesize
 3487            reg      current ACCUMULATOR                                            synthesize
 3488     */                                                                             synthesize
 3489     do;   /* find the identifier in the symbol table */                            synthesize
 3490        call id_lookup (mp);                                                        synthesize
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 108
 line    source statement                                                               procedure and compiler information
 
 3491         if fixl (mp) = -1 then call undeclared_id (mp);                            synthesize
 3492     end;                                                                           synthesize
 3493                                                                                    synthesize case 105.
 3494  /*    105                | <subscript head> <expression> )           */           synthesize
 3495                                                                                    synthesize
 3496     do; /* either a procedure call, array, or builtin function */                  synthesize
 3497        cnt (mp) = cnt (mp) + 1;          /* count subscripts */                    synthesize
 3498        i = fixv (mp);                    /* zero or builtin function number */     synthesize
 3499        if i < 6 then do case i;                                                    synthesize
 3500           /* case 0 -- array or call */                                            synthesize case 0.
 3501           do;                                                                      synthesize
 3502              if sytype (fixl (mp)) = PROCTYPE                                      synthesize
 3503               | sytype (fixl (mp)) = CHARPROCTYPE then call stuff_parameter;       synthesize
 3504              else                                                                  synthesize
 3505                 if cnt (mp) > 1 then                                               synthesize
 3506                    call error ('multiple subscripts not allowed', 0);              synthesize
 3507                 else                                                               synthesize
 3508                    do;                                                             synthesize
 3509                       call forceaccumulator (mpp1);                                synthesize
 3510                       inx (mp) = reg(mpp1);                                        synthesize
 3511                    end;                                                            synthesize
 3512           end;                                                                     synthesize
 3513           /* case 1 -- builtin function length */                                  synthesize case 1.
 3514           do;                                                                      synthesize
 3515              call forcedescriptor (mpp1);                                          synthesize
 3516              call emitinst(lsh,reg(mpp1),0,    -27,0,0);/* shift out address */    synthesize
 3517              type (mp) = ACCUMULATOR;                                              synthesize
 3518              reg(mp) = reg(mpp1);                                                  synthesize
 3519           end;                                                                     synthesize
 3520           /* case 2 -- builtin function substr */                                  synthesize case 2.
 3521           do;  /* builtin function substr */                                       synthesize
 3522              if cnt(mp) = 2 then                                                   synthesize
 3523                 do;                                                                synthesize
 3524                    if type(mpp1) = CONSTANT then                                   synthesize
 3525                       do;  /* emit a complex CONSTANT */                           synthesize
 3526                          call emitconstant (shl(fixv(mpp1),27)-fixv(mpp1));        synthesize
 3527                          call emitinst (sub,reg(mp),0,adr,0,1);                    synthesize
 3528                       end;                                                         synthesize
 3529                    else                                                            synthesize
 3530                       do;                                                          synthesize
 3531                         call forceaccumulator (mpp1);                              synthesize
 3532                         call emitinst (add,reg(mp),0,reg(mpp1),0,0);               synthesize
 3533                         call emitinst (lsh,reg(mpp1),0,    27,0,0);                synthesize
 3534                         call emitinst (sub,reg(mp),0,reg(mpp1),0,0);               synthesize
 3535                         acc(reg(mpp1)) = AVAIL;                                    synthesize
 3536                       end;                                                         synthesize
 3537                 end;                                                               synthesize
 3538              else                                                                  synthesize
 3539                 do;  /* three arguments */                                         synthesize
 3540                    if type(mpp1) = CONSTANT then                                   synthesize
 3541                       do;  /* make a CONSTANT length to or in */                   synthesize
 3542                          call emitconstant (shl(fixv(mpp1),27));                   synthesize
 3543                          call emitinst (ior,reg(mp),0,adr,0,1);                    synthesize
 3544                       end;                                                         synthesize
 3545                    else                                                            synthesize
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 109
 line    source statement                                                               procedure and compiler information
 
 3546                       do;                                                          synthesize
 3547                          call forceaccumulator (mpp1);                             synthesize
 3548                          call emitinst (lsh,reg(mpp1),0,    27,0,0);               synthesize
 3549                          call emitinst(ior,reg(mp),0,reg(mpp1),0,0);               synthesize
 3550                           acc(reg(mpp1)) = AVAIL;                                  synthesize
 3551                       end;                                                         synthesize
 3552                 end;                                                               synthesize
 3553              type (mp) = DESCRIPT;                                                 synthesize
 3554           end;                                                                     synthesize
 3555           /* case 3 -- builtin function byte */                                    synthesize case 3.
 3556           do;  /* builtin function byte */                                         synthesize
 3557              if cnt(mp) = 1 then                                                   synthesize
 3558                 do;                                                                synthesize
 3559                    if type (mpp1) = CHRTYPE then                                   synthesize
 3560                       do;                                                          synthesize
 3561                          fixv(mp) = byte(var(mpp1));                               synthesize
 3562                          type (mp) = CONSTANT;                                     synthesize
 3563                       end;                                                         synthesize
 3564                    else                                                            synthesize
 3565                       do;                                                          synthesize
 3566                          call forcedescriptor (mpp1);                              synthesize
 3567                          call emitinst (and,reg(mpp1),0,addrmask,0,1);             synthesize
 3568                          /* fake a corebyte */                                     synthesize
 3569                          type(mpp1) = VARIABLE;                                    synthesize
 3570                          fixl(mpp1) = corebyteloc;                                 synthesize
 3571                          inx(mpp1) = reg(mpp1);                                    synthesize
 3572                          cnt(mpp1) = 1;                                            synthesize
 3573                          call forceaccumulator (mpp1);                             synthesize
 3574                          type(mp) = type(mpp1);                                    synthesize
 3575                          reg(mp) = reg(mpp1);                                      synthesize
 3576                       end;                                                         synthesize
 3577                 end;                                                               synthesize
 3578              else if cnt (mp) = 2 then                                             synthesize
 3579                 do;                                                                synthesize
 3580                    sp = mpp1;  /* so we can use arithemit */                       synthesize
 3581                    call arithemit (add,1);                                         synthesize
 3582                    /* fake a corebyte */                                           synthesize
 3583                    type(mpp1) = VARIABLE;                                          synthesize
 3584                    fixl(mpp1) = corebyteloc;                                       synthesize
 3585                          cnt(mpp1) = 1;                                            synthesize
 3586                    inx(mpp1) = reg(mp);                                            synthesize
 3587                    call forceaccumulator(mpp1);                                    synthesize
 3588                    type(mp) = type(mpp1);                                          synthesize
 3589                    reg(mp) = reg(mpp1);                                            synthesize
 3590                 end;                                                               synthesize
 3591              else call error (toomsg || syt(fixl(mp)),0);                          synthesize
 3592           end;                                                                     synthesize
 3593           /* case 4 -- builtin function shl */                                     synthesize case 4.
 3594           call shift_code (0);           /* <- */                                  synthesize
 3595           /* case 5 -- builtin function shr */                                     synthesize case 5.
 3596           call shift_code (1);           /* -> */                                  synthesize
 3597        end; /* case on i */                                                        synthesize case 6.
 3598        else if i = 9 then call emit_inline(1);  /*built-in function inline */      synthesize
 3599        else if i = 18 then                                                         synthesize
 3600           do;  /* builtin function addr */                                         synthesize
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 110
 line    source statement                                                               procedure and compiler information
 
 3601              call forceaddress (mpp1);                                             synthesize
 3602              type (mp) = ACCUMULATOR;                                              synthesize
 3603           end;                                                                     synthesize
 3604        else do;    /* some sort of builtin function */                             synthesize
 3605                call forceaccumulator(mpp1);                                        synthesize
 3606                if cnt(mp) = 1 then reg(mp) = reg(mpp1);                            synthesize
 3607                 else inx(mp) = reg(mpp1);                                          synthesize
 3608             end;                                                                   synthesize
 3609     end;                                                                           synthesize
 3610                                                                                    synthesize case 106.
 3611  /*    106   <subscript head> ::= <identifier> (                      */           synthesize
 3612     do;                                                                            synthesize
 3613        call id_lookup(mp);                                                         synthesize
 3614        if fixl(mp) = -1 then call undeclared_id (mp);                              synthesize
 3615     end;                                                                           synthesize
 3616                                                                                    synthesize case 107.
 3617  /*    107                      | <subscript head> <expression> ,     */           synthesize
 3618                                                                                    synthesize
 3619     do; /* builtin function or procedure call */                                   synthesize
 3620        cnt (mp) = cnt (mp) + 1;                                                    synthesize
 3621        if fixv (mp) = 0 then                                                       synthesize
 3622           do; /* not a builtin function */                                         synthesize
 3623              if sytype(fixl(mp)) = PROCTYPE                                        synthesize
 3624               | sytype(fixl(mp)) = CHARPROCTYPE then call stuff_parameter;         synthesize
 3625              else call forceaccumulator (mpp1);                                    synthesize
 3626           end;                                                                     synthesize
 3627        else if fixv(mp) = 2 | fixv (mp) = 3 then                                   synthesize
 3628           do; /* substr or byte */                                                 synthesize
 3629              if cnt(mp) = 1 then                                                   synthesize
 3630                 do;                                                                synthesize
 3631                    call forcedescriptor (mpp1);                                    synthesize
 3632                    type (mp) = ACCUMULATOR;                                        synthesize
 3633                    reg(mp) = reg(mpp1);                                            synthesize
 3634                 end;                                                               synthesize
 3635              else if cnt (mp) = 2 & fixv (mp) = 2 then                             synthesize
 3636                 do; /* just substr, we'll note error on byte later */              synthesize
 3637                    if type(mpp1) ~= CONSTANT | fixv(mpp1) ~= 0 then                synthesize
 3638                       do;                                                          synthesize
 3639                          sp = mpp1;  /* so we can use arithemit */                 synthesize
 3640                         call arithemit (add,1);                                    synthesize
 3641                          fixv(mp) = 2; /* if it commutes, arithmit changes it */   synthesize
 3642                       end;                                                         synthesize
 3643                    call emitinst(and,reg(mp),0,addrmask,0,1);/* and out length */  synthesize
 3644                 end;                                                               synthesize
 3645              else call error (toomsg || syt(fixl(mp)),0);                          synthesize
 3646           end;                                                                     synthesize
 3647        else if fixv(mp) = 4 | fixv (mp) = 5 then                                   synthesize
 3648           do; /* shr or shl */                                                     synthesize
 3649              call forceaccumulator (mpp1);                                         synthesize
 3650              reg(mp) = reg(mpp1);                                                  synthesize
 3651           end;                                                                     synthesize
 3652        else if fixv(mp) = 9 then call emit_inline(0); /* inline */                 synthesize
 3653        else do; /* some sort of builtin function */                                synthesize
 3654                if cnt (mp) = 1 then                                                synthesize
 3655                   do;                                                              synthesize
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 111
 line    source statement                                                               procedure and compiler information
 
 3656                      call forceaccumulator (mpp1); /* pick up the VARIABLE */      synthesize
 3657                      reg(mp) = reg(mpp1);                                          synthesize
 3658                   end;                                                             synthesize
 3659                else call error (toomsg || syt(fixl(mp)),0);                        synthesize
 3660             end;                                                                   synthesize
 3661     end;                                                                           synthesize
 3662                                                                                    synthesize case 108.
 3663  /*    108   <CONSTANT> ::= <string>                                  */           synthesize
 3664     type (mp) = CHRTYPE;                                                           synthesize
 3665  /*    109                | <number>                                  */           synthesize case 109.
 3666     type (mp) = CONSTANT;                                                          synthesize
 3667                                                                                    synthesize case 110.
 3668  end;  /* of case on production number */                                          synthesize
 3669  end synthesize;                                                                   synthesize
 
symbol table dump
 
symbol            type       loc   segment defined ref count
production_number fixed     10492     data   2818       1
stack_case        procedure  9014  program   2822       5
  parameter  1    fixed     10499     data   2823       6
toomsg            character   937   string   2820       3
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 112
 line    source statement                                                               procedure and compiler information
 
 3670                                                                                   *
 3671    /*              syntactic parsing functions                              */    *
 3672                                                                                   *
 3673                                                                                   *
 3674   conflict: procedure (current_state);                                            *
 3675                                                                                    conflict
 3676           declare i fixed, current_state fixed;                                    conflict
 3677                                                                                    conflict
 3678           /*   this proc is TRUE if the current token is not   */                  conflict
 3679           /*   a transition symbol from the current state      */                  conflict
 3680                                                                                    conflict
 3681           /*   (a conflict therefore exists between the        */                  conflict
 3682           /*   current state and the next token)               */                  conflict
 3683                                                                                    conflict
 3684           i = index1(current_state);   /*   starting point for state        */     conflict
 3685                                        /*   transition symbols              */     conflict
 3686           do i = i to i+index2(current_state)-1;   /*   compare with each   */     conflict
 3687           if read1(i) = token then return (FALSE); /*   found it            */     conflict
 3688           end;                                                                     conflict
 3689           return (TRUE);   /*   not there   */                                     conflict
 3690                                                                                    conflict
 3691           end conflict;                                                            conflict
 
symbol table dump
 
symbol          type       loc   segment defined ref count
current_state   fixed     10602     data   3674       2
i               fixed     10601     data   3676       5
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 113
 line    source statement                                                               procedure and compiler information
 
 3692                                                                                   *
 3693                                                                                   *
 3694   recover: procedure;                                                             *
 3695                                                                                    recover
 3696           declare answer bit(1);                                                   recover
 3697                                                                                    recover
 3698           /*   this is a very crude error recovery procedure               */      recover
 3699           /*   it returns TRUE if the parse must be resumed in             */      recover
 3700           /*   a new state (the one in the current position of the state   */      recover
 3701           /*   stack)                                                      */      recover
 3702           /*   it returns FALSE if the parse is resumed with the same      */      recover
 3703           /*   state as was intended before recover was called             */      recover
 3704                                                                                    recover
 3705           answer = FALSE;                                                          recover
 3706           /*   if this is the second successive call to recover, discard   */      recover
 3707           /*   one symbol (failsoft is set TRUE by scan)                   */      recover
 3708           if ~ failsoft & 1 then call scan;                                        recover
 3709           failsoft = FALSE;                                                        recover
 3710           /*   find something solid in the text   */                               recover
 3711           do while (~stopit(token) & 1);                                           recover
 3712           call scan;                                                               recover
 3713           end;                                                                     recover
 3714           no_look_ahead_done = FALSE;                                              recover
 3715           /*   delete parse stack until the hard token is   */                     recover
 3716           /*   legal as a transition symbol                 */                     recover
 3717           do while conflict (state_stack(sp));                                     recover
 3718           if sp > 0                                                                recover
 3719                then do;                                                            recover
 3720                     /*   delete one item from the stack   */                       recover
 3721                     sp = sp - 1;                                                   recover
 3722                     answer = TRUE;   /*   parse to be resumed in new state   */    recover
 3723                     end;                                                           recover
 3724                else do;   /*   stack is empty   */                                 recover
 3725                     /*   try to find a legal token (for start state)   */          recover
 3726                      call scan;                                                    recover
 3727                     if token = eofile                                              recover
 3728                          then do;                                                  recover
 3729                               /*   must stop compiling                */           recover
 3730                               /*   resume parse in an illegal state   */           recover
 3731                               answer = TRUE;                                       recover
 3732                               state_stack(sp) = 0;                                 recover
 3733                               return (answer);                                     recover
 3734                               end;                                                 recover
 3735                     end;                                                           recover
 3736           end;                                                                     recover
 3737           /*   found an acceptable token from which to resume the parse   */       recover
 3738           call printline ('resume:' || substr(pointer,length(pointer)-             recover
 3739              (line_length+cp-text_limit-lb-1)+length(bcd)),-1);                    recover
 3740           return (answer);                                                         recover
 3741                                                                                    recover
 3742           end recover;                                                             recover
 
symbol table dump
 
symbol          type       loc   segment defined ref count
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 114
symbol          type       loc   segment defined ref count
 
answer          bit (9)   10604     data   3696       5
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 115
 line    source statement                                                               procedure and compiler information
 
 3743                                                                                   *
 3744                                                                                   *
 3745   compilation_loop:                                                               *
 3746     procedure;                                                                    *
 3747                                                                                    compilation_loop
 3748           declare overflow character initial (                                     compilation_loop
 3749           'stack overflow *** compilation aborted ***');                           compilation_loop
 3750           declare i fixed, j fixed, state fixed;                                   compilation_loop
 3751           declare end_of_file character initial (                                  compilation_loop
 3752           'end of file found unexpectedly *** compilation aborted ***');           compilation_loop
 3753                                                                                    compilation_loop
 3754           /*   this proc parses the input string (by calling the scanner)   */     compilation_loop
 3755           /*   and calls the code emission proc (synthesize) whenever a     */     compilation_loop
 3756           /*   production can be applied                                    */     compilation_loop
 3757                                                                                    compilation_loop
 3758           /*   initialize                                                   */     compilation_loop
 3759           compiling = TRUE;                                                        compilation_loop
 3760           state = START_STATE;                                                     compilation_loop
 3761           sp = -1;                                                                 compilation_loop
 3762           /*   stop compiling if finished                                   */     compilation_loop
 3763   comp:   do while (compiling);                                                    compilation_loop
 3764           /*   find which of the four kinds of states we are dealing with:  */     compilation_loop
 3765           /*   read,apply production,lookahead, or push state               */     compilation_loop
 3766           if state <= MAXR#                                                        compilation_loop
 3767                then do;   /*   read state   */                                     compilation_loop
 3768                     sp = sp+1;   /*   add an element to the stack   */             compilation_loop
 3769                     if sp = STACKSIZE                                              compilation_loop
 3770                          then do;                                                  compilation_loop
 3771                               call error (overflow,2);                             compilation_loop
 3772                               return;                                              compilation_loop
 3773                               end;                                                 compilation_loop
 3774                     state_stack(sp) = state;   /*   push present state   */        compilation_loop
 3775                     i = index1(state);         /*   get starting point   */        compilation_loop
 3776                     if no_look_ahead_done                                          compilation_loop
 3777                          then do;   /*   read if necessary   */                    compilation_loop
 3778                               call scan;                                           compilation_loop
 3779                               no_look_ahead_done = FALSE;                          compilation_loop
 3780                               end;                                                 compilation_loop
 3781                     /*   compare token with each transition symbol in    */        compilation_loop
 3782                     /*   read state                                      */        compilation_loop
 3783                      do i = i to i+index2(state)-1;                                compilation_loop
 3784                     if read1(i) = token                                            compilation_loop
 3785                          then do;   /*   found it   */                             compilation_loop
 3786                               var(sp) = bcd;                                       compilation_loop
 3787                               fixv(sp) = number_value;                             compilation_loop
 3788                               fixl(sp) = card_count;                               compilation_loop
 3789                               ppsave(sp) = pp;                                     compilation_loop
 3790                               state = read2(i);                                    compilation_loop
 3791                               no_look_ahead_done = TRUE;                           compilation_loop
 3792                               go to comp;                                          compilation_loop
 3793                               end;                                                 compilation_loop
 3794                     end;                                                           compilation_loop
 3795                     /*   found an error   */                                       compilation_loop
 3796                     call error ('illegal symbol pair: ' ||                         compilation_loop
 3797                                 vocab(state_name(state)) || x1 ||                  compilation_loop
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 116
 line    source statement                                                               procedure and compiler information
 
 3798                                 vocab(token),1);                                   compilation_loop
 3799                     call stack_dump;    /*  display the stack   */                 compilation_loop
 3800                     /*   try to recover   */                                       compilation_loop
 3801                     if recover                                                     compilation_loop
 3802                          then do;                                                  compilation_loop
 3803                               state = state_stack(sp);   /*   new starting pt  */  compilation_loop
 3804                               if state = 0                                         compilation_loop
 3805                                    then do;   /*   unexpected eofile   */          compilation_loop
 3806                                         call error (end_of_file,2);                compilation_loop
 3807                                         return;                                    compilation_loop
 3808                                         end;                                       compilation_loop
 3809                               end;                                                 compilation_loop
 3810                     sp = sp-1;   /*   stack at sp contains junk   */               compilation_loop
 3811                     end;                                                           compilation_loop
 3812                else                                                                compilation_loop
 3813           if state > MAXP#                                                         compilation_loop
 3814                then do;   /*   apply production state   */                         compilation_loop
 3815                     /*   sp points at right end of production   */                 compilation_loop
 3816                     /*   mp points at lest end of production   */                  compilation_loop
 3817                     mp = sp-index2(state);                                         compilation_loop
 3818                     mpp1 = mp+1;                                                   compilation_loop
 3819                     call synthesize (state-MAXP#);   /*   apply production   */    compilation_loop
 3820                     sp = mp;   /*   reset stack pointer   */                       compilation_loop
 3821                     i = index1(state);                                             compilation_loop
 3822                     /*   compare top of state stack with tables   */               compilation_loop
 3823                     j = state_stack(sp);                                           compilation_loop
 3824                     do while apply1(i) ~= 0;                                       compilation_loop
 3825                     if j = apply1(i) then go to top_match;                         compilation_loop
 3826                     i = i+1;                                                       compilation_loop
 3827                     end;                                                           compilation_loop
 3828                     /*   has the program goal been reached   */                    compilation_loop
 3829          top_match: if apply2(i) =0                                                compilation_loop
 3830                          then do;   /*   yes it has   */                           compilation_loop
 3831                               compiling = FALSE;                                   compilation_loop
 3832                               return;                                              compilation_loop
 3833                               end;                                                 compilation_loop
 3834                     state = apply2(i);   /*   pick up the next state   */          compilation_loop
 3835                     end;                                                           compilation_loop
 3836                else                                                                compilation_loop
 3837           if state <= MAXL#                                                        compilation_loop
 3838                then do;   /*   lookahead state   */                                compilation_loop
 3839                      i = index1(state);   /*   index into the table   */           compilation_loop
 3840                     if no_look_ahead_done                                          compilation_loop
 3841                          then do;   /*   get a token   */                          compilation_loop
 3842                               call scan;                                           compilation_loop
 3843                               no_look_ahead_done = FALSE;                          compilation_loop
 3844                               end;                                                 compilation_loop
 3845                     /*   check token against legal lookahead transition symbols*/  compilation_loop
 3846                     do while look1(i) ~= 0;                                        compilation_loop
 3847                     if look1(i) = token                                            compilation_loop
 3848                          then go to look_match;   /*   found one   */              compilation_loop
 3849                     i = i+1;                                                       compilation_loop
 3850                     end;                                                           compilation_loop
 3851         look_match: state = look2(i);                                              compilation_loop
 3852                     end;                                                           compilation_loop
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 117
 line    source statement                                                               procedure and compiler information
 
 3853                else do;   /*   push state   */                                     compilation_loop
 3854                     sp = sp+1;   /*   push a non-terminal onto the stack   */      compilation_loop
 3855                     if sp = STACKSIZE                                              compilation_loop
 3856                          then do;                                                  compilation_loop
 3857                               call error (overflow,2);                             compilation_loop
 3858                               return;                                              compilation_loop
 3859                               end;                                                 compilation_loop
 3860                     /*   push a state # into the state_stack   */                  compilation_loop
 3861                     state_stack(sp) = index2(state);                               compilation_loop
 3862                     /*   get next state                        */                  compilation_loop
 3863                     state = index1(state);                                         compilation_loop
 3864                     end;                                                           compilation_loop
 3865           end;   /*   of compile loop   */                                         compilation_loop
 3866                                                                                    compilation_loop
 3867           end compilation_loop;                                                    compilation_loop
 
symbol table dump
 
symbol          type       loc   segment defined ref count
comp            label     11608  program   3763       1
end_of_file     character   956   string   3751       1
i               fixed     10617     data   3750      19
j               fixed     10618     data   3750       2
look_match      label     11846  program   3848       1
overflow        character   955   string   3748       2
state           fixed     10619     data   3750      20
top_match       label     11793  program   3825       1
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 118
 line    source statement                                                               procedure and compiler information
 
 3868                                                                                   *
 3869  print_time:                                                                      *
 3870     procedure (text, time);                                                       *
 3871     /* print text followed by time, which is in milliseconds */                    print_time
 3872        declare text character, time fixed;                                         print_time
 3873        k = time;                                                                   print_time
 3874        i = k / 60000;                                                              print_time
 3875        j = k mod 60000 / 1000;                                                     print_time
 3876        k = k mod 1000;                                                             print_time
 3877        call printline (text || i || ':' || j || '.' || k,-1);                      print_time
 3878     end print_time;                                                                print_time
 
symbol table dump
 
symbol          type       loc   segment defined ref count
text            character   958   string   3870       1
time            fixed     10642     data   3870       1
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 119
 line    source statement                                                               procedure and compiler information
 
 3879                                                                                   *
 3880     /*   e x e c u t i o n   s t a r t s   h e r e                          */    *
 3881                                                                                   *
 3882     declare time_start fixed,                                                     *
 3883             time_init fixed,                                                      *
 3884             time_compile fixed,                                                   *
 3885             time_finish fixed;                                                    *
 3886                                                                                   *
 3887     time_start = runtime;           /* get time(cpu) started*/                    *
 3888     call initialize;                                                              *
 3889     time_init = runtime;     /* time to initialize */                             *
 3890     call compilation_loop;                                                        *
 3891     time_compile = runtime;     /* time to compile the program*/                  *
 3892     control(byte('E')) = FALSE;                                                   *
 3893     control(byte('B')) = FALSE;                                                   *
 3894     subtitle = '';                                                                *
 3895     if control(byte('S')) then call symboldump;                                   *
 3896     else EJECT_PAGE;                                                              *
 3897     /* now enter the value of ndescript                                        */ *
 3898     call emitlabel (ndesc,5);            /* generate label */                     *
 3899     if control(byte('A')) then                                                    *
 3900        output(DATAFILE) = '$' || ndesc || ':'; /* label for assembler */          *
 3901     call emitdataword (dsp-1);           /* put down number of desc's */          *
 3902     if control(byte('A')) then                                                    *
 3903        output(DATAFILE) = 's=.;';           /* start string segment */            *
 3904     /* add the descriptors to the data segment                                 */ *
 3905     do i = 0 to dsp-1;                                                            *
 3906        if control(byte('A')) then                                                 *
 3907           output(DATAFILE)='       byte (9)'||descl(i)|| '(27)' ||desca(i)|| ';'; *
 3908        call output_dataword (shl(descl(i),27) + desca(i), dp);                    *
 3909        call emitlabel (i,3);                                                      *
 3910        dp = dp + 1;                                                               *
 3911     end;                                                                          *
 3912     /* final code for system interface                                         */ *
 3913     call emitinst (4,0,0,0,0,0);                                                  *
 3914     call flush_data_buffer;                                                       *
 3915     call flush_labels;                                                            *
 3916     do while code_tail ~= code_head;                                              *
 3917        call output_codeword;                                                      *
 3918        end;                                                                       *
 3919     call output_codeword;                                                         *
 3920     call flush_code_buffer;                                                       *
 3921     if control(byte('A')) then                                                    *
 3922        do;                                                                        *
 3923           output (CODEFILE) = '       end $0;';                                   *
 3924           /* copy code file to end of data file */                                *
 3925           codestring = input(CODEFILE);                                           *
 3926           do while length(codestring) > 0;                                        *
 3927              output(DATAFILE) = codestring;                                       *
 3928              codestring = input(CODEFILE);                                        *
 3929           end;                                                                    *
 3930           output (CODEFILE) = ' ';                                                *
 3931        end;                                                                       *
 3932                                                                                   *
 3933     file(RELFILE) = SYMB_TYPE + 2;      /* generate external refs */              *
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 120
 line    source statement                                                               procedure and compiler information
 
 3934     file(RELFILE) = "(3)040000000000";                                            * c40 = 524288
 3935     file(RELFILE) = "(3)600000000000" + radix50 ('xpllib');                       * c41 = 4294967296
 3936     file(RELFILE) = library;                                                      * c42 = -17179869184
 3937     file(RELFILE) = START_TYPE + 1;                                               *
 3938     file(RELFILE) = "(3)200000000000";                                            * c43 = 1835008
 3939     file(RELFILE) = "(3)400000" + startloc;                                       *
 3940     file(RELFILE) = END_TYPE + 2;                                                 *
 3941     file(RELFILE) = "(3)240000000000";                                            *
 3942     file(RELFILE) = "(3)400000" + pp;                                             * c44 = 21474836480
 3943     file(RELFILE) = dp;                                                           *
 3944                                                                                   *
 3945     time_finish = runtime;   /* time to do all but final stats */                 *
 3946     call printline (substr(x70, 0, 40) || 'c o m p i l e r   s t a t i s t i c s',-1);*
 3947     call printline (card_count || ' lines containing ' || statement_count ||      * c45 = 5368709120
 3948        ' statements were compiled.',0);                                           *
 3949     if error_count = 0 then call printline ('no errors were detected.',-1);       *
 3950     else if error_count > 1 then                                                  *
 3951        call printline (error_count || ' errors (' || severe_errors                *
 3952        || ' severe) were detected.',-1);                                          *
 3953     else if severe_errors = 1 then call printline ('one severe error was detected.',-1);*
 3954        else call printline ('one error was detected.',-1);                        *
 3955      if previous_error > 0 then                                                   *
 3956         call printline ('last error was on line ' || previous_error ,-1);         *
 3957     call printline (pp || ' words of program, ' || dp-dsp || ' words of data, and ' ||*
 3958        dsp || ' words of descriptors.  total core requirement ' || pp+dp ||       *
 3959        ' words.',-1);                                                             *
 3960                                                                                   *
 3961  /* now compute times and print them */                                           *
 3962     time_init = time_init - time_start;                                           *
 3963     time_compile = time_compile - time_start;                                     *
 3964     time_finish = time_finish - time_start;                                       *
 3965                                                                                   *
 3966     call print_time ('total time in compiler    = ',time_finish);                 *
 3967     call print_time ('initialization time       = ',time_init);                   *
 3968     call print_time ('actual compilation time   = ',time_compile - time_init);    *
 3969     call print_time ('post-compilation clean-up = ',time_finish-time_compile);    *
 3970                                                                                   *
 3971     if control(byte('D')) then call dumpit;                                       *
 3972  eof eof eof eof eof eof eof eof eof eof eof eof eof eof eof eof eof eof eof eof  *
 
symbol table dump
 
symbol                type       loc   segment defined ref count
a                     fixed      1931     data    279      10
acc                   fixed      1937     data    284      43
add                   fixed      6261     data    404       9
addi                  fixed      6262     data    405       4
addm                  fixed      6263     data    406       2
addrmask              fixed      1935     data    281       5
adr                   fixed      2147     data    351      16
alphabet              character   100   string    224       1
and                   fixed      6264     data    407       8
andi                  fixed      6265     data    408       3
aosa                  fixed      6266     data    409       1
apply1                bit (9)     932     data    126       2
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 121
symbol                type       loc   segment defined ref count
 
apply2                bit (9)    1062     data    155       2
arithemit             procedure  5031  program   2020       9
  parameter  1        fixed      9696     data   2020      21
  parameter  2        fixed      9697     data   2020      10
b                     fixed      1932     data    279       9
backmsg               character   751   string    541       4
backup                procedure  3871  program   1692       3
balance               character   104   string    240       8
base                  fixed      1699     data    234       3
bcd                   character    97   string    190      27
bchar                 procedure   971  program    725       2
blt                   fixed      6267     data    410       2
boolbranch            procedure  5223  program   2066       2
  parameter  1        fixed      9708     data   2066       7
  parameter  2        fixed      9709     data   2066       4
buffer                character   101   string    225      15
build_bcd             procedure   561  program    618       2
  parameter  1        bit (9)    9157     data    619       3
byteptrs              fixed      1914     data    262       6
c                     fixed      1933     data    279       3
calli                 fixed      6268     data    411       1
callsub               procedure  3818  program   1674       1
  parameter  1        fixed      9612     data   1674       2
  parameter  2        fixed      9613     data   1674       2
  parameter  3        fixed      9614     data   1674       4
calltype              fixed      1920     data    268       3
cam                   fixed      6269     data    412       5
camge                 fixed      6270     data    413       1
caml                  fixed      6271     data    414       1
camle                 fixed      6272     data    415       1
camn                  fixed      6273     data    416       2
card_count            fixed      1691     data    226      13
casep                 fixed      9103     data    537      12
casestack             fixed      8927     data    536       3
catentry              fixed      1917     data    265       2
ch                    fixed      1384     data    190       7
char                  procedure   945  program    710       7
chartype              bit (9)    1427     data    211      11
char_temp             character   260   string    466       7
check_string_overflow procedure  3805  program   1669       3
clearars              procedure  3323  program   1474       6
cmprhi                fixed      6274     data    417       2
cnt                   fixed      8720     data    528      36
code                  character   232   string    307       8
codemsg               character   749   string    539       4
codestring            character   236   string    313       4
code_buffer           fixed      1967     data    318       7
code_full             bit (9)    1962     data    308       7
code_head             fixed      1963     data    309      26
code_pp               fixed      2028     data    322       4
code_rbits            fixed      2032     data    323       4
code_rel              fixed      2024     data    321       4
code_tail             fixed      1964     data    310      13
compactify            procedure   128  program      0       1
compareswap           fixed      6312     data    455       1
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 122
symbol                type       loc   segment defined ref count
 
compilation_loop      procedure 11602  program   3745       1
compiling             fixed      1909     data    255       6
concatenate           fixed      1707     data    239       2
conflict              procedure 11477  program   3674       1
  parameter  1        fixed     10602     data   3674       3
control               bit (9)    1555     data    211      61
corebyteloc           fixed      1923     data    271       3
count_arith           fixed      1956     data    290       3
count_compact         fixed        33     data      0       3
count_force           fixed      1955     data    289       3
count_inst            fixed      1954     data    288       3
count_scan            fixed      1953     data    287       3
count_store           fixed      1957     data    291       3
cp                    fixed      1385     data    190      62
current_procedure     character   103   string    229       8
datacard              character   231   string    305      13
datamsg               character   750   string    540       5
data_buffer           fixed      1986     data    319       6
dctr                  fixed      2039     data    328      15
deblank               procedure   958  program    718       3
delete_move           procedure  3906  program   1702       8
  parameter  1        fixed      9615     data   1703      12
  parameter  2        fixed      9616     data   1703      11
  parameter  3        fixed      9617     data   1703      11
  parameter  4        fixed      9618     data   1703      10
  parameter  5        fixed      9619     data   1703      11
  parameter  6        fixed      9620     data   1703      10
  parameter  7        fixed      9621     data   1703      10
desca                 fixed      2155     data    356       3
descl                 fixed      3156     data    357       3
descref               fixed      4157     data    358       5
divide                fixed      1703     data    237       2
divide_code           procedure  5523  program   2149       2
  parameter  1        fixed      9721     data   2149       4
dloc                  fixed      2040     data    329       5
dp                    fixed      1965     data    311      60
dpb                   fixed      6275     data    418       3
dpoffset              fixed      1966     data    312      21
dptr                  fixed      2038     data    327      12
dsp                   fixed      5158     data    359      24
dumpit                procedure  6237  program   2334       1
emitblock             procedure  2131  program   1116       3
  parameter  1        fixed      9262     data   1117       5
emitbyte              procedure  2272  program   1142       4
  parameter  1        fixed      9271     data   1143       7
emitcodeword          procedure  2423  program   1172       1
  parameter  1        character   793   string   1172       2
  parameter  2        fixed      9487     data   1172       2
  parameter  3        fixed      9488     data   1172       2
emitconstant          procedure  2328  program   1153      10
  parameter  1        fixed      9276     data   1154      15
emitdataword          procedure  2197  program   1128      19
  parameter  1        fixed      9269     data   1129      21
emitdesc              procedure  2949  program   1346       7
  parameter  1        fixed      9523     data   1346       9
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 123
symbol                type       loc   segment defined ref count
 
  parameter  2        fixed      9524     data   1346       9
emitinst              procedure  2737  program   1270     219
  parameter  1        fixed      9505     data   1270     224
  parameter  2        fixed      9506     data   1270     221
  parameter  3        fixed      9507     data   1270     221
  parameter  4        fixed      9508     data   1270     226
  parameter  5        fixed      9509     data   1270     222
  parameter  6        fixed      9510     data   1270     222
emitlabel             procedure  2520  program   1199      13
  parameter  1        fixed      9490     data   1199      19
  parameter  2        fixed      9491     data   1199      18
emit_inline           procedure  3968  program   1733       2
  parameter  1        bit (9)    9622     data   1734       3
enter                 procedure  3045  program   1377       8
  parameter  1        character   817   string   1377      13
  parameter  2        fixed      9535     data   1377      11
  parameter  3        fixed      9536     data   1377      10
  parameter  4        fixed      9537     data   1377      10
eofile                fixed      1704     data    237       3
error                 procedure   431  program    585      56
  parameter  1        character   761   string    586      60
  parameter  2        fixed      9131     data    586      57
error_count           fixed      1692     data    226       5
expansion_count       fixed      1896     data    245       4
failsoft              fixed      1908     data    255       3
falseloc              fixed      1913     data    261       1
filemsg               character   752   string    542       2
findar                procedure  3334  program   1481      12
findlabel             procedure  3012  program   1361      11
fixl                  fixed      8873     data    532      78
fixv                  fixed      8771     data    530      58
flush_code_buffer     procedure  1758  program    983       3
flush_datacard        procedure  2064  program   1104       6
flush_data_buffer     procedure  1722  program    966       3
flush_labels          procedure  1967  program   1059       2
forceaccumulator      procedure  4161  program   1811      33
  parameter  1        fixed      9646     data   1811      67
forceaddress          procedure  3404  program   1514       1
  parameter  1        fixed      9578     data   1515       2
forcedescriptor       procedure  4626  program   1921      11
  parameter  1        fixed      9675     data   1922      21
for_count             fixed      2144     data    335      13
for_label             fixed      2093     data    334       6
for_ref               fixed      2042     data    333       7
freebase              fixed        32     data      0       2
freelimit             fixed        11     data      0       2
genstore              procedure  4693  program   1939       3
  parameter  1        fixed      9676     data   1939      20
  parameter  2        fixed      9677     data   1939      23
get_card              procedure   590  program    625       5
hash                  fixed      7876     data    516       9
hasher                procedure  3019  program   1369       5
  parameter  1        character   816   string   1370       8
hll                   fixed      6276     data    419       5
hlrz                  fixed      6277     data    420       1
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 124
symbol                type       loc   segment defined ref count
 
hrli                  fixed      6278     data    421       2
hrlm                  fixed      6279     data    422       1
hrrei                 fixed      6280     data    423       1
i                     fixed      6329     data    468     152
idcompares            fixed      6323     data    459       5
ident                 fixed      1700     data    237       3
idiv                  fixed      6281     data    424       1
idivi                 fixed      6282     data    425       1
idpb                  fixed      6283     data    426       3
idx                   fixed      8553     data    518       7
id_lookup             procedure  3213  program   1425       3
  parameter  1        fixed      9558     data   1426      12
ildb                  fixed      6284     data    427       3
imul                  fixed      6285     data    428       1
index1                fixed      1089     data    162       5
index2                bit (9)    1324     data    175       4
info                  character   259   string    465       8
initialize            procedure  6560  program   2388       1
instruct              fixed      5749     data    402       8
inx                   fixed      8669     data    527      53
ior                   fixed      6286     data    429       4
itype                 fixed      2148     data    352       4
i_format              procedure   351  program    549       6
  parameter  1        fixed      9119     data    550       7
  parameter  2        fixed      9120     data    550       8
i_string              character   261   string    467      12
j                     fixed      6330     data    468      55
jbase                 fixed      1698     data    234      10
jrst                  fixed      6287     data    430      12
jump                  fixed      6288     data    431       2
jumpe                 fixed      6289     data    432       2
jumpge                fixed      6290     data    433       1
jumpn                 fixed      6291     data    434       2
k                     fixed      6331     data    468      22
l                     fixed      6332     data    468       2
labelset              fixed      1705     data    238       1
label_buffer          fixed      2005     data    320       5
label_count           fixed      2041     data    330      10
label_gen             character   227   string    283       7
label_sink            fixed      1936     data    282       3
lb                    fixed      1708     data    240      12
ldb                   fixed      6292     data    435       2
lengthmask            fixed      1934     data    280       4
library               fixed      1927     data    275       2
library_call          procedure  4072  program   1766       5
  parameter  1        fixed      9637     data   1766       8
  parameter  2        fixed      9638     data   1766       7
  parameter  3        fixed      9639     data   1766       9
  parameter  4        fixed      9640     data   1766       9
library_save          fixed      1928     data    276       1
limitword             fixed      1924     data    272       3
line_count            fixed      1959     data    296      10
line_length           fixed      1695     data    228       3
look1                 bit (9)     914     data    120       2
look2                 bit (9)    1044     data    150       1
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 125
symbol                type       loc   segment defined ref count
 
lowup                 character procedure  1039  program    745       1
  parameter  1        character   772   string    746       5
lsh                   fixed      6293     data    436      14
lshc                  fixed      6294     data    437       7
macro_count           fixed      1773     data    243       6
macro_declare         fixed      1834     data    243       4
macro_index           bit (9)    1709     data    242       5
macro_name            character   105   string    241      11
macro_text            character   166   string    242       5
maxndecsy             fixed      6335     data    469       3
monitor_call          procedure  4129  program   1796       3
  parameter  1        fixed      9642     data   1796       4
  parameter  2        fixed      9644     data   1796       5
  parameter  3        fixed      9643     data   1796       4
move                  fixed      6295     data    438      34
movei                 fixed      6296     data    439      21
movem                 fixed      6297     data    440      19
mover                 fixed      1921     data    269       3
movestacks            procedure  3370  program   1501       9
  parameter  1        fixed      9576     data   1502      17
  parameter  2        fixed      9577     data   1502      17
movm                  fixed      6298     data    441       1
movn                  fixed      6299     data    442       2
mp                    fixed      8925     data    533     252
mpp1                  fixed      8926     data    533     112
ndecsy                fixed      6334     data    469      38
ndesc                 fixed      1926     data    274       4
newdp                 fixed      2149     data    353      10
newdpoffset           fixed      2151     data    353       6
newdsp                fixed      2150     data    353       4
nmbrentry             fixed      1918     data    266       2
not_letter_or_digit   bit (9)    1619     data    212       5
no_look_ahead_done    bit (9)    1910     data    258       7
number                fixed      1702     data    237       3
number_value          fixed      1697     data    234       8
olddp                 fixed      2152     data    354       4
olddpoffset           fixed      2154     data    354       4
olddsp                fixed      2153     data    354       2
opname                character   238   string    361       2
orsymbol              fixed      1706     data    239       2
outputlabel           procedure  2498  program   1191       2
  parameter  1        fixed      9489     data   1192       3
output_codeword       procedure  1884  program   1030       5
output_dataword       procedure  2004  program   1079       3
  parameter  1        fixed      9258     data   1080       5
  parameter  2        fixed      9259     data   1080       6
page_count            fixed      1958     data    295       4
parct                 fixed      6336     data    469      18
pointer               character    99   string    198       4
pop                   fixed      6300     data    443       2
popj                  fixed      6301     data    444      13
pp                    fixed      1961     data    306      42
ppsave                fixed      8822     data    531      12
previous_error        fixed      1694     data    227       5
printline             procedure   374  program    560      50
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 126
symbol                type       loc   segment defined ref count
 
  parameter  1        character   753   string    561      52
  parameter  2        fixed      9122     data    561      54
print_time            procedure 11884  program   3869       4
  parameter  1        character   958   string   3870       5
  parameter  2        fixed     10642     data   3870       5
procedure_depth       fixed      1696     data    230       6
procmark              fixed      6333     data    469      21
proc_start            procedure  3597  program   1581       4
psbits                fixed      1915     data    263       6
ptr                   fixed      8132     data    517       9
push                  fixed      6302     data    445       2
pushj                 fixed      6303     data    446      10
pword                 fixed      2145     data    336       4
radix50               procedure  1794  program   1002       2
  parameter  1        character   782   string   1003       6
rctr                  fixed      2037     data    326      15
read1                 bit (9)     829     data    105       2
read2                 bit (9)     959     data    132       1
reading               bit (9)    1960     data    304       4
recover               procedure 11510  program   3694       1
refcheck              procedure  2678  program   1240       3
  parameter  1        fixed      9496     data   1241      12
reg                   fixed      8618     data    526     123
reserved_limit        fixed      1426     data    201       3
restore_acs           procedure  3568  program   1571       4
  parameter  1        fixed      9601     data   1572       6
returned_type         fixed      6337     data    470      13
rot                   fixed      6304     data    447       4
rptr                  fixed      2036     data    325      13
s                     character   237   string    360      21
save_acs              procedure  3543  program   1562       4
  parameter  1        fixed      9598     data   1563       5
scan                  procedure  1090  program    758       6
setca                 fixed      6305     data    448       1
setinit               procedure  3431  program   1525       2
setlimit              procedure  5366  program   2103       2
setzm                 fixed      6306     data    449       2
severe_errors         fixed      1693     data    227       5
shift_code            procedure  5635  program   2191       2
  parameter  1        fixed      9733     data   2192       4
shouldcommute         procedure  4975  program   2013       2
skip                  fixed      6307     data    450       1
skipe                 fixed      6308     data    451       1
sojg                  fixed      6309     data    452       3
source                character   230   string    299      18
sp                    fixed      8924     data    533      97
stack_dump            procedure  8952  program   2798       2
startloc              fixed      2146     data    337       2
statement_count       fixed      6322     data    458       4
state_name            bit (9)     804     data     93       2
state_stack           bit (9)    8554     data    524       7
stepk                 fixed      1930     data    278       3
stillcond             fixed      6320     data    456       5
stillinzero           fixed      6321     data    457      11
stopit                bit (9)    1897     data    255       7
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 127
symbol                type       loc   segment defined ref count
 
str                   fixed      1929     data    277       4
strcomp               fixed      1919     data    267       2
string                fixed      1701     data    237       5
stringcompare         procedure  5709  program   2216       4
string_check          fixed      1916     data    264       2
string_recover        fixed      1922     data    270       5
stuff_parameter       procedure  5403  program   2118       2
sub                   fixed      6310     data    453       5
subi                  fixed      6311     data    454       6
subtitle              character   229   string    294      11
symboldump            procedure  5802  program   2237       2
synthesize            procedure  9013  program   2817       1
  parameter  1        fixed     10492     data   2818       2
syt                   character   277   string    494      28
sytcard               fixed      7455     data    514       4
sytco                 fixed      7034     data    513      14
sytloc                fixed      6507     data    508      26
sytseg                bit (9)    6928     data    511      18
sytype                bit (9)    6401     data    501      34
target_register       fixed      1911     data    259      11
tdeclare              procedure  3643  program   1590       2
  parameter  1        fixed      9605     data   1591       3
text                  character   102   string    225      45
text_limit            fixed      1690     data    225      18
time_compile          fixed     10646     data   3884       5
time_finish           fixed     10647     data   3885       5
time_init             fixed     10645     data   3883       5
time_start            fixed     10644     data   3882       4
title                 character   228   string    293       5
token                 fixed      1383     data    190      18
top_macro             fixed      1895     data    244      10
trueloc               fixed      1912     data    260       3
tsa                   fixed      1925     data    273      12
tx                    bit (9)    1491     data    211       2
type                  fixed      8567     data    525      80
typename              character   262   string    484       2
undeclared_id         procedure  3280  program   1455       2
  parameter  1        fixed      9561     data   1456       9
var                   character   698   string    529      27
vocab                 character     5   string     71      10
x1                    character   254   string    460      18
x2                    character   255   string    461       4
x3                    character   256   string    462       2
x4                    character   257   string    463       5
x7                    character   258   string    464       4
x70                   character    98   string    196      21
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 128
 
 
                                        c o m p i l e r   s t a t i s t i c s
 
3972 lines containing 2116 statements were compiled.
no errors were detected.
12367 words of program, 10774 words of data, and 987 words of descriptors.  total core requirement 24128 words.
total time in compiler    = 1:21.909
initialization time       = 0:0.72
actual compilation time   = 1:6.835
post-compilation clean-up = 0:15.2
 
macro definitions:
 
name             at line ref count literal value
P#                   91        0    109
TRUE                194       27    "1"
BUSY                285        8    1
MAXR#                57        2    99
MAXL#                59        1    125
MAXP#                61        2    125
MAXS#                63        2    234
RSIZE                99        2    337
LSIZE               101        2    69
ASIZE               103        2    105
FALSE               194       25    "0"
AVAIL               285       35    0
VOCAB#               69        2    91
dx_size               0        2    500
VERSION              53        1    '4.0'
FOREVER             195        4    while TRUE
RELFILE             302       25    4
LIBFILE             303        2    5
FOR_MAX             332        3    50
CHRTYPE             475       18    6
SPECIAL             480       25    11
SYTSIZE             493       10    420
PAGE_MAX            297        4    54
DATAFILE            300       22    2
CODEFILE            301        7    3
END_TYPE            343        1    "(3)5000000"
VARIABLE            473       13    3
CONSTANT            474       18    4
BYTETYPE            477        6    8
DESCRIPT            479       12    10
PROCTYPE            482        5    13
TERMINAL#            67        7    42
CODE_TYPE           340        2    "(3)1000000"
SYMB_TYPE           341        1    "(3)2000000"
NAME_TYPE           344        1    "(3)6000000"
DESCLIMIT           355        4    1000
LABELTYPE           471        3    1
FIXEDTYPE           476       17    7
STACKSIZE           523       11    50
CASELIMIT           535        2    175
EJECT_PAGE          298        3    line_count = PAGE_MAX+1
BUFFERSIZE          317        7    18
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 129
name             at line ref count literal value
 
HISEG_TYPE          342        1    "(3)3000000"
START_TYPE          345        1    "(3)7000000"
START_STATE          65        1    1
MACRO_LIMIT         241        5    60
INTREQ_TYPE         346        1    "(3)10000000"
ACCUMULATOR         472       16    2
FORWARDTYPE         478        7    9
FORWARDCALL         481        6    12
CHARPROCTYPE        483        7    14
EXPANSION_LIMIT     245        1    300
 
id compares       = 8365
symbol table size = 414
macro definitions = 52
scan              = 26676
emitinst          = 13257
force ACCUMULATOR = 6066
arithemit         = 891
generate store    = 1048
free string area  = 14084
compactifications = 158
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 130
instruction frequencies
 
.init.    1
.inpt.    6
.outp.    42
.exit.    3
.filo.    24
.name.    7
calli     6
ildb      3
ldb       163
idpb      3
dpb       68
move      3215
movei     257
movem     2576
movn      3
movm      1
imuli     11
idivi     20
rot       4
lsh       329
lshc      7
blt       2
jrst      725
pushj     963
push      64
pop       64
popj      139
add       121
addi      317
addm      2
sub       74
subi      84
cail      15
caie      179
caile     7
caige     14
cain      37
caig      55
caml      16
came      22
camle     64
camge     7
camn      7
camg      8
jump      1
jumpe     107
jumpa     290
jumpge    1
jumpn     2
skipe     18
skipge    1
skipn     1
skipg     2
aosa      54
sojg      3
 
ulxcom.xpl  compiled 26-jul-1977  at 20:16:29 by VERSION 4.0                             page 131
instruction frequencies
 
setzm     841
and       89
andi      337
ior       77
setca     7
hll       5
hrli      2
hrlm      1
hlrz      1
hrrei     792
